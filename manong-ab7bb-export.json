{
  "Cloud" : [ {
    "directories" : [ {
      "directories" : [ {
        "expanded" : true,
        "name" : "EC2"
      }, {
        "expanded" : true,
        "name" : "Elastic Beanstalk"
      }, {
        "expanded" : true,
        "name" : "Lambda"
      }, {
        "expanded" : true,
        "name" : "Autoscaling"
      }, {
        "expanded" : true,
        "name" : "Elastic Load Balancer"
      }, {
        "expanded" : true,
        "name" : "VPC"
      } ],
      "expanded" : true,
      "name" : "Compute"
    }, {
      "directories" : [ {
        "expanded" : true,
        "name" : "EBS"
      }, {
        "expanded" : true,
        "files" : [ {
          "content" : "<img src=\"https://i.stack.imgur.com/QUYLL.png\" width=\"500px\">\n<img src=\"https://i.stack.imgur.com/wGplQ.png\" width=\"500px\">",
          "name" : "Access Denied while deleting root buckets"
        } ],
        "name" : "S3"
      }, {
        "expanded" : true,
        "name" : "CloudFront"
      }, {
        "expanded" : true,
        "name" : "Glacier"
      }, {
        "expanded" : true,
        "name" : "Snowball"
      }, {
        "expanded" : true,
        "name" : "Storage Gateway"
      } ],
      "expanded" : true,
      "name" : "Storage"
    }, {
      "directories" : [ {
        "expanded" : true,
        "name" : "RDS"
      }, {
        "expanded" : true,
        "name" : "DynamoDB"
      }, {
        "expanded" : true,
        "name" : "ElasticCache"
      }, {
        "expanded" : true,
        "name" : "RedShift"
      } ],
      "expanded" : true,
      "name" : "Database"
    }, {
      "directories" : [ {
        "expanded" : true,
        "name" : "Direct Connect"
      }, {
        "expanded" : true,
        "name" : "Route53"
      } ],
      "expanded" : true,
      "name" : "Networking"
    }, {
      "directories" : [ {
        "expanded" : true,
        "name" : "CloudWatch"
      }, {
        "expanded" : true,
        "name" : "CloudFormation"
      }, {
        "expanded" : true,
        "name" : "CloudTrail"
      }, {
        "expanded" : true,
        "name" : "OpsWorks"
      }, {
        "expanded" : true,
        "name" : "Management Console"
      }, {
        "expanded" : true,
        "name" : "Trusted Advisor"
      } ],
      "expanded" : true,
      "name" : "Management Tools"
    }, {
      "directories" : [ {
        "expanded" : true,
        "name" : "Identity Access Management(IAM)"
      }, {
        "expanded" : true,
        "name" : "Key Management Service(KMS)"
      } ],
      "expanded" : true,
      "name" : "Security and Identity"
    }, {
      "directories" : [ {
        "expanded" : true,
        "name" : "SQS"
      }, {
        "expanded" : true,
        "name" : "SES"
      }, {
        "expanded" : true,
        "name" : "SNS"
      } ],
      "expanded" : true,
      "name" : "Application Services"
    } ],
    "expanded" : true,
    "name" : "AWS"
  }, {
    "directories" : [ {
      "directories" : [ {
        "expanded" : true,
        "files" : [ {
          "content" : "",
          "name" : "Monasca-Transform"
        } ],
        "name" : "Transform"
      } ],
      "expanded" : true,
      "name" : "Monasca"
    } ],
    "expanded" : true,
    "name" : "OpenStack"
  }, {
    "expanded" : true,
    "name" : "Docker"
  } ],
  "Design" : [ {
    "expanded" : true,
    "files" : [ {
      "content" : "file2content",
      "name" : "mini twitter"
    } ],
    "name" : "Twitter"
  }, {
    "expanded" : true,
    "files" : [ {
      "content" : "<img src=\"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRzsfC3_TjqWY541kl2wfLZnOTL6nKrM1H8RQJCc9BgiU3pYcbnxg\" />",
      "name" : "UberEats"
    } ],
    "name" : "Uber"
  }, {
    "expanded" : true,
    "name" : "Netflix"
  }, {
    "expanded" : true,
    "name" : "Facebook"
  }, {
    "expanded" : true,
    "name" : "Linkedin"
  }, {
    "expanded" : true,
    "name" : "Monitor System"
  }, {
    "expanded" : true,
    "name" : "Dashboard"
  }, {
    "expanded" : true,
    "name" : "Dropbox"
  }, {
    "expanded" : true,
    "name" : "Twitch"
  }, {
    "directories" : [ {
      "expanded" : true,
      "name" : "Google Doc"
    }, {
      "expanded" : true,
      "name" : "Google Sheet"
    }, {
      "expanded" : true,
      "name" : "Google File System"
    }, {
      "expanded" : true,
      "name" : "Bigtable"
    } ],
    "expanded" : true,
    "name" : "Google"
  }, {
    "expanded" : true,
    "name" : "Whatsapp"
  }, {
    "expanded" : true,
    "name" : "Wechat"
  }, {
    "expanded" : true,
    "name" : "User System"
  }, {
    "expanded" : true,
    "name" : "SQL Database"
  }, {
    "expanded" : true,
    "name" : "NoSQL Database"
  }, {
    "expanded" : true,
    "name" : "Crawler"
  }, {
    "expanded" : true,
    "name" : "Tiny URL"
  }, {
    "expanded" : true,
    "name" : "Task Scheduler"
  }, {
    "expanded" : true,
    "name" : "Rate Limiter"
  }, {
    "expanded" : true,
    "name" : "Flicker"
  }, {
    "expanded" : true,
    "name" : "Recommender System"
  }, {
    "expanded" : true,
    "name" : "Message Broker"
  }, {
    "expanded" : true,
    "name" : "Chess"
  }, {
    "expanded" : true,
    "name" : "Elevator"
  }, {
    "expanded" : true,
    "name" : "ATM"
  }, {
    "expanded" : true,
    "name" : "Typeahead"
  }, {
    "expanded" : true,
    "name" : "Yelp"
  }, {
    "expanded" : true,
    "name" : "MapReduce"
  } ],
  "Java" : [ {
    "directories" : [ {
      "directories" : [ {
        "expanded" : true,
        "name" : "tst"
      } ],
      "expanded" : true,
      "files" : [ {
        "content" : "File class represents platform independent files and directories. It can create, delete, \nrename files and directories, but it have no access to their content.\nExamples:\n<code>\nFile file = new File(\"/path/to/file\");\nfile.mkdir(); //create a directory\nfile.mkdirs(); //create a directory with necessary intermediate directory\nfile.exists(); // true if file exisits\nfile.isFile();\nfile.isDirectory();\nfile.createNewFile();\nfile.renameTo(\"/newfilename\");\nfile.delete();\nif(file.isDirectory()) {\n    file.listFiles();\n}\nif(file.isDirectory()) {\n   file.listFiles(new FileFilter() {\n            @Override\n            public boolean accept(File pathname) {\n               return pathname.isFile();\n            }\n    });\n}\nSystem.out.println(file); //result: /path/to/file,  same as file.toString();\nSystem.out.println(file.getName()); //result: file\nSystem.out.println(file.getParent());\n</code>\n\nFrequently used methods:\n<code>\n//access file and path names\ngetName()\ngetPath()\ngetAbsoluteFile()\ngetAbsolutePath()\ngetParent()\n\n// file detection\nexists()\ncanRead()\ncanWrite()\nisFile()\nisDirectory()\n\n// file information\nlength()\nlastModify()\n\n// file and directory manipulation\ncreateNewFile()\nrenameTo(File f)\ndelete()\nmkDir()\nlist()\nlistFiles()\n</code>\n",
        "name" : "File"
      }, {
        "content" : "<code>\nFile dir = new File(\"dir\");\nif (!dir.exists()){\n    dir.mkdir();\n}\nFile file = new File(dir, \"raf.dat\");\nif (!file.exists()){\n    file.createNewFile();\n}\n\nRandomAccessFile raf = new RandomAccessFile(file, \"rw\");\nSystem.out.println(raf.getFilePointer()); // 0\nraf.write(\"a\"); // raf.write(byte b): write one byte. will write lower 8 bits of \"a\"\nint i = 12345678;\nraf.writeInt(i); // same as raf.write(i&gt;&gt;&gt;24();raf.write(i&gt;&gt;&gt;16);raf.write(i&gt;&gt;&gt;8);raf.write(i);\n\nString abc = \"abcdefg\";\nbyte[] bytes = abc.getBytes();\nraf.write(bytes);  //raf.write(byte[] bytes)\n\nraf.seek(0); // move file pointer to the beginning\n\nbyte[]  buffer = new byte[(int)raf.length()];\nraf.read(buffer); //raf.read(byte[] bytes)\n\nraf.seek(0);\nString line = raf.readLine();\nraf.close(); //never ever forget to close an opened file\n</code>",
        "name" : "RandomAccessFile"
      }, {
        "content" : "<code>\npublic class IOTest {\n\t\n\t/**\n\t * 利用字符输入输出流, 完成 hello.txt 文件的复制.\n\t * 把该文件复制为 hello2.txt\n\t * @throws IOException \n\t */\n\t\n\t/**\n\t * 利用字节输入输出流, 完成 hello.txt 文件的复制.\n\t * 把该文件复制为 hello2.txt\n\t * @throws IOException \n\t */\n\t@Test\n\tpublic void testCopyFile() throws IOException{\n\t\t//1. 创建定位到 hello.txt 的文件的输入流\n\t\tInputStream in = new FileInputStream(\"枚举类.avi\");\n\t\t\n\t\t//2. 创建定位到 hello2.txt 的文件输出流\n\t\tOutputStream out = new FileOutputStream(\"枚举类2.avi\");\n\t\t\n\t\t//3. 创建一个 byte 数组, 用于读写文件 \n\t\tbyte [] buffer = new byte[1024 * 10];\n\t\tint len = 0;\n\t\t\n\t\t//4. 读写文件:\n\t\t//in.read(buffer); out.write(buffer, 0, len);\n\t\twhile((len = in.read(buffer)) != -1){\n\t\t\tout.write(buffer);\n\t\t}\n\t\t\n\t\t//5. 关闭流资源. \n\t\tout.close();\n\t\tin.close();\n\t}\n\t\n\t/**\n\t * 测试字节输出流\n\t * @throws IOException\n\t */\n\t@Test\n\tpublic void testOutputStream() throws IOException{\n\t\tOutputStream out = new FileOutputStream(\"abcd.txt\");\n\t\t\n\t\tString content = \"www.atguigu.com\\nHello Java!\";\n//\t\tint len = 10;\n//\t\t\n//\t\tbyte [] contentBytes = content.getBytes();\n//\t\t\n//\t\tfor(int i = 0; i &lt; content.length() / 10; i++){\n//\t\t\t//把 String 拆分成多个 buffer\n//\t\t\tout.write(contentBytes, i * 10, len);\n//\t\t}\n//\t\t\n//\t\tif(content.length() % 10 != 0){\n//\t\t\tout.write(contentBytes, 10 * (content.length() / 10), \n//\t\t\t\t\tcontent.length() - (10 * (content.length() / 10)));\n//\t\t}\n\t\t\n\t\tout.write(content.getBytes());\n\t\t\n\t\tout.close();\n\t}\n\t\n\t/**\n\t * 测试字符输入流.\n\t * @throws IOException \n\t */\n\t@Test\n\tpublic void testReader() throws IOException{\n\t\t//利用字符输入流读取 hello.txt 文档的内容, 输出到控制台. \n\t\tReader reader = new FileReader(\"hello.txt\");\n\t\t\n\t\tchar [] buffer = new char[10];\n\t\tint len = 0;\n\t\t\n\t\twhile((len = reader.read(buffer)) != -1){\n\t\t\tfor(int i = 0; i &lt; len; i++){\n\t\t\t\tSystem.out.print(buffer[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\treader.close();\n\t}\n\t\n\t/**\n\t * 测试字节输入流\n\t * @throws IOException\n\t */\n\t@Test\n\tpublic void testInputStream() throws IOException{\n\t\t//1. 创建了一个字节输入流.\n\t\tInputStream in = new FileInputStream(\"hello.txt\");\n\t\n\t\t//2. 读取文件的内容\n\t\t//2.1 第一读取一个字节. 效率很低, 不建议这样读. -1 表示读取到文件的结尾处\n//\t\tint result = in.read();\n//\t\t\n//\t\twhile(result != -1){\n//\t\t\tSystem.out.print((char)result);\n//\t\t\tresult = in.read();\n//\t\t}\n\t\t\n\t\t//2.2 一次读取一组: 一组字符. \n\t\t//返回一次实际读取的字节数, 若为 -1 表示读取到文件的结尾\n//\t\tbyte [] buffer = new byte[10];\n//\t\tint len = 0;\n//\t\t\n//\t\twhile((len = in.read(buffer)) != -1){\n//\t\t\tfor(int i = 0; i &lt; len; i++){\n//\t\t\t\tSystem.out.print((char)buffer[i]);\n//\t\t\t}\n//\t\t}\n\t\t\n\t\t//2.3 把内容读取到字节数组的部分连续的元素中.\n\t\tbyte [] result = new byte[1024 * 10];\n\t\tin.read(result, 10, in.available());\n\t\t\n\t\t//3. 关闭流资源\n\t\tin.close();\n\t}\n\n\t@Test\n\tpublic void testInputObjectStream() throws IOException, Exception {\n\t\tInputStream in = new FileInputStream(\"d:\\\\obj.txt\");\n\t\tObjectInputStream objectInputStream = new ObjectInputStream(in);\n\n\t\tObject obj = objectInputStream.readObject();\n\t\tSystem.out.println(obj);\n\n\t\tobjectInputStream.close();\n\t\tin.close();\n\t}\n\n\t@Test\n\tpublic void testSerializable() throws IOException {\n\t\tPerson person = new Person(\"AA\", 12);\n\t\tperson.setAddress(new Address(\"BeiJing\"));\n\n\t\t// 使用 ObjectOutputStream 把对象写到硬盘上\n\t\tOutputStream out = new FileOutputStream(\"d:\\\\obj.txt\");\n\t\tObjectOutputStream objectOutputStream = new ObjectOutputStream(out);\n\n\t\tobjectOutputStream.writeObject(person);\n\n\t\tout.close();\n\t\tobjectOutputStream.close();\n\t}\n\n\t/**\n\t * 先创建两个字节输入输出流: 分别指向 hello.txt, hello5.txt 然后再转为字符输入输出流, 在转为带缓冲的字符输入输出流\n\t * \n\t * 完成文件的复制.\n\t * \n\t * @throws IOException\n\t */\n\t@Test\n\tpublic void testOutputStreamWriter() throws IOException {\n\t\tInputStream in = new FileInputStream(\"hello.txt\");\n\t\tReader reader = new InputStreamReader(in);\n\t\tBufferedReader bufferedReader = new BufferedReader(reader);\n\n\t\tOutputStream out = new FileOutputStream(\"hello5.txt\");\n\t\tWriter writer = new OutputStreamWriter(out);\n\t\tBufferedWriter bufferedWriter = new BufferedWriter(writer);\n\n\t\tString str = null;\n\t\tint i = 0;\n\t\twhile ((str = bufferedReader.readLine()) != null) {\n\t\t\tif (i != 0) {\n\t\t\t\tbufferedWriter.write(\"\\n\");\n\t\t\t}\n\n\t\t\tbufferedWriter.write(str);\n\t\t\ti++;\n\t\t}\n\n\t\tin.close();\n\t\treader.close();\n\t\tbufferedReader.close();\n\n\t\tbufferedWriter.close();\n\t\twriter.close();\n\t\tout.close();\n\t}\n\n\t@Test\n\tpublic void testInputStreamReader() throws IOException {\n\t\t// 指向文档的字节流\n\t\tInputStream in = new FileInputStream(\"hello.txt\");\n\n\t\t// 把上面的流转为字符流\n\t\tReader reader = new InputStreamReader(in);\n\n\t\t// 把字符流转为带缓冲的字符流\n\t\tBufferedReader bufferedReader = new BufferedReader(reader);\n\n\t\t// BufferedReader bufferedReader2 =\n\t\t// new BufferedReader(new InputStreamReader(new\n\t\t// FileInputStream(\"hello.txt\")));\n\n\t\tString str = null;\n\t\twhile ((str = bufferedReader.readLine()) != null) {\n\t\t\tSystem.out.println(str);\n\t\t}\n\n\t\t// 关闭:\n\t\tin.close();\n\t\treader.close();\n\t\tbufferedReader.close();\n\t}\n\n\t/**\n\t * 利用BufferedInputStream 和 BufferedOutputStream 完成 hello.txt 文件到 hello5.txt\n\t * 文件的复制.\n\t * \n\t * @throws IOException\n\t * \n\t */\n\t@Test\n\tpublic void testBufferedInputStreamAndBufferedOutputStream()\n\t\t\tthrows IOException {\n\t\tInputStream in = new FileInputStream(\"hello.txt\");\n\t\tBufferedInputStream bufferedInputStream = new BufferedInputStream(in);\n\n\t\tOutputStream out = new FileOutputStream(\"hello5.txt\");\n\t\tBufferedOutputStream bufferedOutputStream = new BufferedOutputStream(\n\t\t\t\tout);\n\n\t\tbyte[] buffer = new byte[1024];\n\t\tint len = 0;\n\n\t\twhile ((len = bufferedInputStream.read(buffer)) != -1) {\n\t\t\tbufferedOutputStream.write(buffer, 0, len);\n\t\t}\n\n\t\tbufferedInputStream.close();\n\t\tbufferedOutputStream.close();\n\t}\n\n\t/**\n\t * 复制 hello.txt 为 hello4.txt\n\t * \n\t * @throws IOException\n\t */\n\t@Test\n\tpublic void testBufferedReaderAndBufferedWriter() throws IOException {\n\t\t// 1. 创建 BufferedReader 和 BufferdWriter\n\t\tReader in = new FileReader(\"hello.txt\");\n\t\tBufferedReader bufferedReader = new BufferedReader(in);\n\n\t\tWriter out = new FileWriter(\"hello4.txt\");\n\t\tBufferedWriter bufferedWriter = new BufferedWriter(out);\n\n\t\t// 2. 进行读写操作\n\t\tString str = null;\n\n\t\tint i = 0;\n\n\t\twhile ((str = bufferedReader.readLine()) != null) {\n\t\t\tif (i != 0) {\n\t\t\t\tbufferedWriter.write(\"\\n\");\n\t\t\t}\n\t\t\tbufferedWriter.write(str);\n\t\t\ti++;\n\t\t}\n\n\t\t// 3. 关闭 IO 流: 直接关闭包装流, 内部会关闭节点流\n\t\tbufferedReader.close();\n\t\tbufferedWriter.close();\n\t}\n\n\t/**\n\t * 利用字符输入输出流, 完成 hello.txt 文件的复制. 把该文件复制为 hello2.txt\n\t * \n\t * @throws IOException\n\t * @throws IOException\n\t */\n\t@Test\n\tpublic void testCopyByReaderAndWriter() throws IOException {\n\t\t// 1. 创建字符输入, 输出流\n\t\tReader reader = new FileReader(\"hello.txt\");\n\t\tWriter writer = new FileWriter(\"hello2.txt\");\n\n\t\t// 3. 创建一个字符数组.\n\t\tchar[] buffer = new char[10];\n\n\t\t// 4. 利用循环读取源文件, 并向目标文件写入\n\t\t// 5. 注意: 使用的写入的方法: write(char[] cbuf, int off, int len)\n\t\t// 而不能直接使用 write(char[] cbuf)\n\t\tint len = 0;\n\t\twhile ((len = reader.read(buffer)) != -1) {\n\t\t\twriter.write(buffer, 0, len);\n\t\t\t// System.out.println(len);\n\t\t}\n\n\t\t// 2. 关闭流资源\n\t\treader.close();\n\t\twriter.close();\n\t}\n}\n</code>",
        "name" : "IO Examples"
      }, {
        "content" : "1. The object to be serialized must be from class that implements Serializable interface.\nAll the fields of the object must implements Serializable interface too.\n\n2. Serialization and deserialization\n<code>\nString file = \"demo/obj.dat\";\n//1.serialization\nObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));\nStudent stu = new Student(\"10001\", \"Tommy\", 20);\noos.writeObject(stu);\noos.flush();\noos.close();\n\n//2. deserialization\nObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));\nStudent stu2 = (Student)ois.readObject();\nSystem.out.println(stu2);\nois.close();\n</code>\n\n3. If a class implements Serializable interface, its subclass can be serialized too.\n\n4. When deserializing a subclass, if its parent class did not implement Serializable interface, \nthen the parent class construction function will be invoked.",
        "name" : "Object Serialization"
      }, {
        "content" : "1. input/output stream system:\n<table class=\"table table-bordered\">\n<tr>\n  <th>Type</th>\n  <th>Interfaces</th>\n  <th>Raw streams</th>\n  <th>Buffered streams</th>\n  <th>Transformation</th>\n  <th>Serialization</th>\n</tr>\n<tr>\n  <td rowspan=\"2\">ByteStream</td>\n  <td>InputStream</td>\n  <td>FileInputStream</td>\n  <td>BufferedInputStream</td>\n  <td></td>\n  <td>ObjectInputStream</td>\n</tr>\n<tr>\n  <td>OutputStream</td>\n  <td>FileOutputStream</td>\n  <td>BufferedOutputStream</td>\n  <td></td>\n  <td>ObjectOutputStream</td>\n</tr>\n<tr>\n  <td rowspan=\"2\">Char Stream</td>\n  <td>Reader</td>\n  <td>FileReader</td>\n  <td>BufferedReader</td>\n  <td>InputStreamReader</td>\n  <td></td>\n</tr>\n<tr>\n  <td>Writer</td>\n  <td>FileWriter</td>\n  <td>BufferedWriter</td>\n  <td>OutputStreamWriter</td>\n  <td></td>\n</tr>\n</table>\n\n2. Examples:\n1) copy file:\n<code>\nInputStream in = new FileInputStream(filename1);\nOutputStream out  = new FileOutputStream(filename2);\nint len = 0;\nbyte[] buffer = new byte[1024 * 10];\nwhile ((len = in.read(buffer)) != -1) {\n    out.write(buffer, 0, len);\n}\nin.close();\nout.close();\n</code>\n\n2) buffered reader\n<code>\nBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(fileName)));\n</code>",
        "name" : "IOStreams"
      }, {
        "content" : "",
        "name" : "test"
      } ],
      "name" : "IO"
    }, {
      "expanded" : true,
      "files" : [ {
        "content" : "1. <b>JSON data types:</b> string, number, boolean, null.\n<b>JSON data structures:</b> Object, Array.\n\nAn Object type is key: value pairs wrapped with \"{}\". The key must be string type.\nAn Array type is a group of data elements wrapped with \"[]\".\n\n",
        "name" : "JSON Basics"
      }, {
        "content" : "The official Java package for JSON manipulation is org.json\n\n1. Installation:\nTo use the package, include the following dependency in maven pom file:\n<code>\n&lt;dependency&gt;\n   &lt;groupId&gt;org.json&lt;/groupId&gt;\n   &lt;artifactId&gt;json&lt;/artifactId&gt;\n   &lt;version&gt;{{please go find the latest version and put here}}&lt;/version&gt;\n&lt;/dependency&gt;\n</code>\n\n2. Create JSON object directly:\n<code>\nJSONObject Jack = new JSONObject();\nObject nullObject = null;\ntry {\n  Jack.put(\"name\", \"Jack\");\n  Jack.put(\"age\", 27);\n  Jack.put(\"major\", new String[]{\"Computer Science\", \"Biology\"});\n  Jack.put(\"married\", false);\n  Jack.put(\"car\", nullObject);\n  System.out.println(Jack.toString());\n} catch (JSONException e) {\n  e.printStackTrace();\n}\n</code>\n\n3. Create JSON object from Map:\n<code>\nMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();\nObject nullObject = null;\nmap.put(\"name\", \"Jack\");\nmap.put(\"age\", 27);\nmap.put(\"major\", new String[]{\"Computer Science\", \"Biology\"});\nmap.put(\"married\", false);\nmap.put(\"car\", nullObject);\nSystem.out.println(new JSONObject(map).toString());\n</code>\n\n4. Create JSON object from Java bean:\nThe bean:\n<code>\npublic class Employee {\n\n\tprivate String name;\n\tprivate int age;\n\tprivate String[] majors;\n\tprivate Object car;\n\tprivate boolean married;\n\tpublic String getName() {  return name;  }\n\tpublic void setName(String name) {  this.name = name;  }\n\tpublic int getAge() {  return age;  }\n\tpublic void setAge(int age) {  this.age = age;  }\n\tpublic String[] getMajors() {  return majors;  }\n\tpublic void setMajors(String[] majors) {  this.majors = majors;  }\n\tpublic Object getCar() {  return car;  }\n\tpublic void setCar(Object car) {  this.car = car;  }\n\tpublic boolean isMarried() {  return married;  }\n\tpublic void setMarried(boolean married) {  this.married = married;  }\n}\n</code>\nCreate the JSON object from the bean:\n<code>\nEmployee Jack = new Employee();\nJack.setName(\"Jack\");\nJack.setAge(27);\nJack.setMarried(false);\nJack.setCar(null);\nJack.setMajors(new String[]{\"Computer Science\", \"Biology\"});\nSystem.out.println(new JSONObject(Jack).toString());\n</code>\n\n5. Create JSON object from string:\n<code>\n//the jsonString could be from anywhere, for example, a file or a http response\nString jsonString = \"{\\\"majors\\\": [\\\"Computer Science\\\", \\\"Biology\\\"], \\\"car\\\": null, \\\"age\\\": 27, \\\"married\\\": false, \\\"name\\\": \\\"Jack\\\"}\";\nSystem.out.println(new JSONObject(jsonString).toString());\n</code>\n\n6. Get values from JSON object:\n<code>\nString jsonString = \"{\\\"majors\\\": [\\\"Computer Science\\\", \\\"Biology\\\"], \\\"car\\\": null, \\\"age\\\": 27, \\\"married\\\": false, \\\"name\\\": \\\"Jack\\\"}\";\nJSONObject jsonObject = new JSONObject(jsonString);\nString name = jsonObject.getString(\"name\");\nInteger age = jsonObject.getInteger(\"age\");\nBoolean married = jsonObject.getBoolean(\"married\");\nJSONArray majors = jsonObject.getJSONArray(\"majors\");\nfor (int i = 0; i &lt; majors.length(); i++) {\n  String major = (String) majors.get(i);\n  System.out.println(major);\n}\n\nif (jsonObject.isNull(\"car\")) {\n   System.out.println(\"No car\"):\n}\n</code>",
        "name" : "JSON by org.json"
      }, {
        "content" : "1. Installation:\n<code>\n&lt;dependency&gt;\n   &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;\n   &lt;artifactId&gt;gson&lt;/artifactId&gt;\n   &lt;version&gt;{{please go find the latest version and put here}}&lt;/version&gt;\n&lt;/dependency&gt;\n</code>\n\n2. Create JSON by gson: \nThe bean:\n<code>\npublic class Employee {\n\tprivate String name;\n\tprivate int age;\n\tprivate String[] majors;\n\tprivate Object car;\n\tprivate boolean married;\n\tpublic String getName() {  return name;  }\n\tpublic void setName(String name) {  this.name = name;  }\n\tpublic int getAge() {  return age;  }\n\tpublic void setAge(int age) {  this.age = age;  }\n\tpublic String[] getMajors() {  return majors;  }\n\tpublic void setMajors(String[] majors) {  this.majors = majors;  }\n\tpublic Object getCar() {  return car;  }\n\tpublic void setCar(Object car) {  this.car = car;  }\n\tpublic boolean isMarried() {  return married;  }\n\tpublic void setMarried(boolean married) {  this.married = married;  }\n}\n</code>\nInitialize the bean:\n<code>\nEmployee Jack = new Employee();\nJack.setName(\"Jack\");\nJack.setAge(27);\nJack.setMarried(false);\nJack.setCar(null);\nJack.setMajors(new String[]{\"Computer Science\", \"Biology\"});\n</code>\n2.1 gson.toJson():\n<code>\nGson gson = new Gson();\nString jsonString = gson.toJson(Jack);\n</code>\n\n2.2 GsonBuilder:\n<code>\nGsonBuilder gsonBuilder = new GsonBuilder();\ngsonBuilder.setPrettyPrinting();\nGson gson = gsonBuilder.create();\nString jsonString = gson.toJson(Jack);\n</code>\n\n3. Create Java bean object from JSON by gson\n<code>\nString jsonString = \"{\\\"majors\\\": [\\\"Computer Science\\\", \\\"Biology\\\"], \\\"car\\\": null, \\\"age\\\": 27, \\\"married\\\": false, \\\"name\\\": \\\"Jack\\\"}\";\nGson gson = new Gson();\nEmployee employee = gson.fromJson(jsonString, Employee.class);\n</code>\n\n4. Transformation of Date:\nThe bean:\n<code>\nimport java.util.Date;\npublic class Birthday {\n    private Date birthday;\n    public Date getBirthday(){  return birthday;  }\n    public void setBirthday(Date birthday) { this.birthday = birthday;  }\n}\n</code>\n\n<code>\nGson gson  = new GsonBuilder().setDateFormat(\"yyyy-MM-dd\").create();\nBirthday bday = gson.fromJson(jsonString, Birthday.class);\nSystem.out.println(bday.getBirthday());\n</code>\n\n5. Transformation of collections:\nThe bean:\n<code>\npublic class Employee {\n\tprivate String name;\n\tprivate int age;\n\tprivate List&lt;String&gt; majors;\n\tprivate Object car;\n\tprivate boolean married;\n\tpublic String getName() {  return name;  }\n\tpublic void setName(String name) {  this.name = name;  }\n\tpublic int getAge() {  return age;  }\n\tpublic void setAge(int age) {  this.age = age;  }\n\tpublic List&lt;String&gt; getMajors() {  return majors;  }\n\tpublic void setMajors(List&lt;String&gt; majors) {  this.majors = majors;  }\n\tpublic Object getCar() {  return car;  }\n\tpublic void setCar(Object car) {  this.car = car;  }\n\tpublic boolean isMarried() {  return married;  }\n\tpublic void setMarried(boolean married) {  this.married = married;  }\n}\n</code>\nJust do the same thing as before and Gson will automatically transform collection field in the bean.\n<code>\nString jsonString = \"{\\\"majors\\\": [\\\"Computer Science\\\", \\\"Biology\\\"], \\\"car\\\": null, \\\"age\\\": 27, \\\"married\\\": false, \\\"name\\\": \\\"Jack\\\"}\";\nGson gson = new Gson();\nEmployee employee = gson.fromJson(jsonString, Employee.class);\nSystem.out.println(employee.getMajors().getClass());\n</code>\n",
        "name" : "GSON"
      } ],
      "name" : "JSON"
    }, {
      "expanded" : true,
      "files" : [ {
        "content" : "<code>\n/**\n * 反射小结:\n * \n * 1. Class: 是一个类; 一个描述类的类. 封装了描述方法的 Method, 描述字段的 Filed,\n * 描述构造器的 Constructor 等属性.\n * \n * 2. 如何得到 Class 对象:\n * 2.1 Person.class\n * 2.2 person.getClass()\n * 2.3 Class.forName(\"com.atguigu.javase.Person\")\n * \n * 3. 关于 Method:\n * 3.1 如何获取 Method:\n * 1). getDeclaredMethods: 得到 Method 的数组.\n * 2). getDeclaredMethod(String methondName, Class ... parameterTypes)\n * \n * 3.2 如果调用 Method\n * 1). 如果方法时 private 修饰的, 需要先调用 Method 的　setAccessible(true), 使其\n * 变为可访问\n * 2). method.invoke(obj, Object ... args);\n * \n * 4. 关于 Field:\n * 3.1 如何获取 Field: getField(String fieldName)\n * 3.2 如何获取 Field 的值: \n * 1). setAccessible(true)\n * 2). field.get(Object obj)\n * 3.3 如何设置 Field 的值:\n * field.set(Obejct obj, Object val)\n * \n * 5. 了解 Constructor 和 Annotation \n * \n * 6. 反射和泛型.\n * 6.1 getGenericSuperClass: 获取带泛型参数的父类, 返回值为: BaseDao&lt;Employee, String&gt;\n * 6.2 Type 的子接口: ParameterizedType\n * 6.3 可以调用 ParameterizedType 的 Type[] getActualTypeArguments() 获取泛型\n * 参数的数组. \n * \n * 7. 搞定 ReflectionUtils 即可. \n *\n */\npublic class ReflectionTest {\n\n\t/**\n\t * 通过反射, 获得定义 Class 时声明的父类的泛型参数的类型\n\t * 如: public EmployeeDao extends BaseDao&lt;Employee, String&gt;\n\t * @param clazz: 子类对应的 Class 对象\n\t * @param index: 子类继承父类时传入的泛型的索引. 从 0 开始\n\t * @return\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static Class getSuperClassGenricType(Class clazz, int index){\n\t\t\n\t\tType type = clazz.getGenericSuperclass();\n\t\t\n\t\tif(!(type instanceof ParameterizedType)){\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tParameterizedType parameterizedType = \n\t\t\t\t(ParameterizedType) type;\n\t\t\n\t\tType [] args = parameterizedType.getActualTypeArguments();\n\t\t\n\t\tif(args == null){\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif(index &lt; 0 || index &gt; args.length - 1){\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tType arg = args[index];\n\t\tif(arg instanceof Class){\n\t\t\treturn (Class) arg;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * 通过反射, 获得 Class 定义中声明的父类的泛型参数类型\n\t * 如: public EmployeeDao extends BaseDao&lt;Employee, String&gt;\n\t * @param &lt;T&gt;\n\t * @param clazz\n\t * @return\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static&lt;T&gt; Class&lt;T&gt; getSuperGenericType(Class clazz){\n\t\treturn getSuperClassGenricType(clazz, 0);\n\t}\n\t\n\t@Test\n\tpublic void testGetSuperClassGenricType(){\n\t\tClass clazz = EmployeeDao.class;\n\t\t//Employee.class\n\t\tClass argClazz = getSuperClassGenricType(clazz, 0);\n\t\tSystem.out.println(argClazz);\n\t\t\n\t\t//String.class\n\t\targClazz = getSuperClassGenricType(clazz, 1);\n\t\tSystem.out.println(argClazz);\n\t}\n\t\n\t@Test\n\tpublic void testGenericAndReflection(){\n\t\t\n\t\tPersonDao personDao = new PersonDao();\n\t\t\n\t\tPerson entity = new Person();\n\t\tpersonDao.save(entity);\n\t\t\n\t\t//class com.atguigu.javase.lesson12.Person\n\t\tPerson result = personDao.get(1); \n\t}\n\t\n\t/**\n\t * Annotation 和 反射:\n\t * 1. 获取 Annotation\n\t * \n\t * getAnnotation(Class&lt;T&gt; annotationClass) \n\t * getDeclaredAnnotations() \n\t * \n\t */\n\t@Test\n\tpublic void testAnnotation() throws Exception{\n\t\tString className = \"com.atguigu.javase.lesson12.Person\";\n\t\t\n\t\tClass clazz = Class.forName(className);\n\t\tObject obj = clazz.newInstance();\n\t\t\n\t\tMethod method = clazz.getDeclaredMethod(\"setAge\", int.class);\n\t\tint val = 6;\n\t\t\n\t\tAnnotation annotation = method.getAnnotation(AgeValidator.class);\n\t\tif(annotation != null){\n\t\t\tif(annotation instanceof AgeValidator){\n\t\t\t\tAgeValidator ageValidator = (AgeValidator) annotation;\n\t\t\t\t\n\t\t\t\tif(val &lt; ageValidator.min() || val &gt; ageValidator.max()){\n\t\t\t\t\tthrow new RuntimeException(\"年龄非法\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmethod.invoke(obj, 20);\n\t\tSystem.out.println(obj);  \n\t\t\n\t}\n\t\n\t/**\n\t * Constructor: 代表构造器\n\t * @throws ClassNotFoundException \n\t * @throws SecurityException \n\t * @throws NoSuchMethodException \n\t * @throws InvocationTargetException \n\t * @throws IllegalArgumentException \n\t * @throws IllegalAccessException \n\t * @throws InstantiationException \n\t */\n\t@Test\n\tpublic void testConstructor() throws SecurityException, ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException{\n\t\tString className = \"com.atguigu.javase.lesson12.Person\";\n\t\tClass&lt;Person&gt; clazz = (Class&lt;Person&gt;) Class.forName(className);\n\t\t\n\t\t//1. 获取 Constructor 对象\n\t\tConstructor&lt;Person&gt; [] constructors = \n\t\t\t\t(Constructor&lt;Person&gt;[]) Class.forName(className).getConstructors();\n\t\t\n\t\tfor(Constructor&lt;Person&gt; constructor: constructors){\n\t\t\tSystem.out.println(constructor); \n\t\t}\n\t\t\n\t\tConstructor&lt;Person&gt; constructor = clazz.getConstructor(String.class, int.class);\n\t\tSystem.out.println(constructor); \n\t\t\n\t\t//2. 调用构造器的 newInstance() 方法创建对象\n\t\tObject obj = constructor.newInstance(\"尚硅谷\", 1);\n\t\t\t\t\n\t}\n\t\n\t@Test\n\tpublic void testClassField() throws ClassNotFoundException, InstantiationException, IllegalAccessException{\n\t\tString className = \"com.atguigu.javase.lesson12.Student\";\n\t\tString fieldName = \"age\"; //可能为私有, 可能在其父类中. \n\t\tObject val = 20;\n\t\t\n\t\t//创建 className 对应类的对象, 并为其 fieldName 赋值为 val\n\t\tObject obj = null;\n\t\t\n\t\tClass clazz = Class.forName(className);\n\t\tField field = getField(clazz, fieldName);\n\t\t\n\t\tobj = clazz.newInstance();\n\t\tsetFieldValue(obj, field, val);\n\t\t\n\t\tStudent stu = (Student) obj;\n\t\tSystem.out.println(stu.getAge()); //20\n\t}\n\t\n\tpublic Object getFieldValue(Object obj, Field field) throws IllegalArgumentException, IllegalAccessException{\n\t\tfield.setAccessible(true);\n\t\treturn field.get(obj);\n\t}\n\n\tpublic void setFieldValue(Object obj, Field field, Object val)\n\t\t\tthrows IllegalAccessException {\n\t\tfield.setAccessible(true);\n\t\tfield.set(obj, val);\n\t}\n\n\tpublic Field getField(Class clazz, String fieldName) {\n\t\tField field = null;\n\t\tfor(Class clazz2 = clazz; clazz2 != Object.class; \n\t\t\t\tclazz2 = clazz2.getSuperclass()){\n\t\t\ttry {\n\t\t\t\tfield = clazz2.getDeclaredField(fieldName);\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t\treturn field;\n\t}\n\t\n\t/**\n\t * Field: 封装了字段的信息. \n\t * 1. 获取字段:\n\t * 1.1 Field [] fields = clazz.getDeclaredFields();\n\t * 1.2 Field field2 = clazz.getDeclaredField(\"age\");\n\t * \n\t * 2. 获取指定对象的指定字段的值.\n\t * public Object get(Object obj)\n\t * obj 为字段所在的对象.\n\t * \n\t * Object val = field.get(person);\n\t * \n\t * 注意: 若该字段是私有的, 需先调用 setAccessible(true) 方法\n\t * \n\t * 3. 设置指定对象的指定字段的值\n\t * public void set(Object obj, Object value)\n\t * obj: 字段所在的对象\n\t * value: 要设置的值.\n\t * \n\t * field.set(person, \"atguigu\");\n\t * \n\t * \n\t */\n\t@Test\n\tpublic void testField() throws ClassNotFoundException, NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException{\n\t\tString className = \"com.atguigu.javase.lesson12.Person\";\n\t\tClass clazz = Class.forName(className);\n\t\t\n\t\t//1. 获取字段\n\t\t//1.1 获取 Field 的数组\n\t\tField [] fields = clazz.getDeclaredFields();\n\t\tfor(Field field: fields){\n\t\t\tSystem.out.println(field.getName()); \n\t\t}\n\t\t\n\t\t//1.2 获取指定名字的 Field\n\t\tField field = clazz.getDeclaredField(\"name\");\n\t\tSystem.out.println(field.getName()); \n\t\t\n\t\tPerson person = new Person(\"ABC\", 12);\n\t\t//2. 获取指定对象的 Field 的值\n\t\tObject val = field.get(person);\n\t\tSystem.out.println(val);\n\t\t\n\t\t//3. 设置指定对象的 Field 的值\n\t\tfield.set(person, \"atguigu\");\n\t\tSystem.out.println(person.getName());\n\t\t\n\t\t//4. 若该字段是私有的, 需要调用 setAccessible(true) 方法\n\t\tField field2 = clazz.getDeclaredField(\"age\");\n\t\tfield2.setAccessible(true);\n\t\tSystem.out.println(field2.get(person)); \n\t}\n\t\n\t/**\n\t * 获取 clazz 的 methodName 方法. 该方法可能是私有方法, 还可能在父类中(私有方法)\n\t * @param clazz\n\t * @param methodName\n\t * @param parameterTypes\n\t * @return\n\t */\n\tpublic Method getMethod(Class clazz, String methodName, \n\t\t\tClass ... parameterTypes){\n\t\t\n\t\tfor(;clazz != Object.class; clazz = clazz.getSuperclass()){\n\t\t\ttry {\n\t\t\t\tMethod method = clazz.getDeclaredMethod(methodName, parameterTypes);\n\t\t\t\treturn method;\n\t\t\t} catch (Exception e) {}\t\t\t\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * 由 Object 数组得到其对应的 Class 数组.\n\t * @param args\n\t * @return\n\t */\n\tpublic Class [] getParamerTypes(Object ... args){\n\t\tClass [] parameterTypes = new Class[args.length];\n\t\t\n\t\tfor(int i = 0; i &lt; args.length; i++){\n\t\t\tparameterTypes[i] = args[i].getClass();\n\t\t}\n\t\t\n\t\treturn parameterTypes;\n\t}\n\t\n\t/**\n\t * 执行 obj 对象的 method 方法, 参数值为 args\n\t * @param obj\n\t * @param method\n\t * @param args\n\t * @return\n\t * @throws InstantiationException\n\t * @throws IllegalAccessException\n\t * @throws InvocationTargetException\n\t */\n\tpublic Object invokeMethod(Object obj, Method method, Object[] args)\n\t\t\tthrows InstantiationException, IllegalAccessException,\n\t\t\tInvocationTargetException {\n\t\tmethod.setAccessible(true);\n\t\tObject result = method.invoke(obj, args);\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * @throws Exception \n\t * \n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Test\n\tpublic void testClassMethod() throws Exception{\n\t\t//1. 全类名\n\t\tString className = \"com.atguigu.javase.lesson12.Student\";\n\t\t//2. 方法名: 可能在 1 给的类中, 也可能在父类中. 可能是私有方法, 也可能是公有方法.\n\t\tString methodName = \"method3\";\n\t\t//3. 执行 2 对应的方法时需要传入的参数列表. \n\t\tObject [] args = {\"尚硅谷\", 25};\n\t\t\n\t\t//根据以下条件, 执行 methodName 对应的方法, 并打印返回值.\n\t\t\n\t\tClass clazz = Class.forName(className);\n\t\tClass [] parameterTypes = getParamerTypes(args);\n\t\t\n\t\tMethod method = getMethod(clazz, methodName, parameterTypes);\n\t\tObject result = invokeMethod(clazz.newInstance(), method, args);\n\t\t\n\t\tSystem.out.println(result); \n\t}\n\n\t\n\t\n\t/**\n\t * \n\t * @param obj: 某个类的一个对象\n\t * @param methodName: 类的一个方法的方法名. \n\t * 该方法也可能是私有方法, 还可能是该方法在父类中定义的(私有)方法\n\t * @param args: 调用该方法需要传入的参数\n\t * @return: 调用方法后的返回值\n\t */\n\tpublic Object invoke2(Object obj, String methodName, \n\t\t\tObject ... args){\n\t\t//1. 获取 Method 对象\n\t\tClass [] parameterTypes = new Class[args.length];\n\t\tfor(int i = 0; i &lt; args.length; i++){\n\t\t\tparameterTypes[i] = args[i].getClass();\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tMethod method = getMethod(obj.getClass(), methodName, parameterTypes);\n\t\t\tmethod.setAccessible(true);\n\t\t\t//2. 执行 Method 方法\n\t\t\t//3. 返回方法的返回值\n\t\t\treturn method.invoke(obj, args);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\t\n\t@Test\n\tpublic void testGetMethod() throws Exception{\n\t\tClass clazz = Class.forName(\"com.atguigu.javase.lesson12.Student\");\n\t\n\t\tMethod method = getMethod(clazz, \"method1\", Integer.class);\n\t\tSystem.out.println(method); \n\t\t\n\t\tmethod = getMethod(clazz, \"method2\");\n\t\tSystem.out.println(method); \n\t}\n\t\n\t@Test\n\tpublic void testInvoke2(){\n\t\tObject obj = new Student();\n\t\t\n\t\tinvoke2(obj, \"method1\", 10); \n\t\t//Student 类的 method1() 方法被调用, 打印: private void method1\n\t\t\n\t\tObject result = invoke2(obj, \"method2\"); \n\t\t//Student 类的父类的 method2() 方法被调用, 返回值为 \"private String method2\"\n\t\tSystem.out.println(result);\n\t\n\t}\n\t\n\t/**\n\t * 若通过 Method 的 invoke() 方法调用方法, 而访问权限不足, 则可以先使该方法\n\t * 变为可被访问的: \n\t * \n\t * method.setAccessible(true);\n\t * \n\t * @throws Exception\n\t */\n\t@Test\n\tpublic void testInvokePrivateMethod() throws Exception{\n\t\tObject obj = new Student();\n\t\t\n\t\tClass clazz = obj.getClass();\n\t\tMethod method = clazz.getDeclaredMethod(\"method1\", Integer.class);\n\t\tSystem.out.println(method); \n\t\t\n\t\t//若需要通过反射执行私有方法\n\t\tmethod.setAccessible(true);\n\t\t\n\t\tmethod.invoke(obj, 10);\n\t}\n\t\n\t/**\n\t * 获取当前类的父类:\n\t * 直接调动 Class 对象的 getSuperClass() 方法. \n\t * @throws Exception \n\t */\n\t@Test\n\tpublic void testGetSuperClass() throws Exception{\n\t\tString className = \"com.atguigu.javase.lesson12.Student\";\n\t\t\n\t\tClass clazz = Class.forName(className);\n\t\tClass superClazz = clazz.getSuperclass();\n\t\t\n\t\tSystem.out.println(superClazz); \n\t}\n\t\n\t/**\n\t * \n\t * @param className: 某个类的全类名\n\t * @param methodName: 类的一个方法的方法名. 该方法也可能是私有方法. \n\t * @param args: 调用该方法需要传入的参数\n\t * @return: 调用方法后的返回值\n\t */\n\tpublic Object invoke(String className, String methodName, Object ... args){\n\t\tObject obj = null;\n\t\t\n\t\ttry {\n\t\t\tobj = Class.forName(className).newInstance();\n\t\t\treturn invoke(obj, methodName, args);\n\t\t}catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * \n\t * @param obj: 方法执行的那个对象. \n\t * @param methodName: 类的一个方法的方法名. 该方法也可能是私有方法. \n\t * @param args: 调用该方法需要传入的参数\n\t * @return: 调用方法后的返回值\n\t */\n\tpublic Object invoke(Object obj, String methodName, Object ... args){\n\t\t//1. 获取 Method 对象\n\t\tClass [] parameterTypes = new Class[args.length];\n\t\tfor(int i = 0; i &lt; args.length; i++){\n\t\t\tparameterTypes[i] = args[i].getClass();\n\t\t\tSystem.out.println(parameterTypes[i]); \n\t\t}\n\t\t\n\t\ttry {\n\t\t\tMethod method = obj.getClass().getMethod(methodName, parameterTypes);\n\t\t\t//2. 执行 Method 方法\n\t\t\t//3. 返回方法的返回值\n\t\t\treturn method.invoke(obj, args);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\t@Test\n\tpublic void testInvoke(){\n\t\tObject obj = new Person();\n\t\t\n\t\tinvoke(obj, \"setName\", \"尚硅谷\", 1);\n\t\tinvoke(\"com.atguigu.javase.lesson12.Person\", \n\t\t\t\t\"setName\", \"尚硅谷\", 12);\n\t\t\n\t\tObject result = \n\t\t\t\tinvoke(\"java.text.SimpleDateFormat\", \"format\", new Date());\n\t\tSystem.out.println(result); \n\t}\n\t\n\t/**\n\t * Class 是对一个类的描述\n\t * 类的属性: Field\n\t * 类的方法: Method\n\t * 类的构造器: Constrctor\n\t * \n\t * Method: 对应类中的方法.\n\t * 1. 获取 Method: \n\t * 1.1  获取类的方法的数组: clazz.getDeclaredMethods();\n\t * 1.2 获取类的指定的方法: getDeclaredMethod(String name,\n     *                           Class&lt;?&gt;... parameterTypes)   \n     *    name: 方法名\n     *    parameterTypes: 方法的参数类型(使用Class来来描述)的列表        \n     *    \n     *    Method method = \n     *    \tclazz.getDeclaredMethod(\"setName\", String.class);  \n     *    \n     *    method = \n     *    \tclazz.getDeclaredMethod(\"setName\", String.class, Integer.class);            \n\t * \n\t * 1.3 通过 method 对象执行方法:\n\t * public Object invoke(Object obj, Object... args)\n\t * \n\t * obj: 执行哪个对象的方法?\n\t * args: 执行方法时需要传入的参数.\n     *\n     * Object obj = clazz.newInstance();\n     * //method 对应的原方法为: \n     * \tpublic void setName(String name, Integer age)\n     * method.invoke(obj, \"尚硅谷\", 12);\n\t * \n\t */\n\t@Test\n\tpublic void testMethod() throws Exception{\n\t\tClass clazz = Class.forName(\"com.atguigu.javase.lesson12.Person\");\n\t\t\n\t\t//1. 得到 clazz 对应的类中有哪些方法, 不能获取 private 方法. \n\t\tMethod [] methods = clazz.getMethods();\n\t\tfor(Method method: methods){\n\t\t\tSystem.out.println(\"^\" + method.getName()); \n\t\t}\n\t\t\n\t\t//2. 获取所有的方法, 包括 private 方法, 且只获取当前类声明的方法. \n\t\tMethod [] methods2 = clazz.getDeclaredMethods();\n\t\tfor(Method method: methods2){\n\t\t\tSystem.out.println(\"~\" + method.getName()); \n\t\t}\n\t\t\n\t\t//3. 获取指定的方法. \n\t\tMethod method = clazz.getDeclaredMethod(\"setName\", String.class);\n\t\tSystem.out.println(method); \n\t\t\n\t\tmethod = clazz.getDeclaredMethod(\"test\");\n\t\tSystem.out.println(method);\n\t\t\n\t\tmethod = clazz.getDeclaredMethod(\"setName\", String.class, Integer.class);\n\t\tSystem.out.println(method);\n\t\t\n\t\t//4. 执行方法!\n\t\tObject obj = clazz.newInstance();\n\t\tmethod.invoke(obj, \"尚硅谷\", 12);\n\t}\n\t\n\t@Test\n\tpublic void testClassLoader() throws ClassNotFoundException, FileNotFoundException{\n\t\t//1. 获取一个系统的类加载器\n\t\tClassLoader classLoader = ClassLoader.getSystemClassLoader();\n\t\tSystem.out.println(classLoader);\n\t\t\n\t\t//2. 获取系统类加载器的父类加载器. \n\t\tclassLoader = classLoader.getParent();\n\t\tSystem.out.println(classLoader); \n\t\t\n\t\t//3. 获取扩展类加载器的父类加载器.\n\t\tclassLoader = classLoader.getParent();\n\t\tSystem.out.println(classLoader);\n\t\t\n\t\t//4. 测试当前类由哪个类加载器进行加载: \n\t\tclassLoader = Class.forName(\"com.atguigu.javase.lesson12.ReflectionTest\")\n\t\t     .getClassLoader();\n\t\tSystem.out.println(classLoader); \n\t\t\n\t\t//5. 测试 JDK 提供的 Object 类由哪个类加载器负责加载\n\t\tclassLoader = Class.forName(\"java.lang.Object\")\n\t\t\t     .getClassLoader();\n\t\tSystem.out.println(classLoader); \n\t\t\n\t\t//6*. 关于类加载器的一个主要方法. \n\t\t//调用 getResourceAsStream 获取类路径下的文件对应的输入流. \n\t\tInputStream in = null;                                   //com/atguigu/javase/lesson12/\n\t\tin = this.getClass().getClassLoader().getResourceAsStream(\"com/atguigu/javase/lesson12/test.properties\");\n\t\tSystem.out.println(in);\n\t\t\t\t//new FileInputStream(\"test.properties\");\n\t}\n\t\n\t/**\n\t * *Class 类的 newInstance() 方法. \n\t * @throws ClassNotFoundException \n\t * @throws IllegalAccessException \n\t * @throws InstantiationException \n\t */\n\t@Test\n\tpublic void testNewInstance() throws ClassNotFoundException, InstantiationException, IllegalAccessException{\n\t\tString className = \"com.atguigu.javase.lesson12.Person\";\n\t\tClass clazz = Class.forName(className);\n\t\t\n\t\t//利用 Class 对象的 newInstance() 方法来创建类的一个对象.\n\t\t//实际调用的是类的那个 无参数的 构造器!\n\t\t//一般地, 一个类若声明了带参数的构造器, 也要声明一个无参数的构造器.\n\t\tObject obj = clazz.newInstance();\n\t\tSystem.out.println(obj); \n\t}\n\t\n\t/**\n\t * 关于 Class: \n\t * 1. Class 是一个类\n\t * 2. 对象照镜子后可以得到的信息：某个类的数据成员名、方法和构造器、\n\t *    某个类到底实现了哪些接口。\n\t * 3. 对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。\n\t *    一个 Class 对象包含了特定某个类的有关信息。\n\t * 4. Class 对象只能由系统建立对象\n\t * 5. 一个类在 JVM 中只会有一个Class实例 \n\t * @throws ClassNotFoundException \n\t */\n\t@Test\n\tpublic void testClass() throws ClassNotFoundException {\n\t\t\n\t\tClass clazz = null;\n\t\t\n\t\t//*1. 得到 Class 对象\n\t\t//1.1 直接通过 类名.class 的方式得到\n\t\tclazz = Person.class;\n\t\t\n\t\t//1.2 通过对象调用 getClass() 方法来获取\n//\t\tObject obj = new Person();\n//\t\tclazz = obj.getClass();\n\t\t\n\t\t//1.3 通过全类名的方式获取. 用的较多。 \n\t\tString className = \"com.atguigu.javase.lesson12.Person\";\n\t\tclazz = Class.forName(className);\n\t\t\n//\t\tField[] fields = clazz.getDeclaredFields();\n\t\t\n\t\tSystem.out.println(); \n\t}\n\n}\n</code>",
        "name" : "Reflection Examples"
      }, {
        "content" : "<code>\n/**\n * 反射的 Utils 函数集合\n * 提供访问私有变量, 获取泛型类型 Class, 提取集合中元素属性等 Utils 函数\n * @author Administrator\n *\n */\npublic class ReflectionUtils {\n\n\t\n\t/**\n\t * 通过反射, 获得定义 Class 时声明的父类的泛型参数的类型\n\t * 如: public EmployeeDao extends BaseDao&lt;Employee, String&gt;\n\t * @param clazz\n\t * @param index\n\t * @return\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static Class getSuperClassGenricType(Class clazz, int index){\n\t\tType genType = clazz.getGenericSuperclass();\n\t\t\n\t\tif(!(genType instanceof ParameterizedType)){\n\t\t\treturn Object.class;\n\t\t}\n\t\t\n\t\tType [] params = ((ParameterizedType)genType).getActualTypeArguments();\n\t\t\n\t\tif(index &gt;= params.length || index &lt; 0){\n\t\t\treturn Object.class;\n\t\t}\n\t\t\n\t\tif(!(params[index] instanceof Class)){\n\t\t\treturn Object.class;\n\t\t}\n\t\t\n\t\treturn (Class) params[index];\n\t}\n\t\n\t/**\n\t * 通过反射, 获得 Class 定义中声明的父类的泛型参数类型\n\t * 如: public EmployeeDao extends BaseDao&lt;Employee, String&gt;\n\t * @param &lt;T&gt;\n\t * @param clazz\n\t * @return\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static&lt;T&gt; Class&lt;T&gt; getSuperGenericType(Class clazz){\n\t\treturn getSuperClassGenricType(clazz, 0);\n\t}\n\t\n\t/**\n\t * 循环向上转型, 获取对象的 DeclaredMethod\n\t * @param object\n\t * @param methodName\n\t * @param parameterTypes\n\t * @return\n\t */\n\tpublic static Method getDeclaredMethod(Object object, String methodName, Class&lt;?&gt;[] parameterTypes){\n\t\t\n\t\tfor(Class&lt;?&gt; superClass = object.getClass(); superClass != Object.class; superClass = superClass.getSuperclass()){\n\t\t\ttry {\n\t\t\t\t//superClass.getMethod(methodName, parameterTypes);\n\t\t\t\treturn superClass.getDeclaredMethod(methodName, parameterTypes);\n\t\t\t} catch (NoSuchMethodException e) {\n\t\t\t\t//Method 不在当前类定义, 继续向上转型\n\t\t\t}\n\t\t\t//..\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * 使 filed 变为可访问\n\t * @param field\n\t */\n\tpublic static void makeAccessible(Field field){\n\t\tif(!Modifier.isPublic(field.getModifiers())){\n\t\t\tfield.setAccessible(true);\n\t\t}\n\t}\n\t\n\t/**\n\t * 循环向上转型, 获取对象的 DeclaredField\n\t * @param object\n\t * @param filedName\n\t * @return\n\t */\n\tpublic static Field getDeclaredField(Object object, String filedName){\n\t\t\n\t\tfor(Class&lt;?&gt; superClass = object.getClass(); superClass != Object.class; superClass = superClass.getSuperclass()){\n\t\t\ttry {\n\t\t\t\treturn superClass.getDeclaredField(filedName);\n\t\t\t} catch (NoSuchFieldException e) {\n\t\t\t\t//Field 不在当前类定义, 继续向上转型\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * 直接调用对象方法, 而忽略修饰符(private, protected)\n\t * @param object\n\t * @param methodName\n\t * @param parameterTypes\n\t * @param parameters\n\t * @return\n\t * @throws InvocationTargetException \n\t * @throws IllegalArgumentException \n\t */\n\tpublic static Object invokeMethod(Object object, String methodName, Class&lt;?&gt; [] parameterTypes,\n\t\t\tObject [] parameters) throws InvocationTargetException{\n\t\t\n\t\tMethod method = getDeclaredMethod(object, methodName, parameterTypes);\n\t\t\n\t\tif(method == null){\n\t\t\tthrow new IllegalArgumentException(\"Could not find method [\" + methodName + \"] on target [\" + object + \"]\");\n\t\t}\n\t\t\n\t\tmethod.setAccessible(true);\n\t\t\n\t\ttry {\n\t\t\treturn method.invoke(object, parameters);\n\t\t} catch(IllegalAccessException e) {\n\t\t\tSystem.out.println(\"不可能抛出的异常\");\n\t\t} \n\t\t\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * 直接设置对象属性值, 忽略 private/protected 修饰符, 也不经过 setter\n\t * @param object\n\t * @param fieldName\n\t * @param value\n\t */\n\tpublic static void setFieldValue(Object object, String fieldName, Object value){\n\t\tField field = getDeclaredField(object, fieldName);\n\t\t\n\t\tif (field == null)\n\t\t\tthrow new IllegalArgumentException(\"Could not find field [\" + fieldName + \"] on target [\" + object + \"]\");\n\t\t\n\t\tmakeAccessible(field);\n\t\t\n\t\ttry {\n\t\t\tfield.set(object, value);\n\t\t} catch (IllegalAccessException e) {\n\t\t\tSystem.out.println(\"不可能抛出的异常\");\n\t\t}\n\t}\n\t\n\t/**\n\t * 直接读取对象的属性值, 忽略 private/protected 修饰符, 也不经过 getter\n\t * @param object\n\t * @param fieldName\n\t * @return\n\t */\n\tpublic static Object getFieldValue(Object object, String fieldName){\n\t\tField field = getDeclaredField(object, fieldName);\n\t\t\n\t\tif (field == null)\n\t\t\tthrow new IllegalArgumentException(\"Could not find field [\" + fieldName + \"] on target [\" + object + \"]\");\n\t\t\n\t\tmakeAccessible(field);\n\t\t\n\t\tObject result = null;\n\t\t\n\t\ttry {\n\t\t\tresult = field.get(object);\n\t\t} catch (IllegalAccessException e) {\n\t\t\tSystem.out.println(\"不可能抛出的异常\");\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n}\n\n</code>",
        "name" : "ReflectionUtil"
      }, {
        "content" : "<code>\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\nimport org.junit.Test;\n\npublic class ProxyTest {\n\n\t/**\n\t * 定义一个 Service 接口.\n\t * 定义如下方法:\n\t * \n\t * addNew(Person person);\n\t * delete(Integer id);\n\t * update(Person person);\n\t * \n\t * 并提供具体的实现类.\n\t * \n\t * 使用动态代理实现事务操作: \n\t * 1. 在具体调用每个 Service 方法前, 都打印: 开始事务\n\t * 2. 方法正常结束, 都打印: 事务提交\n\t * 3. 若在调用目标方法处异常情况下: 打印: 事务回滚. \n\t * \n\t */\n\t@Test\n\tpublic void testPersonService(){\n\t\tService target = new ServiceImpl();\n\t\t\n\t\tService proxy = new PersonServiceProxy(target).getPersonServiceProxy();\n\t\t\n\t\tSystem.out.println(ServiceImpl.getPersons());\n\t\tproxy.addNew(new Person(1005, \"CCC\"));\n\t\tSystem.out.println(ServiceImpl.getPersons());\n\t\t\n\t\tproxy.delete(1001);\n\t\tSystem.out.println(ServiceImpl.getPersons());\n\t\t\n\t\tproxy.update(new Person(1002, \"MMM\"));\n\t\tSystem.out.println(ServiceImpl.getPersons());\n\t}\n\t\n\t/**\n\t * 关于动态代理的细节\n\t * 1. 需要一个被代理的对象. \n\t * 2. 类加载器通常是和被代理对象使用相同的类加载器\n\t * \n\t * 3. 一般地, Proxy.newInstance() 的返回值是一个被代理对象实现的接口的类型. \n\t * 当然也可以是其他的接口的类型.\n\t * 注意: 第二个参数, 必须是一个接口类型的数组. \n\t * 提示: 若代理对象不需要额外实现被代理对象实现的接口以外的接口, \n\t * 可以使用 target.getClass().getInterfaces()\n\t * \n\t * 4. InvocationHandler 通常使用匿名内部类的方式: 被代理对象需要是 final 类型的.\n\t * 5. InvocationHandler 的 invoke() 方法中的第一个参数 Object 类型的 proxy\n\t * 指的是正在被返回的那个代理对象, 一般情况下使用.  \n\t */\n\t@Test\n\tpublic void testProxy2(){\n\t\tfinal ArithmeticCalculator target = new ArithmeticCalculatorImpl2();\n\t\tSystem.out.println(Arrays.asList(target.getClass().getInterfaces())); \n\t\t\n\t\tObject proxy = Proxy.newProxyInstance(\n\t\t\t\ttarget.getClass().getClassLoader(), \n\t\t\t\t//new Class[]{ArithmeticCalculator.class, Object.class}, \n\t\t\t\ttarget.getClass().getInterfaces(),\n\t\t\t\tnew InvocationHandler() {\n\t\t\t\t\t\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object invoke(Object proxy, Method method, \n\t\t\t\t\t\t\tObject[] args)\n\t\t\t\t\t\t\tthrows Throwable {\n\t\t\t\t\t\tObject obj = null;\n\t\t\t\t\t\t\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tobj = method.invoke(target, args);\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\n\t\tArithmeticCalculator arithmeticCalculator = (ArithmeticCalculator) proxy;\n\t\tSystem.out.println(arithmeticCalculator.add(4, 2)); \n\t}\n\t\n\t@Test\n\tpublic void testProxy(){\n\t\t\n\t\tfinal ArithmeticCalculator arithmeticCalculator = \n\t\t\t\tnew ArithmeticCalculatorImpl2();\n\t\t\n\t\tArithmeticCalculator proxy = \n\t\t\t\t/**\n\t\t\t\t * ClassLoader: 由动态代理产生的对象由哪个类加载器来加载. \n\t\t\t\t * 通常情况下和被代理对象使用一样的类加载器\n\t\t\t\t * Class&lt;?&gt;[]: 由动态代理产生的对象必须需要实现的接口的 Class 数组\n\t\t\t\t * InvocationHandler: 当具体调用代理对象的方法时, 将产生什么行为.\n\t\t\t\t */\n\t\t\t\t(ArithmeticCalculator) Proxy.newProxyInstance(\n\t\t\t\t\t\tarithmeticCalculator.getClass().getClassLoader(), \n\t\t\t\t\t\tnew Class[]{ArithmeticCalculator.class}, \n\t\t\t\t\t\tnew InvocationHandler() {\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * proxy:\n\t\t\t\t\t\t\t * method: 正在被调用的方法\n\t\t\t\t\t\t\t * args: 调用方法时传入的参数.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\t\t\t\t\t\t\tthrows Throwable {\n//\t\t\t\t\t\t\t\tSystem.out.println(\"method: \" + method);\n//\t\t\t\t\t\t\t\tSystem.out.println(Arrays.asList(args));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tSystem.out.println(\"^_^ The method \" \n\t\t\t\t\t\t\t\t\t\t+ method.getName() + \" begins with \"\n\t\t\t\t\t\t\t\t\t\t+ Arrays.asList(args)); \n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//调用被代理类的目标方法\n\t\t\t\t\t\t\t\tObject result = method.invoke(arithmeticCalculator, args);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tSystem.out.println(\"^_^ The method \" \n\t\t\t\t\t\t\t\t\t\t+ method.getName() \n\t\t\t\t\t\t\t\t\t\t+ \" ends with \" + result);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\n\t\tproxy.mul(1, 2);\n\t\t\n\t\tint result = proxy.add(2, 5);\n\t\tSystem.out.println(result);\n\t\t\n\t}\n\n\tpublic void testCalculator() {\n\t\t\n\t\tArithmeticCalculator arithmeticCalculator = new ArithmeticCalculatorImpl();\t\t\n\t\tarithmeticCalculator.mul(2, 3);\t\n\t}\n}\n</code>\n\n<code>\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class PersonServiceProxy {\n\n\tprivate Service target = null;\n\n\tpublic PersonServiceProxy(Service target) {\n\t\tthis.target = target;\n\t}\n\t\n\tpublic Service getPersonServiceProxy(){\n\t\t\n\t\tService proxy = (Service) Proxy.newProxyInstance(target.getClass().getClassLoader(), \n\t\t\t\ttarget.getClass().getInterfaces(), \n\t\t\t\tnew InvocationHandler() {\n\t\t\t\t\t\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\t\t\t\t\tthrows Throwable {\n\t\t\t\t\t\tSystem.out.println(\"开启事务\");\n\t\t\t\t\t\t\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tObject result = method.invoke(target, args);\n\t\t\t\t\t\t\tSystem.out.println(\"提交事务\");\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t\tSystem.out.println(\"回滚事务\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\n\t\treturn proxy;\n\t}\n\t\n}\n</code>",
        "name" : "Proxy"
      } ],
      "name" : "Reflection"
    }, {
      "expanded" : true,
      "files" : [ {
        "content" : "<code>\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.URL;\nimport java.net.URLConnection;\n\nimport org.junit.Test;\n\n/**\n * 1. IP 和 端口的具体意义:\n * 1). IP 定位网络中的一台主机\n * 2). 端口定位主机的一个网络程序. \n * \n * 2. InetAddress: 对象表示网络中的一个地址\n * InetAddress address = InetAddress.getByName(\"127.0.0.1\");\n * \n * 3. TCP/IP 编程:\n * 1). 服务器/客户端: 客户端发送请求到服务器, 服务器接收请求, 给予响应到客户端.\n * 2). ServerSocket\n * 3). Socket\n * 具体参看 PPT 16 页的图. \n *\n */\npublic class SocketTest {\n\n\t@Test\n\tpublic void testURL() throws IOException{\n\t\tURL url = new URL(\"http://127.0.0.1:8080/examples/abcd.txt\");\n\n\t\tSystem.out.println(url.getPath());\n\t\tSystem.out.println(url.getQuery()); \n\t\t\n\t\tURLConnection urlConnection = url.openConnection();\n\t\tSystem.out.println(urlConnection); \n\t\t\n\t\tInputStream in = urlConnection.getInputStream();\n\t\tOutputStream out = new FileOutputStream(\"test.txt\");\n\t\t\n\t\tbyte [] buffer = new byte[1024];\n\t\tint len = 0;\n\t\t\n\t\twhile((len = in.read(buffer)) != -1){\n\t\t\tout.write(buffer, 0, len);\n\t\t}\n\t\t\n\t\tin.close();\n\t\tout.close();\n\t}\n\t\n\t@Test\n\tpublic void testClientSocket2() throws IOException{\n\t\tInetAddress address = InetAddress.getByName(\"127.0.0.1\");\n\t\tSocket socket = new Socket(address, 8686);\n\t\t\n\t\tInputStream in = socket.getInputStream();\n\t\tOutputStream out = new FileOutputStream(\"d:\\\\abcd.jpg\");\n\t\t\n\t\tbyte [] buffer = new byte[1024];\n\t\tint len = 0;\n\t\t\n\t\twhile((len = in.read(buffer)) != -1){\n\t\t\tout.write(buffer, 0, len);\n\t\t}\n\t\t\n\t\tin.close();\n\t\tout.close();\n\t\t\n\t\tsocket.close();\n\t}\n\t\n\t@Test\n\tpublic void testServerSocket2() throws IOException{\n\t\tServerSocket serverSocket = new ServerSocket(8686);\n\t\tSocket socket = serverSocket.accept();\n\t\t\n\t\tInputStream in = new FileInputStream(\"abc.jpg\");\n\t\tbyte [] buffer = new byte[1024];\n\t\tint len = 0;\n\t\t\n\t\tOutputStream out = socket.getOutputStream();\n\t\twhile((len = in.read(buffer)) != -1){\n\t\t\tout.write(buffer, 0, len);\n\t\t}\n\t\t\n\t\tout.close();\n\t\tin.close();\n\t\t\n\t\tsocket.close();\n\t\tserverSocket.close();\n\t}\n\t\n\t@Test\n\tpublic void testSocket() throws IOException{\n\t\tInetAddress address = InetAddress.getByName(\"127.0.0.1\");\n\t\t//创建 Socket 对象: 同时也向服务端发出请求\n\t\tSocket socket = new Socket(address, 8989);\n\t\t\n\t\t//通过 输入输出流 和服务端进行交互\n\t\tInputStream in = socket.getInputStream();\n\t\tBufferedReader reader = \n\t\t\t\tnew BufferedReader(new InputStreamReader(in));\n\t\tSystem.out.println(\"^_^: \" + reader.readLine());\n\t\t\n\t\tin.close();\n\t\treader.close();\n\t\t\n\t\t//关闭 Socket\n\t\tsocket.close();\n\t}\n\t\n\t@Test\n\tpublic void testServerSocket() throws IOException{\n\t\t//创建 ServerSocket 对象\n\t\tServerSocket serverSocket = new ServerSocket(8989);\n\t\t//接受客户端的请求, 并得到 Socket 对象\n\t\tSocket socket = serverSocket.accept();\n\t\n\t\t//通过 输入输出流 和客户端进行交互\n\t\tOutputStream out = socket.getOutputStream();\n\t\tPrintWriter writer = new PrintWriter(out);\n\t\twriter.write(\"来自服务端的问候.\");\n\t\t\n\t\twriter.close();\n\t\tout.close();\n\t\t\n\t\t//遍历 Socket 资源. \n\t\tsocket.close();\n\t\tserverSocket.close();\n\t}\n\t\n\t/**\n\t * InetAddress: 表示互联网(或局域网)的一台主机的地址\n\t * @throws IOException \n\t */\n\t@Test\n\tpublic void testInetAddress() throws IOException {\n\t\t//InetAddress address = InetAddress.getByName(\"www.atguigu.com\");\n\t\t//www.atguigu.com/202.108.35.210\n\t\t//System.out.println(address); \n\t\t\n\t\tInetAddress address2 = InetAddress.getLocalHost();\n\t\tSystem.out.println(address2); \n\t}\n}\n</code>",
        "name" : "SocketTest"
      } ],
      "name" : "Socket"
    }, {
      "expanded" : true,
      "files" : [ {
        "content" : "1. Multithreading summary:\n<code>\n/**\n * 关于线程:\n * 1. 在 Java 中, Thread 类代表一个线程. \n * \n * 2. 实现线程有 2 种方式:\n * 2.1 继承 Thread 类\n * 2.2 实现 Runnable 接口.\n * \n * 3. 继承 Thread 类:\n * 3.1 必须重写 run() 方法: 里边放置的是实际的线程体。\n * \n * 4. 启动线程:\n * 4.1 创建 Thread 对象\n * 4.2 调用 Thread 对象的 start() 方法启动线程. 而不是 run() 方法.\n * \n * 5. 实现 Runnable 接口的方式:\n * 5.1 创建实现 Runnable 接口的实现类: 必须实现 run() 方法\n * 5.2 创建 5.1 对应的 Runnable 接口的实现类对象\n * 5.3 创建 Thread 对象, 利用 Thread(Runnable target)\n * 5.4 调用 Thread 类 start() 方法启动线程. \n * \n * 6. 线程生命周期相关的几个方法(了解):\n * 6.1 yeild(): 若当前线程调用该方法, 则由执行状态变为可运行状态. \n * 6.2 sleep(int mills): 使当前线程休眠一段时间. 以毫秒为单位\n * 6.3 join: 在一个线程中调用另外的线程的 join() 方法, 将使当前线程阻塞, \n *           等待另一个线程执行完后再进入可执行状态.  \n * 6.4 interrupt(): 将解除线程的阻塞状态. \n * 6.5 isAlive(): 可以判断当前线程是否处于可运行状态或运行状态.     \n *\n * 7. 线程安全的问题:\n * 7.1 理解并编写出线程不安全的示例代码: 多个线程访问一个共享的资源. \n * 7.2 使用 synchronized 代码块解决线程安全的问题: 需要在 synchronized 代码块中\n * 参照共同的一个对象.      \n * \n * 8. 关于线程通信(了解):\n * 8.1 相关方法: wait(), notify(), notifyAll()\n * 8.2 这些方法在 同步方法中 调用. \n */\n</code>\n\n2. Multithreading by extending Thread class\n<code>\npublic class ThreadTest {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t//1. 创建线程对象\n\t\tThread thread = new FirstThread(\"FirstThread\");\n\t\t\n\t\t//2. 调用线程对象的 start() 方法启动线程\n\t\tthread.start();\n\t\t\n\t\tString threadName = \n\t\t\t\tThread.currentThread().getName();\n\t\tfor(int i = 0; i &lt; 100; i++){\n\t\t\tSystem.out.println(threadName + \": \" + i); \n\t\t}\n\t}\t\n}\n\nclass FirstThread extends Thread{\n\t\n\tpublic FirstThread(String name) {\n\t\tsuper(name);\n\t}\n\t\n\t/**\n\t * 线程体在 run() 方法中\n\t */\n\t@Override\n\tpublic void run() {\n\t\tString threadName = \n\t\t\t\tThread.currentThread().getName();\n\t\tfor(int i = 0; i &lt; 100; i++){\n\t\t\tSystem.out.println(threadName + \": \" + i); \n\t\t}\n\t}\n}\n</code>\n\n3. Multithreading by implementing Runnable interface\n<code>\npublic class MyRunnable implements Runnable{\n\n\tint i = 0;\n\t\n\t@Override\n\tpublic void run() {\n\t\tfor(; i &lt; 100; i++){\n\t\t\tSystem.out.println(Thread.currentThread().getName() \n\t\t\t\t\t+ \": \" + i);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tMyRunnable mr = new MyRunnable();\n\t\t\n\t\tThread thread1 = new Thread(mr);\n\t\tThread thread2 = new Thread(mr);\n\t\t\n\t\tthread1.start();\n\t\tthread2.start();\n\t}\n}\n\n</code>",
        "name" : "Threading Basics"
      }, {
        "content" : "1. Life cycle:\n<img src=\"http://img2016.itdadao.com/d/file/tech/2016/12/09/cbb320328091556171.png\">\n\n2. test if a thread is alive\n<code>\npublic class IsAliveThreadTest extends Thread{\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tThread thread = new IsAliveThreadTest();\n\t\t\n\t\tSystem.out.println(thread.isAlive()); //false;\n\t\t\n\t\tthread.start();\n\t\tSystem.out.println(thread.isAlive()); //true\n\t\t\n\t\ttry {\n\t\t\tthread.join();\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\tSystem.out.println(thread.isAlive()); //false\n\t\t\n\t\t//已经结束的线程, 再调用 start() 方法会抛出异常. \n\t\t//thread.start();\t\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tfor(int i = 0; i &lt; 100; i++){\n\t\t\tSystem.out.println(i);\n\t\t}\n\t}\n}\n</code>\n\n3. yield() test\n<code>\npublic class YieldThreadTest extends Thread{\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tThread t1 = new YieldThreadTest(\"线程-1\");\n\t\tThread t2 = new YieldThreadTest(\"线程-2\");\n\t\t\n\t\tt1.start();\n\t\tt2.start();\n\t}\n\t\n\tpublic YieldThreadTest(String name) {\n\t\tsuper(name);\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tfor(int i = 0; i &lt; 100; i++){\n\t\t\tSystem.out.println(getName() + \": \" + i);\n\t\t\n\t\t\tif(i == 10){\n\t\t\t\tyield();\n\t\t\t}\n\t\t}\n\t}\n}\n</code>\n\n4. join() test\n<code>\npublic class JoinThreadTest extends Thread{\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tThread thread = new JoinThreadTest();\n\t\tthread.start();\n\t\t\n\t\tfor(int i = 0; i &lt; 100; i++){\n\t\t\tSystem.out.println(Thread.currentThread().getName()\n\t\t\t\t\t+ \": \" + i);\n\t\t\t\n\t\t\tif(i == 10){\n\t\t\t\ttry {\n\t\t\t\t\tthread.join();\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tfor(int i = 0; i &lt; 100; i++){\n\t\t\tSystem.out.println(getName() \n\t\t\t\t\t+ \": \" + i);\n\t\t}\n\t}\n}\n</code>\n\n5. sleep() test\n<code>\npublic class SleepThreadTest extends Thread{\n\n\tpublic static void main(String[] args) {\n\t\tnew SleepThreadTest().start();\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tfor(int i = 0; i &lt; 100; i++){\n\t\t\t\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(getName() + \": \" + i);\n\t\t}\n\t}\n}\n</code>\n\n6. interrupt() test\n<code>\npublic class InterruptThreadTest extends Thread{\n\t\n\tpublic static void main(String[] args) {\n\t\tInterruptThreadTest itt = \n\t\t\t\tnew InterruptThreadTest();\n\t\t\n\t\titt.start();\n\t\t\n\t\titt.interrupt();\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tfor(int i = 0; i &lt; 100; i++){\n\t\t\tSystem.out.println(getName() + \": \" \n\t\t\t\t\t+ i);\n\t\t\t\n\t\t\tif(i == 10){\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(1000000);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n</code>",
        "name" : "Thread Life Cycle"
      }, {
        "content" : "1.  Synchronized object\n<code>\npublic class ShareApple implements Runnable{\n\t\n\tprivate int appleCount = 5;\n\t\n\t//拿苹果\n\tboolean getApple(){\n\t\t\n\t\t//String str = new String(\"abc\"); //\n\t\t\n\t\tsynchronized (this) {\n\t\t\n\t\t\tif(appleCount &gt; 0){\n\t\t\t\t\n\t\t\t\tappleCount--;\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println(Thread.currentThread().getName() \n\t\t\t\t\t\t+ \"拿走了一个苹果. 还剩下 \" + appleCount + \" 个苹果. \");\n\t\t\t\treturn true;\n\t\t\t}\t\t\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t//线程体\n\t@Override\n\tpublic void run() {\n\t\tboolean flag = getApple();\n\t\twhile(flag){\n\t\t\tflag = getApple();\n\t\t}\n\t\t\n\t\tSystem.out.println(Thread.currentThread().getName() + \"线程结束了\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tShareApple shareApple = new ShareApple();\n\t\t\n\t\tThread th1 = new Thread(shareApple);\n\t\tThread th2 = new Thread(shareApple);\n\t\t\n\t\tth1.setName(\"小明\");\n\t\tth2.setName(\"小强\");\n\t\t\n\t\tth2.start();\n\t\tth1.start();\t\n\t}\n}\n</code>\n\n2. Synchronized method\n<code>\npublic class PrintLetters implements Runnable {\n\n\tprivate char c = 'a';\n\n\tpublic synchronized boolean print() {\n\t\t\tif (c &lt;= 'z') {\n\t\t\t\tSystem.out.println(Thread.currentThread().getName() + \": \" + c);\n\n\t\t\t\ttry {\n\t\t\t\t\tThread.currentThread().sleep(10);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\n\t\t\t\tc++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tboolean flag = print();\n\t\twhile (flag) {\n\t\t\tflag = print();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tPrintLetters letter = new PrintLetters();\n\n\t\tThread th1 = new Thread(letter);\n\t\tThread th2 = new Thread(letter);\n\n\t\tth1.setName(\"线程-1\");\n\t\tth2.setName(\"线程-2\");\n\n\t\tth1.start();\n\t\tth2.start();\n\t}\n}\n</code>\n",
        "name" : "Thread Synchronization"
      }, {
        "content" : "1. wait(), notify()\nThe follow example will show threads print letters alternately\n<code>\npublic class PrintLetters2 implements Runnable{\n\n\tprivate char c = 'a';\n\t\n\t@Override\n\tpublic void run() {\n\t\twhile(c &lt;= 'z'){\n\t\t\tprint();\n\t\t}\n\t}\n\n\tpublic synchronized void print(){\n\t\tif(c &lt;= 'z'){\n\t\t\tSystem.out.println(Thread.currentThread().getName() \n\t\t\t\t\t+ \": \" + c);\n\t\t\tc++;\n\t\t\t\n\t\t\tnotify();\n\t\t\t\n\t\t\ttry {\n\t\t\t\twait();\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tRunnable runnable = new PrintLetters2();\n\t\t\n\t\tThread th1 = new Thread(runnable);\n\t\tth1.setName(\"线程-1\");\n\t\t\n\t\tThread th2 = new Thread(runnable);\n\t\tth2.setName(\"线程-2\");\n\t\t\n\t\tth1.start();\n\t\tth2.start();\t\n\t}\n}\n</code> \n\n2.  The following example will demonstrate how threads communicate\n<code>\npublic class TicketHouse implements Runnable{\n\n\tprivate int fiveCount = 1, tenCount = 0, twentyCount = 0;\n\t\n\tpublic synchronized void buy(){\n\t\t\n\t\tString name = Thread.currentThread().getName();\n\t\t\n\t\t//zf: 20 元\n\t\tif(\"zf\".equals(name)){\n\t\t\tif(fiveCount &lt; 3){\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tSystem.out.println(\"5 元面值: \" + fiveCount + \", 张飞必须等待.\");\n\t\t\t\t\twait();\n\t\t\t\t\tSystem.out.println(\"5 元面值: \" + fiveCount + \",卖一张票给张飞, 找零 15\");\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}else if(\"gy\".equals(name)){\n\t\t\tfiveCount++;\n\t\t\tSystem.out.println(\"卖一张票给关羽. 钱正好. 5 元面值: \" + fiveCount);\n\t\t}else if(\"lb\".equals(name)){\n\t\t\tfiveCount++;\n\t\t\tSystem.out.println(\"卖一张票给刘备. 钱正好. 5 元面值: \" + fiveCount);\n\t\t}\n\t\t\n\t\tif(fiveCount == 3){\n\t\t\tnotifyAll();\t\t\t\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tbuy();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tRunnable runnable = new TicketHouse();\n\t\t\n\t\tThread th1 = new Thread(runnable);\n\t\tth1.setName(\"zf\");\n\t\t\n\t\tThread th2 = new Thread(runnable);\n\t\tth2.setName(\"gy\");\n\t\t\n\t\tThread th3 = new Thread(runnable);\n\t\tth3.setName(\"lb\");\n\t\t\n\t\tth1.start();\n\t\tth2.start();\n\t\tth3.start();\t\n\t}\n}\n</code>",
        "name" : "Thread Communication"
      } ],
      "name" : "Multithreading"
    } ],
    "expanded" : true,
    "files" : [ {
      "content" : "Basic enum definition:\n<code>\npublic enum Season{\n\t//1. must list all enums in the first row.\n\tSPRING(\"Spring\", \"green land\"), \n\tSUMMER(\"Summer\", \"hot and rain\"), \n\tFALL(\"Fall\", \"falling leaves\"), \n\tWINTER(\"Winter\", \"cold and snow\");\n\t\n\tprivate final String name;\n\tprivate final String desc;\n\t\n\tprivate Season(String name, String desc) {\n\t\tthis.name = name;\n\t\tthis.desc = desc;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic String getDesc() {\n\t\treturn desc;\n\t}\n}\n</code>\n\nenum implementing interface:\n<code>\npublic interface TimeInfo {\n\tpublic String getTimeInfo();\n}\npublic enum Season implements TimeInfo {\n\tSPRING(\"Spring\", \"green land\"){\n\t\t@Override\n\t\tpublic String getTimeInfo() {\n\t\t\treturn \"2-4\";\n\t\t}\n\t}, \n\tSUMMER(\"Summer\", \"hot and rain\"){\n\t\t@Override\n\t\tpublic String getTimeInfo() {\n\t\t\treturn \"5-7\";\n\t\t}\n\t}, \n\tFALL(\"Fall\", \"falling leaves\"){\n\t\t@Override\n\t\tpublic String getTimeInfo() {\n\t\t\treturn \"8-10\";\n\t\t}\n\t}, \n\tWINTER(\"Winter\", \"cold and snow\"){\n\t\t@Override\n\t\tpublic String getTimeInfo() {\n\t\t\treturn \"11-1\";\n\t\t}\n\t};\n\t\n\tprivate final String name;\n\tprivate final String desc;\n\t\n\tprivate Season(String name, String desc) {\n\t\tthis.name = name;\n\t\tthis.desc = desc;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic String getDesc() {\n\t\treturn desc;\n\t}\n}\n</code>\n\nGet values of enum:\n<code>\nfor (Season s: Season.values()){\n    System.out.println(s);\n}\n</code>\n\nCreate an enum object from string name: \n<code>\nSeason spring = Season.valueOf(Season.class, \"SPRING\");\n</code>",
      "name" : "enum"
    }, {
      "content" : "Definition of annotation: \n<code>\n@Documented //this annotation will be extracted by javadoc tools\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@Target(value={ElementType.FIELD, ElementType.TYPE} \npublic @interface HelloAnnotation {\n    public String name(); //an annotation field\n    public int number() default 8; //an annotation field with default value\n}\n</code>",
      "name" : "annotation"
    }, {
      "content" : "<code>\n/**\n * Date() 封装了时间和日期.\n * \n * DateFormat: 把日期对象格式化为一个字符串 和 把一个字符串转为一个 Date 对象\n * 1. DateFormat: 是一个抽象类. \n * 抽象类获取对象的方式:\n * 1). 创建其子类对象\n * 2). 有的抽象类中提供了静态工厂方法来获取抽象类的实例. \n */\npublic class DateFormatTest {\n\n\tpublic void testSimpleDateFormat() throws ParseException{\n\t\tDateFormat dateFormat = \n\t\t\t\tnew SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\n\t\t\n\t\tDate date = new Date();\n\t\tSystem.out.println(dateFormat.format(date)); \n\t\t\n\t\tString dateStr = \"1990-12-12 12:12:12\";\n\t\tDate date2 = dateFormat.parse(dateStr);\n\t\tSystem.out.println(date2); \n\t}\n\t\n\tpublic void testDateFormat() throws ParseException{\n\t\tDateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG, \n\t\t\t\tDateFormat.LONG);\n\t\t\n\t\tDate date = new Date();\n\t\tString dateStr = dateFormat.format(date);\n\t\tSystem.out.println(dateStr); \n\t\t\n\t\tdateStr = \"2013年6月10日 下午03时48分06秒\";\n\t\tDate date2 = dateFormat.parse(dateStr);\n\t\tSystem.out.println(date2); \n\t}\n\t\n\tpublic void testDate() {\n\t\tDate date = new Date();\n\t\tSystem.out.println(date);\n\t}\n}\n</code>\n\n",
      "name" : "date"
    }, {
      "content" : "file2",
      "name" : "nio"
    }, {
      "content" : "<img src=\"https://camo.githubusercontent.com/54d8044546deb8928ba81dc48d0c280030088e81/687474703a2f2f3778727a6c6d2e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f6a617661636f2e706e67\">",
      "name" : "collections and maps"
    } ],
    "name" : "JavaSE"
  }, {
    "expanded" : true,
    "files" : [ {
      "content" : "1. Installation:\n",
      "name" : "Tomcat"
    } ],
    "name" : "Java Web"
  }, {
    "directories" : [ {
      "expanded" : true,
      "files" : [ {
        "content" : "<code>\n&lt;filter&gt;\n\t&lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;\n\t&lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;\n&lt;/filter&gt;\n\n&lt;filter-mapping&gt;\n\t&lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;\n\t&lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/filter-mapping&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n$(function() {\n\t$(\".delete\").click(function(){\n\t\tvar href = $(this).attr(\"href\");\n\t\t$(\"form\").attr(\"action\", href).submit();\n\t\treturn false;\n\t});\n})\n&lt;/script&gt;\n\t\n\n&lt;form action=\"\" method=\"POST\"&gt;\n\t&lt;input type=\"hidden\" name=\"_method\" value=\"DELETE\" /&gt;\n&lt;/form&gt;\n\n&lt;a class=\"delete\" href=\"profile/${profile.id}\"&gt; Delete&lt;/a&gt;\n</code>",
        "name" : "post mapping to delete"
      } ],
      "name" : "SpringMVC"
    }, {
      "expanded" : true,
      "name" : "SpringData"
    }, {
      "expanded" : true,
      "name" : "SpringSecurity"
    } ],
    "expanded" : true,
    "name" : "Spring"
  }, {
    "expanded" : true,
    "name" : "GUI"
  }, {
    "expanded" : true,
    "files" : [ {
      "content" : "\n1. Generating stream\n<code>\n//1. from collections(lists, sets):\nCollection.stream()\nCollection.parallelStream()\n\n//2. from arrays:\nArrays.stream(T array)\nStream.of(T array)\n\n//3. from BufferedReader:\njava.io.BufferedReader.lines()\n\n//4. from static factory:\njava.util.stream.IntStream.range()\njava.nio.file.Files.walk()\n\n//5. custom generated:\njava.util.Spliterator\nRandom.ints()\nBitSet.stream()\nPattern.splitAsStream(java.lang.CharSequence)\nJarFile.stream()\n</code>\n\nExamples:\n<code>\n// from individual values\nStream stream1 = Stream.of(\"a\", \"b\", \"c\");\n\n// from arrays\nString[] strArray = new String[]{\"a\", \"b\", \"c\"};\nStream stream2 = Stream.of(strArray);\nStream stream3 = Arrays.stream(strArray);\n\n// from collections\nList&lt;String&gt; list = Arrays.asList(strArray);\nStream stream4 = list.stream();\n\n// from basic values IntStream/DoubleStream/LongStream\nIntStream.of(new int[]{1,2,3}).forEach(System.out::println);\nIntStream.range(1,3).forEach(System.out::println);\nIntStream.rangeClosed(1,3).forEach(System.out::println);\n</code>\n\n2.  Operations of stream\nThere are 3 types of operations: Intermediate, Terminal, Short-circuiting.\n<ul>\n<li><b>Intermediate:</b> map (mapToInt, flatMap), filter, distinct, sorted, peek, limit, skip,\n parallel, sequential, unordered</li>\n<li><b>Terminal:</b>forEach, forEachOrdered, toArray, reduce, collect, min, max, count, \nanyMatch, allMatch, noneMatch, findFirst, findAny, iterator</li>\n<li><b>Short-circuiting:</b>anyMatch, allMatch, noneMatch, findFirst, findAny, limit</li>\n</ul>\n\ntransform stream to other data structures:\n<code>\n//to Array\nString[] array = stream.toArray(String::new);\n\n//to Collection\nList&lt;String&gt; list1 = stream.collect(Collectors.toList());\nList&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));\nSet set1 = stream.collect(Collectors.toSet());\nStack stack1 = stream.collect(Collectors.toCollection(Stack::new));\n\n//to String\nString str = stream.collect(Collectors.joining()).toString();\n</code>\n\nmap:\n<code>\n// string to uppercase\nList&lt;String&gt; output = wordList.stream().map(String::toUpperCase).collect(Collectors.toList());\n\n// square of numbers\nList&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4, 5, 6);\nList&lt;Integer&gt; squares = nums.stream().map(num -&gt; num * num).collect(Collectors.toList());\n</code>\n\nflatMap:\n<code>\nStream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(\n Arrays.asList(1),\n Arrays.asList(2, 3),\n Arrays.asList(4, 5, 6)\n );\nStream&lt;Integer&gt; outputStream = inputStream.flatMap((childList) -&gt; childList.stream());\n</code>\n\nfilter:\n<code>\n// filter even number\nInteger[] nums = {1, 2, 3, 4, 5, 6};\nInteger[] evens = Stream.of(nums).filter(n -&gt; n%2 == 0).toArray(Integer[]::new);\n\n//find matched words\nList&lt;String&gt; output = reader.lines().\n flatMap(line -&gt; Stream.of(line.split(REGEXP))).\n filter(word -&gt; word.length() &gt; 0).\n collect(Collectors.toList());\n</code>\n\nforEach:\n<code>\nroster.stream()\n .filter(p -&gt; p.getGender() == Person.Sex.MALE)\n .forEach(p -&gt; System.out.println(p.getName()));\n\n//forEach is a Terminal operation, the following is WRONG!!!\nstream.forEach(element -&gt; doOneThing(element));\nstream.forEach(element -&gt; doAnotherThing(element));\n</code>\n\npeek: \n<code>\n//peek is similar to forEach but it does not terminate the stream\nStream.of(\"one\", \"two\", \"three\", \"four\")\n .filter(e -&gt; e.length() &gt; 3)\n .peek(e -&gt; System.out.println(\"Filtered value: \" + e))\n .map(String::toUpperCase)\n .peek(e -&gt; System.out.println(\"Mapped value: \" + e))\n .collect(Collectors.toList());\n</code>\n\nreduce: returns an Optional\n<code>\n// concat, output: \"ABCD\"\nString concat = Stream.of(\"A\", \"B\", \"C\", \"D\").reduce(\"\", String::concat); \n// get min，minValue = -3.0\ndouble minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); \n// get sum，sumValue = 15, with initial value(5)\nint sumValue = Stream.of(1, 2, 3, 4).reduce(5, Integer::sum);\n// get sum，sumValue = 10, no initial value\nsumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();\n// filter，concatentation，output: \"ace\"\nconcat = Stream.of(\"a\", \"B\", \"c\", \"D\", \"e\", \"F\").\n filter(x -&gt; x.compareTo(\"Z\") &gt; 0).\n reduce(\"\", String::concat);\n</code>\n\n3. Optional:\nThe purpose of using Optional is to avoid NullPointerException.\n<code>\npublic static void print(String text) {\n    Optional.ofNullable(text).ifPresent(System.out::println);\n}\n\npublic static int getLen(String text) {\n    return Optional.ofNullable(text).map(String::length).orElse(-1);\n}\n</code>\n",
      "name" : "Stream"
    } ],
    "name" : "Java 8"
  }, {
    "expanded" : true,
    "name" : "Design Patterns"
  } ],
  "JavaScript" : [ {
    "expanded" : true,
    "files" : [ {
      "content" : "closure",
      "name" : "closure"
    }, {
      "content" : "1. Format number:\n<code>\n//Number.toFixed(x)\nvar profits=2489.8237\nprofits.toFixed(3) //returns 2489.824 (round up)\nprofits.toFixed(2) //returns 2489.82\nprofits.toFixed(7) //returns 2489.8237000 (padding)\n\n//Number.toPrecision()\nvar anumber=123.45\nanumber.toPrecision(6) //returns 123.450 (padding)\nanumber.toPrecision(4) //returns 123.5 (round up)\nanumber.toPrecision(2) //returns 1.2e+2 (you figure it out!)\n</code>\n\n2. Parse string into number:\n<code>\nparseInt(num); // default way (no radix)\nparseInt(num, 10); // parseInt with radix (decimal)\nparseFloat(num) // floating point\nNumber(num); // Number constructor\n~~num //bitwise not\nnum / 1 // diving by one\nnum * 1 // multiplying by one\nnum - 0 // minus 0\n+num // unary operator \"+\"\n</code>",
      "name" : "number"
    }, {
      "content" : "<code>\nprocess.stdin.resume();\nprocess.stdin.setEncoding('ascii');\n\nvar input_stdin = \"\";\nvar input_stdin_array = \"\";\nvar input_currentline = 0;\n\nprocess.stdin.on('data', function (data) {\n    input_stdin += data;\n});\n\nprocess.stdin.on('end', function () {\n    input_stdin_array = input_stdin.split(\"\\n\");\n    main();    \n});\n\n// Reads complete line from STDIN\nfunction readLine() {\n    return input_stdin_array[input_currentline++];\n}\n</code>",
      "name" : "input/output"
    }, {
      "content" : "1. native whitespace stripping:\n<code>\n'hello '.trimRight() # =&gt; 'hello'\n' hello'.trimLeft() # =&gt; 'hello'\n' hello '.trim() # =&gt; 'hello'\n</code>",
      "name" : "string"
    } ],
    "name" : "JavaScript"
  }, {
    "expanded" : true,
    "name" : "Angular 1"
  }, {
    "expanded" : true,
    "files" : [ {
      "content" : "https://www.udemy.com/angular-2-tutorial-for-beginners/?couponCode=ng_youtube",
      "name" : "udemy course by Josh"
    }, {
      "content" : "<code>\nThis Document :  https://docs.google.com/document/d/1JBLiWL0MYSXXUcgl43tqT2PfM1xurIcs2ERUbb-fZYE/edit?usp=sharing\nYoutube tutorial: https://www.youtube.com/watch?v=htPYk6QxacQ\n \nAngular 4\nCheatsheet\n \n# Read var from typescript: \n&lt;p&gt; {{varName}} &lt;/p&gt;\n \n \n# Disable button via variable:\n&lt;button [disabled]=\"!(buttonActive)\"&gt;Btn 1&lt;/button&gt;\n( the disable keyword can be anything, this line will toogle the “disabled” visibility in the HTML )\n \n# Html element text binding:\n&lt;p [innerText]=\"textValue\"&gt;&lt;/p&gt; \n \n \n# User event binding: \n&lt;button (click)=\"onButton1Clicked()\"&gt;Button 1&lt;/button&gt;\n \n \n# Event data g example: \nHtml : \n&lt;input type=\"text\" (input)=\"onInput($event)\"&gt;\nTs: \nonInput( event:Event ) { \n\tthis.varOne = (&lt;HTMLInputElement&gt;event.target).value\n}\n \n# Two way binding: \nts:\nexport class MyComponent {\n\tvariableX = \"my text value\"\n}\nhtml:\n&lt;input type=\"text\" [(ngModel)=\"variableX\"]&gt;\n&lt;p&gt;{{variableX}}&lt;/p&gt;\n\n\n( component is a directive )\n( structural directive add or remove elements )\n( accepts boolean expression, method/variable )\n# Structural directive ngIf :\n&lt;p *ngIf=\"isParagraph1Visible()\"&gt;Paragraph 1&lt;/p&gt;\n&lt;p *ngIf=\"paragh2Visible\"&gt;Paragraph 2&lt;/p&gt;\n \n \n# ng if else : \n&lt;p *ngIf=\"flagVariable; else pNoVisible\"&gt; flag is True &lt;/p&gt;\n&lt;ng-template #pNoVisible&gt;\n\t&lt;p&gt; flag is false &lt;/p&gt;\n&lt;/ng-template&gt;\n \n \n( attribute directive only change the target element )\n( add / remove styles )\n# Attribute directive ngStyle:\n&lt;p [ngStyle]=\"{'background-color': getParagraphColor() }\" &gt; Example 1 &lt;/p&gt;\n&lt;p [ngStyle]=\"{backgroundColor: 'red' }\" &gt; Example 2 &lt;/p&gt;\n \n \n(add/remove classes)\n# Attribute directive ngClass:\n&lt;p [ngClass]=\"{cssClassName : classIsActive === 'yes' }\"&gt; Paragraph &lt;/p&gt;\n \n \n# Replicate element / component for each item in array \nTs : \nlist = [ 0 , 1, 2 ];\nTs :\n&lt;p *ngFor=\"let itemFromList of list\"&gt;{{itemFromList}}&lt;/p&gt;\n</code>",
      "name" : "Angular 2 cheatsheet"
    } ],
    "name" : "Angular 2"
  }, {
    "expanded" : true,
    "name" : "NodeJS"
  }, {
    "expanded" : true,
    "name" : "jQuery"
  }, {
    "expanded" : true,
    "name" : "HTML5"
  }, {
    "expanded" : true,
    "name" : "Ajax"
  } ],
  "LeetCode" : [ {
    "Description" : "Given an array of integers, return indices of the two numbers such that they add up to a specific target. \nYou may assume that each input would have exactly one solution.",
    "Difficulty" : "Easy",
    "Number" : 1,
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\npublic class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();\n        int[] result = new int[2];\n        for(int i = 0; i &lt; nums.length; i++) {\n            if(map.containsKey(nums[i])) {\n                result[0] = map.get(nums[i]);\n                result[1] = i;\n                return result;\n            }\n            map.put(target - nums[i], i);\n        }\n        return result;\n    }\n}\n</code>",
        "runtime" : "5ms, 99.82%"
      } ],
      "JavaScript" : [ {
        "code" : "var Solution = function(){};",
        "runtime" : "100ms"
      } ],
      "Python" : [ {
        "code" : "Use dictionary:\n<code>class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        if len(nums) &lt;= 1:\n            return [-1,-1]\n        lookup = {}\n        for i in xrange(len(nums)):\n            gap = target - nums[i]\n            if gap not in lookup:\n                lookup[nums[i]] = i\n            else:\n                return [lookup[gap],i]\n        return [-1,-1]</code>\n",
        "runtime" : "100ms"
      }, {
        "code" : "Same method, just cleaner code:\n<code>\nclass Solution(object):\n    def twoSum(self, nums, target):\n        d = {}\n        for i, num in enumerate(nums):\n            if target - num in d:\n                return [d[target - num], i]\n            if num not in d:\n                d[num] = i\n        return [-1,-1]\n</code>",
        "runtime" : "56ms, 90.91%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Two Sum",
    "id" : 1
  }, {
    "Description" : "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 0 -> 8",
    "Difficulty" : "Easy",
    "Number" : 2,
    "Solutions" : {
      "Java" : [ {
        "code" : "public class Solution {}",
        "runtime" : "100ms"
      } ],
      "JavaScript" : [ {
        "code" : "var Solution = function(){};",
        "runtime" : "100ms"
      } ],
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        dummy = ListNode(0)\n        curr = dummy\n        carry = 0\n        while l1 or l2:\n            v1 = l1.val if l1 else 0\n            v2 = l2.val if l2 else 0\n            bitsum = v1 + v2 + carry\n            carry, bit = divmod(bitsum, 10)\n            curr.next = ListNode(bit)\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n            curr = curr.next\n        if carry:\n            curr.next = ListNode(carry)\n        return dummy.next\n</code>",
        "runtime" : "120ms, 90.98%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Add Two Numbers",
    "id" : 2
  }, {
    "Description" : "Given a string, find the length of the longest substring without repeating characters.\n\nExamples:\n\nGiven \"abcabcbb\", the answer is \"abc\", which the length is 3.\n\nGiven \"bbbbb\", the answer is \"b\", with the length of 1.\n\nGiven \"pwwkew\", the answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring.",
    "Difficulty" : "Hard",
    "Number" : "3",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\npublic class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int longest = 0;\n        int left = 0;\n        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();\n        for (int i = 0; i &lt; s.length(); i++) {\n            if (map.containsKey(s.charAt(i)) && map.get(s.charAt(i)) &gt;= left) {\n                left = map.get(s.charAt(i)) + 1;\n            }\n            map.put(s.charAt(i), i);\n            longest = Math.max(longest, i - left + 1);\n        }\n        return longest;\n    }\n}\n</code>",
        "runtime" : "20ms, 100%"
      } ],
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        result, start, indexDict = 0, 0, {}\n        for i, c in enumerate(s):\n            if c in indexDict and indexDict[c] &gt;= start:\n                start = indexDict[c] + 1\n            indexDict[c] = i\n            result = max(result, i - start + 1)\n        return result\n</code>",
        "runtime" : "95ms, 81.34%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Longest Substring Without Repeating Characters"
  }, {
    "Description" : "There are two sorted arrays nums1 and nums2 of size m and n respectively.\n\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\n\nExample 1:\nnums1 = [1, 3]\nnums2 = [2]\n\nThe median is 2.0\nExample 2:\nnums1 = [1, 2]\nnums2 = [3, 4]\n\nThe median is (2 + 3)/2 = 2.5",
    "Difficulty" : "Hard",
    "Number" : "4",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\npublic class Solution {\n    double findMedianSortedArrays(int A[], int B[]) {\n        int len = A.length + B.length;\n        if (len % 2 == 1) {\n            return findKth(A, 0, B, 0, len / 2 + 1);\n        }\n        return (\n            findKth(A, 0, B, 0, len / 2) + findKth(A, 0, B, 0, len / 2 + 1)\n        ) / 2.0;\n    }\n\n    // find kth number of two sorted array\n    public static int findKth(int[] A, int A_start,\n                              int[] B, int B_start,\n                              int k){\t\t\n\t\tif (A_start &gt;= A.length) {\n\t\t\treturn B[B_start + k - 1];\n\t\t}\n\t\tif (B_start &gt;= B.length) {\n\t\t\treturn A[A_start + k - 1];\n\t\t}\n\n\t\tif (k == 1) {\n\t\t\treturn Math.min(A[A_start], B[B_start]);\n\t\t}\n\t\t\n\t\tint A_key = A_start + k / 2 - 1 &lt; A.length\n\t\t            ? A[A_start + k / 2 - 1]\n\t\t            : Integer.MAX_VALUE;\n\t\tint B_key = B_start + k / 2 - 1 &lt; B.length\n\t\t            ? B[B_start + k / 2 - 1]\n\t\t            : Integer.MAX_VALUE; \n\t\t\n\t\tif (A_key &lt; B_key) {\n\t\t\treturn findKth(A, A_start + k / 2, B, B_start, k - k / 2);\n\t\t} else {\n\t\t\treturn findKth(A, A_start, B, B_start + k / 2, k - k / 2);\n\t\t}\n\t}\n}\n</code>",
        "runtime" : "5ms, 100%"
      } ],
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        total = len(nums1) + len(nums2)\n        if total & 0x1:\n            return self.findKth(nums1, nums2, total/2+1)\n        else:\n            smaller = self.findKth(nums1, nums2, total/2)\n            bigger = self.findKth(nums1, nums2, total/2+1)\n            return (smaller+bigger)/2.0\n\n    def findKth(self, nums1, nums2, k):\n        if len(nums1) == 0:\n            return nums2[k-1]\n        if len(nums2) == 0:\n            return nums1[k-1]\n        if k == 1:\n            return min(nums1[0], nums2[0])\n        a =nums1[k/2-1] if len(nums1)&gt;= k/2 else float('inf')\n        b =nums2[k/2-1] if len(nums2)&gt;= k/2 else float('inf')\n        if a &lt; b:\n            return self.findKth(nums1[k/2:],nums2, k-k/2)\n        else:\n            return self.findKth(nums1, nums2[k/2:], k-k/2)\n   </code>",
        "runtime" : "89ms, 95.61%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Median of Two Sorted Arrays"
  }, {
    "Description" : "Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\n\nExample:\n\n\nInput: \"babad\"\n\nOutput: \"bab\"\n\nNote: \"aba\" is also a valid answer.\nExample:\n\nInput: \"cbbd\"\n\nOutput: \"bb\"",
    "Difficulty" : "Medium",
    "Number" : "5",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\npublic class Solution {\n    public String longestPalindrome(String s) {\n        String T = preProcess(s);\n        int n = T.length();\n        int[] p = new int[n];\n        int center = 0, right = 0;\n        for (int i = 1; i &lt; n - 1; i++) {\n            int j = 2 * center - i;  //j and i are symmetric around center\n            p[i] = (right &gt; i) ? Math.min(right - i, p[j]) : 0;\n            \n            // Expand palindrome centered at i\n            while (T.charAt(i + 1 + p[i]) == T.charAt(i - 1 - p[i]))\n                p[i]++;\n            \n            // If palindrome centered at i expand past right,\n            // then adjust center based on expand palindrome\n            if (i + p[i] &gt; right) {\n                center = i;\n                right = i + p[i];\n            }\n        }\n        \n        //  Find the longest palindrome\n        int maxLength = 0, centerIndex = 0;\n        for (int i = 1; i &lt; n - 1; i++) {\n            if (p[i] &gt; maxLength) {\n                maxLength = p[i];\n                centerIndex = i;\n            }\n        }\n        centerIndex = (centerIndex - 1 - maxLength) / 2;\n        return s.substring(centerIndex, centerIndex + maxLength);\n    }\n    \n    // preProcess the original string s.\n    // For example, s = \"abcdefg\", then the rvalue = \"^#a#b#c#d#e#f#g#$\"\n    private String preProcess(String s) {\n        if (s == null || s.length() == 0)  return \"^$\";\n        StringBuilder rvalue = new StringBuilder(\"^\");\n        for (int i = 0; i &lt; s.length(); i++)\n            rvalue.append(\"#\").append(s.substring(i, i+1));\n        rvalue.append(\"#$\");\n        return rvalue.toString();\n    }\n}\n</code>",
        "runtime" : "36ms, 47.67%"
      }, {
        "code" : "<code>\npublic class Solution {\n    public String longestPalindrome(String s) {\n        int len = s.length();\n        Boolean[] ref = new Boolean[len+1];//用来记录i到j的string是不是palindrome\n        java.util.Arrays.fill(ref, true);\n\n        int maxlen = 0;\n        int maxi = 0;\n        for (int j = 0; j &lt; len; j++) // Beginning of the string\n            {\n                for (int i = 0; i &lt;= j; i++) \n                {   \n                    if (s.charAt(i) == s.charAt(j)) ref[i] = ref[i+1];\n                    else ref[i] = false;\n\n                    if (ref[i]) {\n                        int curlen = j - i + 1;\n                        if (curlen &gt; maxlen) {maxi = i; maxlen = curlen;}\n                    }    // If ref[j] is true, then update the answer\n                }\n            }          \n        return s.substring(maxi, maxi + maxlen);\n    }\n}\n</code>",
        "runtime" : "72ms, 29.45%"
      } ],
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def longestPalindrome(self, s):\n        if not s or len(s) == 1:\n            return s\n        longest = s[:1]\n        for i in xrange(len(s)):\n            exp1 = self.expand(s, i, i)\n            if len(exp1) &gt; len(longest):\n                longest = exp1\n            exp2 = self.expand(s, i, i+1)\n            if len(exp2) &gt; len(longest):\n                longest = exp2\n        return longest\n    \n    def expand(self, s, left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left+1:right]\n</code>",
        "runtime" : "1268ms, 27.64%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Longest Palindromic Substring"
  }, {
    "Description" : "The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\nP   A   H   N\nA P L S I I G\nY   I   R\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\nWrite the code that will take a string and make this conversion given a number of rows:\n\nstring convert(string text, int nRows);\nconvert(\"PAYPALISHIRING\", 3) should return \"PAHNAPLSIIGYIR\".",
    "Difficulty" : "Easy",
    "Number" : "6",
    "Solutions" : {
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def convert(self, s, numRows):\n        length = len(s)\n        if length &lt;= numRows or numRows == 1:\n            return s\n        charList = [''] * length\n        step = 2 * (numRows - 1)\n        count = 0\n        for i in xrange(numRows):\n            interval = step - 2 * i\n            for j in xrange(i, length, step):\n                charList[count] = s[j]\n                count += 1\n                if 0 &lt; interval &lt; step and \\\n                    j + interval &lt; length and \\\n                    count &lt; length:\n                        charList[count] = s[j+interval]\n                        count += 1\n        return ''.join(charList)\n</code>",
        "runtime" : "115ms, 71.13%"
      }, {
        "code" : "<code>\nclass Solution(object):\n    def convert(self, s, numRows):\n        length = len(s)\n        if length &lt;= numRows or numRows == 1:\n            return s\n        charList = [''] * length\n        step = 2 * (numRows - 1)\n        count = 0\n        for i in xrange(numRows):\n            interval = step - 2 * i\n            for j in xrange(i, length, step):\n                charList[count] = s[j]\n                count += 1\n                if 0 &lt; interval &lt; step and \\\n                    j + interval &lt; length and \\\n                    count &lt; length:\n                        charList[count] = s[j+interval]\n                        count += 1\n        return ''.join(charList)\n</code>",
        "runtime" : "140ms, 40.69%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "ZigZag Conversion"
  }, {
    "Description" : "Reverse digits of an integer.\n\nExample1: x = 123, return 321\nExample2: x = -123, return -321",
    "Difficulty" : "Easy",
    "Number" : "7",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\npublic class Solution {\n    public int reverse(int n) {\n        if (n &lt; 0) {\n            if ( n == -2147483648) {\n                return 0;\n            }\n            return -reverse(-n);\n        }\n        int result = 0;\n        while(n != 0){\n\n            if (result &gt; Integer.MAX_VALUE/10){\n                return 0;\n            }\n            result = result * 10 + n % 10;\n            n /= 10;\n        }\n        \n        return result;\n    }\n}\n</code>",
        "runtime" : "2ms, 100%"
      } ],
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def reverse(self, x):\n        if x &lt; 0:\n            return -self.reverse(-x)\n        result = 0\n        while x != 0:\n            result = result * 10 + x % 10\n            x /= 10\n        return result if result &lt; 0x7FFFFFFF else 0\n</code>",
        "runtime" : "59ms, 51.08%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Reverse Integer"
  }, {
    "Description" : "Implement atoi to convert a string to an integer.\n\nHint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.\n\nNotes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.",
    "Difficulty" : "Medium",
    "Number" : "8",
    "Solutions" : {
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def myAtoi(self, str):\n        str = str.strip()\n        if not str:\n            return 0\n        result, sign = 0, 1\n        MIN_INT = -1&lt;&lt;31\n        MAX_INT = -(MIN_INT + 1)\n        i = 0\n        \n        if str[i] in '+-':\n            if str[i] == '-':\n                sign = -1\n            i += 1\n        while i &lt; len(str):\n            if not str[i].isdigit():\n                break\n            result = result * 10 + ord(str[i]) - ord('0')\n            i += 1\n        result *= sign\n        return min(MAX_INT, result) if result &gt; 0 else max(MIN_INT, result)\n</code>",
        "runtime" : "56ms, 99.25%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "String to Integer (atoi)"
  }, {
    "Description" : "Determine whether an integer is a palindrome. Do this without extra space.",
    "Difficulty" : "Easy",
    "Number" : "9",
    "Solutions" : {
      "Go" : [ {
        "code" : "<code>\nfunc isPalindrome(x int) bool {\n    if x &lt; 0 {\n        return false\n    }\n    \n    d := 1\n    for x / d &gt;= 10 {\n        d *= 10\n    }\n    \n    for d &gt; 1 {\n        if x / d != x % 10 {\n            return false\n        }\n        x = x % d / 10\n        d /= 100\n    }\n    return true\n}\n</code>",
        "runtime" : "89ms, 11.27%"
      } ],
      "Java" : [ {
        "code" : "<code>\npublic class Solution {\n    public boolean isPalindrome(int x) {\n        if (x &lt; 0) {\n            return false;\n        }\n        return x == reverse(x);\n    }\n    \n    public int reverse(int x) {\n        int result = 0;\n        while (x != 0) {\n            result = result * 10 + x % 10;\n            x = x / 10;\n        }\n        return result;\n    }\n}\n</code>",
        "runtime" : "12ms, 100%"
      } ],
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def isPalindrome(self, x):\n        if x < 0:\n            return False\n        d = 1\n        while x / d >= 10:\n            d *= 10\n        while d > 1:\n            if x / d != x % 10:\n                return False\n            x = x % d / 10\n            d /= 100\n        return True\n</code>",
        "runtime" : "209ms, 87.74%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Palindrome Number"
  }, {
    "Description" : "Implement regular expression matching with support for '.' and '*'.\n\n'.' Matches any single character.\n'*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\nThe function prototype should be:\nbool isMatch(const char *s, const char *p)\n\nSome examples:\nisMatch(\"aa\",\"a\") → false\nisMatch(\"aa\",\"aa\") → true\nisMatch(\"aaa\",\"aa\") → false\nisMatch(\"aa\", \"a*\") → true\nisMatch(\"aa\", \".*\") → true\nisMatch(\"ab\", \".*\") → true\nisMatch(\"aab\", \"c*a*b\") → true",
    "Difficulty" : "Hard",
    "Number" : "10",
    "Solutions" : {
      "Java" : [ {
        "code" : "Time Complexity:  O(mn), Space: O(mn)\n<code>\npublic class Solution {\n    public boolean isMatch(String s, String p) {\n        if (s == null || p == null) {\n            return false;\n        }\n        int m = s.length();\n        int n = p.length();\n        boolean[][] result = new boolean[m + 1][n + 1];\n        result[0][0] = true;\n        for (int i = 1; i &lt;= m; i++) {\n            result[i][0] = false;\n        }\n        for (int i = 1; i &lt;= n; i++) {\n            if (p.charAt(i - 1) == '*') {\n                result[0][i] = result[0][i - 2];\n            }\n        }\n        for (int i = 1; i &lt;= m; i++) {\n            for (int j = 1; j &lt;= n; j++) {\n                char c1 = s.charAt(i - 1);\n                char c2 = p.charAt(j - 1);\n                if (c2 == '*') {\n                    result[i][j] = result[i][j - 2] || match(c1, p.charAt(j - 2)) && result[i][j - 2] || match(c1, p.charAt(j - 2)) && result[i - 1][j];\n                } else {\n                    result[i][j] = match(c1, c2) && result[i - 1][j - 1];\n                }\n            }\n        }\n        return result[m][n];\n    }\n    public boolean match(char c1, char c2) {\n        return c2 == '.' || c2 == c1;\n    }\n}\n</code>",
        "runtime" : "30ms, 75.15%"
      } ],
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        if s is None and p is None:\n            return True\n        if s is None or p is None:\n            return False\n        m, n = len(s), len(p)\n        dp = [[False] * (n+1) for _ in xrange(m+1)]\n        dp[0][0] = True\n        \n        def match(s, p):\n            return s == p or p == '.'\n            \n        for j in xrange(1, n+1):\n            if p[j-1] == '*':\n                dp[0][j] = dp[0][j-2]\n        for i in xrange(1, m+1):\n            for j in xrange(1, n+1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i][j-2] or match(s[i-1], p[j-2]) and dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j-1] and match(s[i-1], p[j-1])\n        return dp[m][n]\n</code>",
        "runtime" : "72ms, 94.55%"
      }, {
        "code" : "<code>\nclass Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        if s is None or p is None:\n            return False\n        m, n = len(s), len(p)\n        dp = [[False] * (n+1) for _ in xrange(m+1)]\n        dp[0][0] = True\n        \n        def match(c1, c2):\n            return c1 == c2 or c2 == '.'\n            \n        for i in xrange(1,n+1):\n            if i &gt; 0 and p[i-1] == '*':\n                dp[0][i] = dp[0][i-2]\n        for i in xrange(1,m+1):\n            for j in xrange(1, n+1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i][j-2] or match(s[i-1],p[j-2]) and (dp[i][j-2] or dp[i-1][j])\n                else:\n                    dp[i][j] = match(s[i-1], p[j-1]) and dp[i-1][j-1]\n        return dp[m][n]\n</code>",
        "runtime" : "99ms, 57.58%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Regular Expression Matching"
  }, {
    "Description" : "Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n\nNote: You may not slant the container and n is at least 2.",
    "Difficulty" : "Medium",
    "Number" : "11",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\npublic class Solution {\n    public int maxArea(int[] height) {\n        if (height == null || height.length &lt;= 1) {\n            return 0;\n        }\n        int left = 0, right = height.length - 1;\n        int max = 0;\n        while (left &lt; right) {\n            if (height[left] &lt; height[right]) {\n                max = Math.max(max, height[left] * (right - left));\n                left++;\n            } else {\n                max = Math.max(max, height[right] * (right - left));\n                right--;\n            }\n        }\n        return max;\n    }\n}\n</code>",
        "runtime" : "4ms, 100%"
      } ],
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        maxarea = 0\n        left, right = 0, len(height) - 1\n        while left &lt; right:\n            maxarea = max(maxarea, (right - left) * min(height[left], height[right]))\n            if height[left] &lt; height[right]:\n                left += 1\n            else:\n                right -= 1\n        return maxarea\n</code>",
        "runtime" : "69ms, 85.99%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Container With Most Water"
  }, {
    "Description" : "Given an integer, convert it to a roman numeral.\n\nInput is guaranteed to be within the range from 1 to 3999.",
    "Difficulty" : "Medium",
    "Number" : "12",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\npublic class Solution {\n    public String intToRoman(int num) {\n        String[] romanChar = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n        int[] integer = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        StringBuilder stringBuilder = new StringBuilder();\n        for (int i = 0; i &lt; romanChar.length; i++) {\n            while (num &gt;= integer[i]) {\n                num -= integer[i];\n                stringBuilder.append(romanChar[i]);\n            }\n        }\n        return stringBuilder.toString();\n    }\n}\n</code>",
        "runtime" : "7ms, 100%"
      } ],
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        romans = ['M','CM','D','CD','C','XC','L','XL','X','IX','V','IV','I']\n        numbers = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\n        resultList = []\n        for i in xrange(len(romans)):\n            while num - numbers[i] &gt;= 0:\n                resultList.append(romans[i])\n                num -= numbers[i]\n        return ''.join(resultList)\n</code>",
        "runtime" : "142ms, 35.21%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Integer to Roman"
  }, {
    "Description" : "Given a roman numeral, convert it to an integer.\n\nInput is guaranteed to be within the range from 1 to 3999.",
    "Difficulty" : "Easy",
    "Number" : "13",
    "Solutions" : {
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        dic = {'M':1000,'D':500,'C':100,'L':50,'X':10,'V':5,'I':1}\n        result = 0\n        prev = 0\n        for c in s:\n            curr = dic[c]\n            result += curr\n            if curr &gt; prev:\n                result -= 2 *prev\n            prev = curr\n        return result     \n</code>",
        "runtime" : "148ms, 61.48%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Roman to Integer"
  }, {
    "Description" : "Write a function to find the longest common prefix string amongst an array of strings.",
    "Difficulty" : "Easy",
    "Number" : "14",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\npublic class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if (strs.length == 0 || strs == null) {\n            return \"\";\n        }\n        \n        String commonPrefix = strs[0];\n        \n        for (int i = 1; i &lt; strs.length; i++) {\n            int index = 0;\n            while (index &lt; strs[i].length() && index &lt; commonPrefix.length() && \n                    commonPrefix.charAt(index) == strs[i].charAt(index)) {\n                index++;\n            }\n            if (index == 0) {\n                return \"\";\n            } else {\n                commonPrefix = commonPrefix.substring(0, index);\n            }\n        }\n        return commonPrefix;\n    }\n}\n</code>",
        "runtime" : "5ms, 100%"
      } ],
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if not strs:\n            return ''\n        shortest = strs[0]\n        for s in strs:\n            if len(s) &lt; len(shortest):\n                shortest = s\n        for i in xrange(len(shortest)):\n            for s in strs:\n                if s[i] != shortest[i]:\n                    return shortest[:i]\n        return shortest\n</code>",
        "runtime" : "64ms, 25.25%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Longest Common Prefix"
  }, {
    "Description" : "Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n\nNote: The solution set must not contain duplicate triplets.\n\nFor example, given array S = [-1, 0, 1, 2, -1, -4],\n\nA solution set is:\n[\n  [-1, 0, 1],\n  [-1, -1, 2]\n]",
    "Difficulty" : "Medium",
    "Number" : "15",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\npublic class Solution {\n    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {\n        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();\n        if (nums == null || nums.length == 0) {\n            return res;\n        }\n        Arrays.sort(nums);\n        quickSort(nums, 0, nums.length - 1);\n        for (int i = 0; i &lt;= nums.length - 3; i++) {\n            if (i &gt; 0 && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            int left = i + 1, right = nums.length - 1;\n            while (left &lt; right) {\n                int sum = nums[i] + nums[left] + nums[right];\n                if (sum == 0) {\n                    Integer[] arr = {nums[i], nums[left], nums[right]};\n                    List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(arr));\n                    res.add(list);\n                    left++;\n                    while (left &lt; right && nums[left] == nums[left - 1]) {\n                        left++;\n                    }\n                    right--;\n                    while (left &lt; right && nums[right] == nums[right + 1]) {\n                        right--;\n                    }\n                } else if (sum &gt; 0) {\n                    right--;\n                } else {\n                    left++;\n                }\n            }\n        }\n        return res;\n    }\n    \n    private void quickSort(int[] nums, int start, int end) {\n        int p = partition(nums, start, end);\n        if (p &gt; start + 1) {\n            quickSort(nums, start, p - 1);\n        }\n        if (p &lt; end - 1) {\n            quickSort(nums, p + 1, end);\n        }\n    }\n    private int partition(int[] nums, int start, int end) {\n        int pivot = nums[start];\n        int i = start;\n        int j = end + 1;\n        while (true) {\n            while(i &lt; end && nums[++i] &lt; pivot);\n            while (j &gt; start && nums[--j] &gt; pivot);\n            if (i &gt;= j) {\n                break;\n            }\n            swap(nums, i, j);\n        }\n        swap(nums, start, j);\n        return j;\n    }\n    private void swap(int[] nums, int i, int j) {\n        int tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n}\n</code>",
        "runtime" : "15ms, 100%"
      } ],
      "Python" : [ {
        "code" : "Python \n<code>\nclass Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if len(nums) &lt; 3:\n            return []\n        result = []\n        nums.sort()\n        \n        for i in xrange(len(nums)-2):\n            if i == 0 or nums[i] != nums[i-1]:\n                left, right = i+1, len(nums)-1\n                while left &lt; right:\n                    tmp = nums[i] + nums[left] + nums[right]\n                    if tmp == 0:\n                        result.append([nums[i], nums[left], nums[right]])\n                        left += 1\n                        right -= 1\n                        while left &lt; right and nums[left] == nums[left-1]:\n                            left += 1\n                        while left &lt; right and nums[right] == nums[right+1]:\n                            right -= 1\n                    elif tmp &lt; 0:\n                        left += 1\n                    else:\n                        right -= 1\n        return result\n</code>",
        "runtime" : "200ms, 60.03%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "3Sum"
  }, {
    "Description" : "Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n\n    For example, given array S = {-1 2 1 -4}, and target = 1.\n\n    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).",
    "Difficulty" : "Medium",
    "Number" : "16",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\npublic class Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n        int closetSum = Integer.MAX_VALUE;\n        int gap = closetSum;\n        for (int i = 0; i &lt; nums.length; i++) {\n            int left = i + 1;\n            int right = nums.length - 1;\n            while (left &lt; right) {\n                int sum = nums[i] + nums[left] + nums[right];\n                if (gap &gt; Math.abs(target - sum)) {\n                    gap = Math.abs(target - sum);\n                    closetSum = sum;\n                }\n                if (sum &lt; target) {\n                    left++;\n                } else if (sum &gt; target) {\n                    right--;\n                } else {\n                    return target;\n                }\n            }\n        }\n        return closetSum;\n    }\n}\n</code>",
        "runtime" : "12ms, 100%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "3Sum Closest"
  }, {
    "Description" : "Given a digit string, return all possible letter combinations that the number could represent.\n\nA mapping of digit to letters (just like on the telephone buttons) is given below.\n\nInput:Digit string \"23\"\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].\nNote:\nAlthough the above answer is in lexicographical order, your answer could be in any order you want.",
    "Difficulty" : "Medium",
    "Number" : "17",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\npublic class Solution {\n    public List&lt;String&gt; letterCombinations(String digits) {\n        List&lt;String&gt; result = new ArrayList&lt;&gt;();\n        if (digits == null || digits.length() == 0) {\n            return result;\n        }\n        result.add(\"\");\n        String[] map = new String[]{\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        for (int i = 0; i &lt; digits.length(); i++) {\n            int index = (int) (digits.charAt(i) - '0');\n            List&lt;String&gt; temp = new ArrayList&lt;&gt;();\n            for (String res : result) {\n                for(char letter : map[index].toCharArray()) {\n                    temp.add(res + letter);\n                }\n            }\n            result = temp;\n        }\n        return result;\n    }\n}\n</code>\n",
        "runtime" : "1ms, 100%"
      } ],
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        if not digits:\n            return  []\n        d = { '2':'abc', '3':'def', '4':'ghi',\n              '5':'jkl', '6':'mno', '7':'pqrs',\n              '8':'tuv', '9':'wxyz' }\n        results = []\n        self.dfs(digits, d, results, [], 0)\n        return results\n    \n    def dfs(self, digits, d, results, result, index):\n        if len(result) == len(digits):\n            results.append(''.join(result[:]))\n            return\n        else:\n            for i in xrange(index, len(digits)):\n                for c in d[digits[i]]:\n                    result.append(c)\n                    self.dfs(digits, d, results, result, i + 1)\n                    result.pop()\n          </code>         ",
        "runtime" : "49ms, 37.54%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Letter Combinations of a Phone Number"
  }, {
    "Description" : "Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\n\nNote: The solution set must not contain duplicate quadruplets.\n\nFor example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.\n\nA solution set is:\n[\n  [-1,  0, 0, 1],\n  [-2, -1, 1, 2],\n  [-2,  0, 0, 2]\n]",
    "Difficulty" : "Medium",
    "Number" : "18",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\npublic class Solution {\n    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) {\n        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n        if (nums == null || nums.length == 0) {\n            return result;\n        }\n        Arrays.sort(nums);\n        for (int i = 0; i &lt; nums.length - 3; i++) {\n            if (i &gt; 0 && nums[i - 1] == nums[i]) {\n                continue;\n            }\n            for (int j = i + 1; j &lt; nums.length - 2; j++) {\n                if (j &gt; i + 1 && nums[j - 1] == nums[j]) {\n                    continue;\n                }\n                int start = j + 1;\n                int end = nums.length - 1;\n                int findNum = target - nums[i] - nums[j];\n                while (start &lt; end) {\n                    if (nums[start] + nums[end] == findNum) {\n                        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n                        list.add(nums[i]);\n                        list.add(nums[j]);\n                        list.add(nums[start]);\n                        list.add(nums[end]);\n                        result.add(list);\n                        while (start &lt; end && nums[start + 1] == nums[start]) {\n                            start++;\n                        }\n                        while (start &lt; end && nums[end - 1] == nums[end]) {\n                            end--;\n                        }\n                        start++;\n                        end--;\n                    } else if (nums[start] + nums[end] &lt; findNum) {\n                        start++;\n                    } else {\n                        end--;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\n</code>",
        "runtime" : "53ms, 84.42%"
      } ],
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if not nums or len(nums) &lt; 4:\n            return []\n        n, result, d = len(nums), set(), collections.defaultdict(list)\n        # nums.sort()\n        for i in xrange(n-1):\n            for j in xrange(i+1, n):\n                gap = target - nums[i] - nums[j]\n                if gap in d:\n                    for pair in d[gap]:\n                        tmp = pair[:] + [i,j]\n                        if len(set(tmp)) == 4:\n                            result.add(tuple(list(sorted(map(nums.__getitem__, tmp)))))\n                d[nums[i] + nums[j]].append([i, j])\n        result = map(list, result)\n        return result\n</code>",
        "runtime" : "225ms, 75.65%"
      }, {
        "code" : "<code>\nclass Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        results = []\n        self.findNsum(nums, target, 4, [], results)\n        return results\n\n    def findNsum(self, nums, target, N, result, results):\n        if len(nums) &lt; N or N &lt; 2: return\n\n        # solve 2-sum\n        if N == 2:\n            l,r = 0,len(nums)-1\n            while l &lt; r:\n                if nums[l] + nums[r] == target:\n                    results.append(result + [nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l &lt; r and nums[l] == nums[l - 1]:\n                        l += 1\n                    while r &gt; l and nums[r] == nums[r + 1]:\n                        r -= 1\n                elif nums[l] + nums[r] &lt; target:\n                    l += 1\n                else:\n                    r -= 1\n        else:\n            for i in range(0, len(nums)-N+1):   # careful about range\n                if target &lt; nums[i]*N or target &gt; nums[-1]*N:  # take advantages of sorted list\n                    break\n                if i == 0 or i &gt; 0 and nums[i-1] != nums[i]:  # recursively reduce N\n                    self.findNsum(nums[i+1:], target-nums[i], N-1, result+[nums[i]], results) \n</code>",
        "runtime" : "125ms, 87.63%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "4Sum"
  }, {
    "Description" : "Given a linked list, remove the nth node from the end of list and return its head.\n\nFor example,\n\n   Given linked list: 1->2->3->4->5, and n = 2.\n\n   After removing the second node from the end, the linked list becomes 1->2->3->5.\nNote:\nGiven n will always be valid.\nTry to do this in one pass.",
    "Difficulty" : "Medium",
    "Number" : "19",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        if (head == null || n &lt;= 0) {\n            return head;\n        }\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode preNode = dummy;\n        for (int i = 0; i &lt; n; i++) {\n            head = head.next;\n        }\n        while (head != null) {\n            head = head.next;\n            preNode = preNode.next;\n        }\n        preNode.next = preNode.next.next;\n        return dummy.next;\n    }\n}\n</code>",
        "runtime" : "1ms, 100%"
      } ],
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        dummy = ListNode(0)\n        dummy.next = head\n        slow = fast = dummy\n        while n &gt; 0:\n            fast = fast.next\n            n -= 1\n        while fast.next:\n            slow = slow.next\n            fast = fast.next\n        slow.next = slow.next.next\n        return dummy.next\n</code>",
        "runtime" : "46ms, 78.95%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Remove Nth Node From End of List"
  }, {
    "Description" : "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nThe brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.",
    "Difficulty" : "Easy",
    "Number" : "20",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\npublic class Solution {\n    public boolean isValid(String s) {\n        if(s == null || s.length() % 2 == 1) {\n            return false;\n        }\n        Map&lt;Character, Character&gt; map = new HashMap();\n        map.put('(', ')');\n        map.put('[', ']');\n        map.put('{', '}');\n        Stack&lt;Character&gt; stack = new Stack();\n        for (int i = 0; i &lt; s.length(); i++) {\n            char c = s.charAt(i);\n            if (map.containsKey(c)) {\n                stack.push(c);\n            } else {\n                if (stack.isEmpty() || map.get(stack.peek()) != c) {\n                    return false;\n                }\n                stack.pop();\n            }\n        }\n        return stack.isEmpty();\n    }\n}\n</code>",
        "runtime" : "6ms, 95.48%"
      } ],
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        stack = []\n        d = {'(':')', '[':']', '{':'}'}\n        for c in s:\n            if c in '([{':\n                stack.append(c)\n            else:\n                if not stack or d[stack[-1]] != c:\n                    return False\n                stack.pop()\n        return not bool(stack)\n</code>",
        "runtime" : "32ms, 99.23%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Valid Parentheses"
  }, {
    "Description" : "Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.",
    "Difficulty" : "Easy",
    "Number" : "21",
    "Solutions" : {
      "Python" : [ {
        "code" : "<code>\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        curr = dummy = ListNode(0)\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                curr.next, l1 = l1, l1.next\n            else:\n                curr.next, l2 = l2, l2.next\n            curr = curr.next\n        curr.next = l1 or l2\n        return dummy.next\n</code>",
        "runtime" : "46ms, 98.52%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Merge Two Sorted Lists"
  }, {
    "Description" : "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\nFor example, given n = 3, a solution set is:\n\n[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]\n",
    "Difficulty" : "Medium",
    "Number" : "22",
    "Solutions" : {
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        result = []\n        self.bfs(n, result)\n        return result\n        \n    def bfs(self, n, result):\n        \n        queue = [(0,0,'')]\n        while queue:\n            x, y, s = queue.pop(0)\n            if y == n:\n                result.append(s)\n            if x &lt; n:\n                queue.append((x+1, y, s + '('))\n            if x &gt; y:\n                queue.append((x, y+1, s + ')'))\n</code>",
        "runtime" : "62ms, 32.45%"
      }, {
        "code" : "<code>\nclass Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        results = []\n        self.dfs(n, 0, 0, '', results)\n        return results\n        \n    def dfs(self, n, left, right, result,results):\n        if left == n and right == n:\n            results.append(result)\n            return\n        if left &lt; n:\n            self.dfs(n, left + 1, right, result + '(', results)\n        if left &gt; right:\n            self.dfs(n, left, right + 1, result + ')', results)\n</code>",
        "runtime" : "56ms, 49.27%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Generate Parentheses"
  }, {
    "Description" : "Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.",
    "Difficulty" : "Hard",
    "Number" : "23",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n// Yutao Hou\npublic class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) {\n            return null;\n        }\n        int left = 0, right = lists.length - 1;\n        while (left &lt; right) {\n            int l = left, r = right;\n            while (l &lt; r) {\n                lists[l] = merge(lists[l], lists[r]);\n                l++;\n                r--;\n            }\n            right = r;\n        }\n        return lists[left];\n    }\n    private ListNode merge(ListNode list1, ListNode list2) {\n        if (list1 == null || list2 == null) {\n            return list1 == null ? list2 : list1;\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode node = dummy;\n        while (list1 != null && list2 != null) {\n            if (list1.val &lt; list2.val) {\n                node.next = list1;\n                list1 = list1.next;\n            } else {\n                node.next = list2;\n                list2 = list2.next;\n            }\n            node = node.next;\n        }\n        if (list1 != null) {\n            node.next = list1;\n        }\n        if (list2 != null) {\n            node.next = list2;\n        }\n        return dummy.next;\n    }\n}\n</code>",
        "runtime" : "4ms, 100%"
      } ],
      "Python" : [ {
        "code" : "<code>\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        n = len(lists)\n        left = self.mergeKLists(lists[:n/2])\n        right = self.mergeKLists(lists[n/2:])\n        return self.merge(left, right)\n        \n    def merge(self, l1, l2):\n        \n        curr = dummy = ListNode(0)\n        while l1 and l2:\n            if l1.val &lt; l2.val:\n                curr.next, l1 = l1, l1.next\n            else:\n                curr.next, l2 = l2, l2.next\n            curr = curr.next\n        curr.next = l1 or l2\n        return dummy.next\n</code>",
        "runtime" : "152ms, 52.58%"
      }, {
        "code" : "<code>\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        from heapq import heappush, heappop, heapreplace, heapify\n        dummy = node = ListNode(0)\n        h = [(n.val, n) for n in lists if n]\n        heapify(h)\n        while h:\n            v, n = h[0]\n            if n.next is None:\n                heappop(h) #only change heap size when necessary\n            else:\n                heapreplace(h, (n.next.val, n.next))\n            node.next = n\n            node = node.next\n\n        return dummy.next\n</code>",
        "runtime" : "156ms, 49.54%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Merge k Sorted Lists"
  }, {
    "Description" : "Given a linked list, swap every two adjacent nodes and return its head.\n\nFor example,\nGiven 1->2->3->4, you should return the list as 2->1->4->3.\n\nYour algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.",
    "Difficulty" : "Medium",
    "Number" : "24",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        \n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        head = dummy;\n        \n        while (head.next != null && head.next.next != null) {\n            // head point moves to the second node\n            ListNode node1 = head.next, node2 = head.next.next;\n            \n            head.next = node2;\n            node1.next = node2.next;\n            node2.next = node1;\n            \n            head = node1;\n        }\n        return dummy.next;\n    }\n}\n</code>",
        "runtime" : "0ms, 100%"
      }, {
        "code" : "<code>\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode pre = dummy;\n        while (head != null && head.next != null) {\n            ListNode third = head.next.next;\n            pre.next = head.next;\n            pre.next.next = head;\n            head.next = third;\n            pre = head;\n            head = third;\n        }\n        return dummy.next;\n    }\n}\n</code>",
        "runtime" : "0ms, 100%"
      } ],
      "Python" : [ {
        "code" : "<code>\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        while head and head.next:\n            third = head.next.next\n            pre.next = head.next\n            head.next.next = head\n            head.next = third\n            pre = head\n            head = third\n        return dummy.next\n</code>",
        "runtime" : "59ms, 13.02%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Swap Nodes in Pairs"
  }, {
    "Description" : "Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.\n\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\n\nYou may not alter the values in the nodes, only nodes itself may be changed.\n\nOnly constant memory is allowed.\n\nFor example,\nGiven this linked list: 1->2->3->4->5\n\nFor k = 2, you should return: 2->1->4->3->5\n\nFor k = 3, you should return: 3->2->1->4->5",
    "Difficulty" : "Hard",
    "Number" : "25",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\npublic class Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        if (k &lt;= 1) {\n            return head;\n        }\n        ListNode dummy = new ListNode(0);\n        ListNode left = dummy;\n        dummy.next = head;\n        head = dummy;\n        while (true) {\n            for (int i = 0; i &lt; k; i++) {\n                head = head.next;\n                if (head == null) {\n                    return dummy.next;\n                }\n            }\n            ListNode right = head.next;\n            head.next = null;\n            ListNode reverse = getReverse(left.next);\n            left.next.next = right;\n            ListNode nextLeft = left.next;\n            left.next = reverse;\n            left = nextLeft;\n            head = left;\n        }\n    }\n    public ListNode getReverse(ListNode head) {\n        ListNode newNode = null;\n        while (head != null) {\n            ListNode next = head.next;\n            head.next = newNode;\n            newNode = head;\n            head = next;\n        }\n        return newNode;\n    }\n}\n</code>",
        "runtime" : "1ms, 100%"
      } ],
      "Python" : [ {
        "code" : "<code>\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        curr, count = head, 0\n        while curr and count &lt; k:\n            curr, count = curr.next, count + 1\n        if count == k:\n            curr = self.reverseKGroup(curr, k)\n            while k &gt; 0:\n                tmp = head.next\n                head.next = curr\n                curr = head\n                head = tmp\n                k -= 1\n            head = curr\n        return head\n</code>",
        "runtime" : "65ms, 97.33%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Reverse Nodes in k-Group "
  }, {
    "Description" : "Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.\n\nDo not allocate extra space for another array, you must do this in place with constant memory.\n\nFor example,\nGiven input array nums = [1,1,2],\n\nYour function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length.",
    "Difficulty" : "Easy",
    "Number" : "26",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\npublic class Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int start = 1;\n        for (int i = 1; i &lt; nums.length; i++) {\n            if (nums[i] != nums[i - 1]) {\n                nums[start++] = nums[i];\n            }\n        }\n        return start;\n    }\n}\n</code>",
        "runtime" : "2ms, 100%"
      } ],
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        pos = 0\n        for i in xrange(len(nums)):\n            if nums[i] != nums[pos]:\n                pos += 1\n                nums[pos] = nums[i]\n        return pos + 1\n</code>",
        "runtime" : "88ms, 75.54%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Remove Duplicates from Sorted Array"
  }, {
    "Description" : "Given an array and a value, remove all instances of that value in place and return the new length.\n\nDo not allocate extra space for another array, you must do this in place with constant memory.\n\nThe order of elements can be changed. It doesn't matter what you leave beyond the new length.\n\nExample:\nGiven input array nums = [3,2,2,3], val = 3\n\nYour function should return length = 2, with the first two elements of nums being 2.",
    "Difficulty" : "Easy",
    "Number" : "27",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\npublic class Solution {\n    public int removeElement(int[] nums, int val) {\n        int left = 0, right = nums.length - 1;\n        while (left &lt;= right) {\n            if (nums[left] == val) {\n                nums[left] = nums[right];\n                right--;\n            } else {\n                left++;\n            }\n        }\n        return left;\n    }\n}\n</code>",
        "runtime" : "1ms, 100%"
      } ],
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def removeElement(self, nums, val):\n        \"\"\"\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        pos = 0\n        for i in xrange(len(nums)):\n            if nums[i] != val:\n                nums[i], nums[pos] = nums[pos], nums[i]\n                pos += 1\n        return pos\n</code>",
        "runtime" : "56ms, 28.88%"
      }, {
        "code" : "<code>\nclass Solution(object):\n    def removeElement(self, nums, val):\n        \"\"\"\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left &lt;= right:\n            if nums[left] == val:\n                nums[left] = nums[right]\n                right -= 1\n            else:\n                left += 1\n        return left\n</code>",
        "runtime" : "52ms, 38.20%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Remove Element"
  }, {
    "Description" : "Implement strStr().\n\nReturns the index of the first occurrence of needle in haystack, \nor -1 if needle is not part of haystack.",
    "Difficulty" : "Easy",
    "Number" : "28",
    "Solutions" : {
      "Python" : [ {
        "code" : "A naive method. Time complexity:O(mn), m, n is the length of haystack and \nneedle respectively.\n\n<code>\nclass Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        if not haystack and not needle:\n            return 0\n        if not needle:\n            return 0\n        if not haystack:\n            return -1\n        if len(needle) &gt; len(haystack):\n            return -1\n        for i in xrange(len(haystack) - len(needle) + 1):\n            for j in xrange(len(needle)):\n                if haystack[i+j] != needle[j]:\n                    break\n                if j == len(needle)-1:\n                    return i\n        return -1\n</code>",
        "runtime" : "68ms, 24.41%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Implement strStr()"
  }, {
    "Description" : "Divide two integers without using multiplication, division and mod operator.\n\nIf it is overflow, return MAX_INT.",
    "Difficulty" : "Medium",
    "Number" : "29",
    "Solutions" : {
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        negative = -1 if (dividend ^ divisor) &lt; 0 else 1\n        dividend, divisor = abs(dividend), abs(divisor)\n        if dividend &lt; divisor:\n            return 0\n        if dividend == divisor:\n            return negative\n        count = 1\n        s, divide = divisor, 1\n        while (s + s) &lt;= dividend:\n            s += s\n            divide += divide\n        result = negative * (divide + self.divide(dividend - s, divisor))\n        \n        if result &lt; -2147483648:\n            return -2147483648\n        elif result &gt; 2147483647:\n            return 2147483647\n        else:\n            return result\n</code>",
        "runtime" : "49ms, 94.73%"
      }, {
        "code" : "<code>\nclass Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        negative = -1 if (dividend ^ divisor) &lt; 0 else 1\n        dividend, divisor = abs(dividend), abs(divisor)\n        if dividend &lt; divisor:\n            return 0\n        if dividend == divisor:\n            return negative\n        count = 1\n        s, divide = divisor, 1\n        while (s + s) &lt;= dividend:\n            s += s\n            divide &lt;&lt;= 1\n        result = negative * (divide + self.divide(dividend - s, divisor))\n        \n        if result &lt; -2147483648:\n            return -2147483648\n        elif result &gt; 2147483647:\n            return 2147483647\n        else:\n            return result\n</code>",
        "runtime" : "85ms, 11.97%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Divide Two Integers"
  }, {
    "Description" : "You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.\n\nFor example, given:\ns: \"barfoothefoobarman\"\nwords: [\"foo\", \"bar\"]\n\nYou should return the indices: [0,9].\n(order does not matter).",
    "Difficulty" : "Hard",
    "Number" : "30",
    "Solutions" : {
      "Python" : [ {
        "code" : "<code>\nimport collections\nclass Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        target = collections.defaultdict(int)\n        result = []\n        for word in words:\n            target[word] += 1\n        lenword, lenwords, lens = len(words[0]), len(words), len(s)\n        for i in xrange(lens - lenword * lenwords + 1):\n            scan = target.copy()\n            for j in xrange(i, i + lenword * lenwords, lenword):\n                tmpstr = s[j:j+lenword]\n                if tmpstr not in scan:\n                    break\n                scan[tmpstr] -= 1\n                if scan[tmpstr] == 0:\n                    del scan[tmpstr]\n            if len(scan) == 0:\n                result.append(i)\n        return result\n</code>",
        "runtime" : "449ms, 45.43%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Substring with Concatenation of All Words"
  }, {
    "Description" : "Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\n\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\n\nThe replacement must be in-place, do not allocate extra memory.\n\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n1,2,3 → 1,3,2\n3,2,1 → 1,2,3\n1,1,5 → 1,5,1",
    "Difficulty" : "Medium",
    "Number" : "31",
    "Solutions" : {
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \"\"\"\n        Now let's pick a number, for example, 24387651.\n\n        what is the next permutation? 24513678.\n\n        How can I get the answer?\n\n        First step: find the first ascending digit from the back of the number. 3 &lt; 8 &gt; 7 &gt; 6 &gt; 5 &gt; 1. Then 3 is the digit.\n\n        Second step: swap that digit with the next big digit in following digits. Which one is the next big digit in 87651? 5! So swap them. Now the number becomes 24587631.\n\n        Third step: sort 87631 into 13678. The final answer is 24513678.\n        \"\"\"\n        k = -1\n        for i in reversed(xrange(len(nums)-1)):\n            if nums[i] &lt; nums[i+1]:\n                k = i\n                break\n        if k == -1:\n            nums.reverse()\n            return\n        n = 0 \n        for i in reversed(xrange(k+1, len(nums))):\n            if nums[i] &gt; nums[k]:\n                n = i\n                break\n        nums[k], nums[n] = nums[n], nums[k]\n        nums[k+1:] = reversed(nums[k+1:])\n</code>",
        "runtime" : "52ms, 96.89%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Next Permutation"
  }, {
    "Description" : "Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.\n\nFor \"(()\", the longest valid parentheses substring is \"()\", which has length = 2.\n\nAnother example is \")()())\", where the longest valid parentheses substring is \"()()\", which has length = 4.\n",
    "Difficulty" : "Hard",
    "Number" : "32",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\npublic class Solution {\n    public int longestValidParentheses(String s) {\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n        Stack&lt;Integer&gt; index = new Stack&lt;Integer&gt;();\n        int res = 0;\n        int start = -1;\n          for (int i = 0; i &lt; s.length(); i++) {\n            char c = s.charAt(i);\n            if (s.charAt(i) == '(') {\n              index.push(i);\n            } else {\n                if (!index.isEmpty()){\n                    index.pop();\n                    if (!index.isEmpty()){\n                        res = Math.max(res, i - index.peek());\n                    } else {\n                        res = Math.max(res, i - start);\n                    }\n                } else {\n                    start = i;\n                }\n            }\n          }\n          return res;\n    }\n}\n</code>",
        "runtime" : "11ms, 100%"
      } ],
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        longest, start, stack = 0, -1, []\n        for i, c in enumerate(s):\n            if c == '(':\n                stack.append(i)\n            else:\n                if stack:\n                    stack.pop()\n                    if stack:\n                        longest = max(longest, i - stack[-1])\n                    else:\n                        longest = max(longest, i - start)\n                else:\n                    start = i\n        return longest\n</code>",
        "runtime" : "89ms, 44.96%"
      }, {
        "code" : "<code>\nclass Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, stack = 0, [-1]\n        for i, c in enumerate(s):\n            if c == ')' and len(stack) &gt; 1 and s[stack[-1]] == '(':\n                stack.pop()\n                result = max(result, i - stack[-1])\n            else:\n                stack.append(i)\n        return result\n</code>",
        "runtime" : "66ms, 97.70%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Longest Valid Parentheses"
  }, {
    "Description" : "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n\n(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\n\nYou are given a target value to search. If found in the array return its index, otherwise return -1.\n\nYou may assume no duplicate exists in the array.\n\n",
    "Difficulty" : "Medium",
    "Number" : "33",
    "Solutions" : {
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left &lt; right:\n            mid = left + (right - left) / 2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] &lt; nums[right]:\n                if nums[mid] &lt;= target &lt;= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid\n            else:\n                if nums[left] &lt;= target &lt;= nums[mid]:\n                    right = mid\n                else:\n                    left = mid + 1\n        return left if nums[left] == target else -1\n</code>",
        "runtime" : "35ms, 99.82%"
      }, {
        "code" : "<code>\nclass Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums)-1\n        while left &lt;= right:\n            mid = left + (right - left) / 2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] &lt; nums[right]:\n                if nums[mid] &lt; target &lt;= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid\n            else:\n                if nums[left] &lt;= target &lt; nums[mid]:\n                    right = mid\n                else:\n                    left = mid + 1\n        return -1\n</code>",
        "runtime" : "35ms, 99.82%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Search in Rotated Sorted Array"
  }, {
    "Description" : "Given an array of integers sorted in ascending order, find the starting and \nending position of a given target value.\n\nYour algorithm's runtime complexity must be in the order of O(log n).\n\nIf the target is not found in the array, return [-1, -1].\n\nFor example,\nGiven [5, 7, 7, 8, 8, 10] and target value 8,\nreturn [3, 4].",
    "Difficulty" : "Medium",
    "Number" : "34",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\npublic class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int[] result = new int[]{-1,-1};\n        if (nums == null || nums.length == 0) {\n            return result;\n        }\n        int left = searchLeft(nums, target);\n        int right = searchRight(nums, target);\n        result[0] = left;\n        result[1] = right;\n        return result;\n    }\n    \n    private int searchLeft(int[] nums, int target) {\n        if (nums == null || nums.length == 0) {\n            return -1;\n        }\n        int left = 0, right = nums.length - 1;\n        while (left &lt; right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] &gt;= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        if (nums[left] == target) {\n            return left;\n        }\n        return -1;\n    }\n    \n    private int searchRight(int[] nums, int target) {\n        if (nums == null || nums.length == 0) {\n            return -1;\n        }\n        int left = 0, right = nums.length - 1;\n        while (left &lt; right) {\n            int mid = left + (right - left + 1) / 2;\n            if (nums[mid] &lt;= target) {\n                left = mid;\n            } else {\n                right = mid - 1;\n            }\n        }\n        if (nums[right] == target) {\n            return right;\n        }\n        return -1;\n    }\n}\n</code>",
        "runtime" : "0ms, 100%"
      } ],
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        left = bisect.bisect_left(nums, target)\n        right = bisect.bisect_right(nums, target)\n        if left &gt;= len(nums) or nums[left] != target:\n            return [-1, -1]\n        return [left, right-1]\n</code>",
        "runtime" : "55ms, 32.73%"
      }, {
        "code" : "<code>\nclass Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums:\n            return [-1, -1]\n        left = self.findLeft(nums, target)\n        right = self.findRight(nums, target)\n        return [left, right]\n    \n    def findLeft(self, nums, target):\n        left, right = 0, len(nums)-1\n        while left &lt; right:\n            mid = left + (right - left) / 2\n            if nums[mid] &gt;= target:\n                right = mid\n            else:\n                left = mid + 1\n        return right if nums[right] == target else -1\n    \n    def findRight(self, nums, target):\n        left, right = 0, len(nums)-1\n        while left &lt; right:\n            mid = left + (right - left + 1) / 2 \n            if nums[mid] &lt;= target:\n                left = mid\n            else:\n                right = mid - 1\n        return left if nums[left] == target else -1\n</code>",
        "runtime" : "45ms, 74.33%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Search for a Range"
  }, {
    "Description" : "Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou may assume no duplicates in the array.\n\nHere are few examples.\n[1,3,5,6], 5 → 2\n[1,3,5,6], 2 → 1\n[1,3,5,6], 7 → 4\n[1,3,5,6], 0 → 0",
    "Difficulty" : "Easy",
    "Number" : "35",
    "Solutions" : {
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums)-1\n        while left &lt; right:\n            mid = left + (right - left) / 2\n            if nums[mid] &gt;= target:\n                right = mid\n            else:\n                left = mid + 1\n        return right if target &lt;= nums[-1] else len(nums)\n</code>",
        "runtime" : "64ms, 9.30%"
      }, {
        "code" : "<code>\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums)\n        while left &lt; right:\n            mid = left + (right - left) / 2\n            if nums[mid] &gt;= target:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n</code>",
        "runtime" : "39ms, 84.41%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Search Insert Position"
  }, {
    "Description" : "Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.\n\nThe Sudoku board could be partially filled, where empty cells are filled\n with the character '.'.\n<br>\n<img src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png\" />\n\nA partially filled sudoku which is valid.\n\nNote:\nA valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.",
    "Difficulty" : "Medium",
    "Number" : "36",
    "Solutions" : {
      "Java" : [ {
        "code" : "<code>\npublic class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        if (board == null || board.length == 0) {\n            return false;\n        }\n        for (int i = 0; i &lt; board.length; i++) {\n            for (int j = 0; j &lt; board[0].length; j++) {\n                if (board[i][j] != '.' && !check(board, i, j)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    private boolean check(char[][] board, int x, int y) {\n        for (int i = 0; i &lt; board.length; i++) {\n            if ((board[i][y] == board[x][y] && x != i) \n                || (board[x][i] == board[x][y] && y != i)) {\n                    return false;\n                }\n        }\n        \n        for (int i = 0; i &lt; 3; i++) {\n            for (int j = 0; j &lt; 3; j++) {\n                int row = x / 3 * 3 + i;\n                int col = y / 3 * 3 + j;\n                if (board[x][y] == board[row][col] && x != row && y != col) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n</code>",
        "runtime" : "3ms, 100%"
      } ],
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        for i in xrange(9):\n            for j in xrange(9):\n                if board[i][j] != '.' and not self.check(board, i, j):\n                    return False\n        return True\n        \n    def check(self, board, x, y):\n        for i in xrange(9):\n            if board[x][y] == board[i][y] and x != i or \\\n                board[x][y] == board[x][i] and y != i:\n                    return False\n        for i in xrange(3):\n            for j in xrange(3):\n                r, c = x / 3 * 3 + i, y / 3 * 3 + j\n                if board[x][y] == board[r][c] and x != r and y != c:\n                        return False\n        return True\n</code>",
        "runtime" : "92ms, 42.61%"
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Valid Sudoku"
  }, {
    "Description" : "Write a program to solve a Sudoku puzzle by filling the empty cells.\n\nEmpty cells are indicated by the character '.'.\n\nYou may assume that there will be only one unique solution.\n<img src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png\" />\nA sudoku puzzle...\n<img src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png\" />\n...and its solution numbers marked in red.",
    "Difficulty" : "Hard",
    "Number" : "37",
    "Source" : "LeetCode",
    "Title" : "Sudoku Solver"
  }, {
    "Description" : "The count-and-say sequence is the sequence of integers beginning as follows:\n1, 11, 21, 1211, 111221, ...\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\nGiven an integer n, generate the nth sequence.\n\nNote: The sequence of integers will be represented as a string.",
    "Difficulty" : "Easy",
    "Number" : "38",
    "Source" : "LeetCode",
    "Title" : "Count and Say"
  }, {
    "Description" : "Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\n\nThe same repeated number may be chosen from C unlimited number of times.\n\nNote:\nAll numbers (including target) will be positive integers.\nThe solution set must not contain duplicate combinations.\nFor example, given candidate set [2, 3, 6, 7] and target 7, \nA solution set is: \n[\n  [7],\n  [2, 2, 3]\n]",
    "Difficulty" : "Medium",
    "Number" : "39",
    "Source" : "LeetCode",
    "Title" : "Combination Sum"
  }, {
    "Description" : "Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\n\nEach number in C may only be used once in the combination.\n\nNote:\nAll numbers (including target) will be positive integers.\nThe solution set must not contain duplicate combinations.\nFor example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, \nA solution set is: \n[\n  [1, 7],\n  [1, 2, 5],\n  [2, 6],\n  [1, 1, 6]\n]",
    "Difficulty" : "Medium",
    "Number" : "40",
    "Source" : "LeetCode",
    "Title" : "Combination Sum II"
  }, {
    "Description" : "Given an unsorted integer array, find the first missing positive integer.\n\nFor example,\nGiven [1,2,0] return 3,\nand [3,4,-1,1] return 2.\n\nYour algorithm should run in O(n) time and uses constant space.",
    "Difficulty" : "Hard",
    "Number" : "41",
    "Source" : "LeetCode",
    "Title" : "First Missing Positive"
  }, {
    "Description" : "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\n\nFor example, \nGiven [0,1,0,2,1,0,1,3,2,1,2,1], return 6.\n<img src=\"http://www.leetcode.com/wp-content/uploads/2012/08/rainwatertrap.png\" />\n\nThe above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!",
    "Difficulty" : "Hard",
    "Number" : "42",
    "Source" : "LeetCode",
    "Title" : "Trapping Rain Water"
  }, {
    "Description" : "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2.\n\nNote:\n\nThe length of both num1 and num2 is < 110.\nBoth num1 and num2 contains only digits 0-9.\nBoth num1 and num2 does not contain any leading zero.\nYou must not use any built-in BigInteger library or convert the inputs to integer directly.",
    "Difficulty" : "Medium",
    "Number" : "43",
    "Source" : "LeetCode",
    "Title" : "Multiply Strings"
  }, {
    "Description" : "Implement wildcard pattern matching with support for '?' and '*'.\n\n'?' Matches any single character.\n'*' Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the entire input string (not partial).\n\nThe function prototype should be:\nbool isMatch(const char *s, const char *p)\n\nSome examples:\nisMatch(\"aa\",\"a\") → false\nisMatch(\"aa\",\"aa\") → true\nisMatch(\"aaa\",\"aa\") → false\nisMatch(\"aa\", \"*\") → true\nisMatch(\"aa\", \"a*\") → true\nisMatch(\"ab\", \"?*\") → true\nisMatch(\"aab\", \"c*a*b\") → false",
    "Difficulty" : "Hard",
    "Number" : "44",
    "Source" : "LeetCode",
    "Title" : "Wildcard Matching"
  }, {
    "Description" : "Given an array of non-negative integers, you are initially positioned at the first index of the array.\n\nEach element in the array represents your maximum jump length at that position.\n\nYour goal is to reach the last index in the minimum number of jumps.\n\nFor example:\nGiven array A = [2,3,1,1,4]\n\nThe minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)\n\nNote:\nYou can assume that you can always reach the last index.",
    "Difficulty" : "Hard",
    "Number" : "45",
    "Source" : "LeetCode",
    "Title" : "Jump Game II"
  }, {
    "Description" : "Given a collection of distinct numbers, return all possible permutations.\n\nFor example,\n[1,2,3] have the following permutations:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]",
    "Difficulty" : "Medium",
    "Number" : "46",
    "Source" : "LeetCode",
    "Title" : "Permutations"
  }, {
    "Description" : "Given a collection of numbers that might contain duplicates, return all possible unique permutations.\n\nFor example,\n[1,1,2] have the following unique permutations:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]",
    "Difficulty" : "Medium",
    "Number" : "47",
    "Source" : "LeetCode",
    "Title" : "Permutations II"
  }, {
    "Description" : "You are given an n x n 2D matrix representing an image.\n\nRotate the image by 90 degrees (clockwise).\n\nFollow up:\nCould you do this in-place?",
    "Difficulty" : "Medium",
    "Number" : "48",
    "Source" : "LeetCode",
    "Title" : "Rotate Image"
  }, {
    "Description" : "Given an array of strings, group anagrams together.\n\nFor example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], \nReturn:\n\n[\n  [\"ate\", \"eat\",\"tea\"],\n  [\"nat\",\"tan\"],\n  [\"bat\"]\n]\nNote: All inputs will be in lower-case.",
    "Difficulty" : "Medium",
    "Number" : "49",
    "Source" : "LeetCode",
    "Title" : "Group Anagrams"
  }, {
    "Description" : "Implement pow(x, n).",
    "Difficulty" : "Medium",
    "Number" : "50",
    "Source" : "LeetCode",
    "Title" : "Pow(x, n)"
  }, {
    "Description" : "The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.\n\n<img src=\"http://www.leetcode.com/wp-content/uploads/2012/03/8-queens.png\" />\n\nGiven an integer n, return all distinct solutions to the n-queens puzzle.\n\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.\n\nFor example,\nThere exist two distinct solutions to the 4-queens puzzle:\n\n[\n [\".Q..\",  // Solution 1\n  \"...Q\",\n  \"Q...\",\n  \"..Q.\"],\n\n [\"..Q.\",  // Solution 2\n  \"Q...\",\n  \"...Q\",\n  \".Q..\"]\n]",
    "Difficulty" : "Hard",
    "Number" : "51",
    "Source" : "LeetCode",
    "Title" : "N-Queens"
  }, {
    "Description" : "Follow up for N-Queens problem.\n\nNow, instead outputting board configurations, return the total number of distinct solutions.",
    "Difficulty" : "Hard",
    "Number" : "52",
    "Source" : "LeetCode",
    "Title" : "N-Queens II"
  }, {
    "Description" : "Find the contiguous subarray within an array (containing at least one number) which has the largest sum.\n\nFor example, given the array [-2,1,-3,4,-1,2,1,-5,4],\nthe contiguous subarray [4,-1,2,1] has the largest sum = 6.\n\nclick to show more practice.\n\nMore practice:\nIf you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.",
    "Difficulty" : "Easy",
    "Number" : "53",
    "Source" : "LeetCode",
    "Title" : "Maximum Subarray"
  }, {
    "Description" : "Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\n\nFor example,\nGiven the following matrix:\n\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\nYou should return [1,2,3,6,9,8,7,4,5].\n\n",
    "Difficulty" : "Medium",
    "Number" : "54",
    "Source" : "LeetCode",
    "Title" : "Spiral Matrix"
  }, {
    "Description" : "Given an array of non-negative integers, you are initially positioned at the first index of the array.\n\nEach element in the array represents your maximum jump length at that position.\n\nDetermine if you are able to reach the last index.\n\nFor example:\nA = [2,3,1,1,4], return true.\n\nA = [3,2,1,0,4], return false.",
    "Difficulty" : "Medium",
    "Number" : "55",
    "Source" : "LeetCode",
    "Title" : "Jump Game"
  }, {
    "Description" : "Given a collection of intervals, merge all overlapping intervals.\n\nFor example,\nGiven [1,3],[2,6],[8,10],[15,18],\nreturn [1,6],[8,10],[15,18].",
    "Difficulty" : "Medium",
    "Number" : "56",
    "Source" : "LeetCode",
    "Title" : "Merge Intervals"
  }, {
    "Description" : "Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\n\nYou may assume that the intervals were initially sorted according to their start times.\n\nExample 1:\nGiven intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].\n\nExample 2:\nGiven [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].\n\nThis is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].",
    "Difficulty" : "Hard",
    "Number" : "57",
    "Source" : "LeetCode",
    "Title" : "Insert Interval"
  }, {
    "Description" : "Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.\n\nIf the last word does not exist, return 0.\n\nNote: A word is defined as a character sequence consists of non-space characters only.\n\nFor example, \nGiven s = \"Hello World\",\nreturn 5.\n\n",
    "Difficulty" : "Easy",
    "Number" : "58",
    "Source" : "LeetCode",
    "Title" : "Length of Last Word"
  }, {
    "Description" : "Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.\n\nFor example,\nGiven n = 3,\n\nYou should return the following matrix:\n[\n [ 1, 2, 3 ],\n [ 8, 9, 4 ],\n [ 7, 6, 5 ]\n]",
    "Difficulty" : "Medium",
    "Number" : "59",
    "Source" : "LeetCode",
    "Title" : "Spiral Matrix II"
  }, {
    "Description" : "The set [1,2,3,…,n] contains a total of n! unique permutations.\n\nBy listing and labeling all of the permutations in order,\nWe get the following sequence (ie, for n = 3):\n\n\"123\"\n\"132\"\n\"213\"\n\"231\"\n\"312\"\n\"321\"\nGiven n and k, return the kth permutation sequence.\n\nNote: Given n will be between 1 and 9 inclusive.",
    "Difficulty" : "Medium",
    "Number" : "60",
    "Source" : "LeetCode",
    "Title" : "Permutation Sequence"
  }, {
    "Description" : "Given a list, rotate the list to the right by k places, where k is non-negative.\n\nFor example:\nGiven 1->2->3->4->5->NULL and k = 2,\nreturn 4->5->1->2->3->NULL.",
    "Difficulty" : "Medium",
    "Number" : "61",
    "Source" : "LeetCode",
    "Title" : "Rotate List"
  }, {
    "Description" : "A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\n\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\n\nHow many possible unique paths are there?\n\n\nAbove is a 3 x 7 grid. How many possible unique paths are there?\n\nNote: m and n will be at most 100.",
    "Difficulty" : "Medium",
    "Number" : "62",
    "Source" : "LeetCode",
    "Title" : "Unique Paths"
  }, {
    "Description" : "Follow up for \"Unique Paths\":\n\nNow consider if some obstacles are added to the grids. How many unique paths would there be?\n\nAn obstacle and empty space is marked as 1 and 0 respectively in the grid.\n\nFor example,\nThere is one obstacle in the middle of a 3x3 grid as illustrated below.\n\n[\n  [0,0,0],\n  [0,1,0],\n  [0,0,0]\n]\nThe total number of unique paths is 2.\n\nNote: m and n will be at most 100.",
    "Difficulty" : "Medium",
    "Number" : "63",
    "Source" : "LeetCode",
    "Title" : "Unique Paths II"
  }, {
    "Description" : "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\n\nNote: You can only move either down or right at any point in time.",
    "Difficulty" : "Medium",
    "Number" : "64",
    "Source" : "LeetCode",
    "Title" : "Minimum Path Sum"
  }, {
    "Description" : "Validate if a given string is numeric.\n\nSome examples:\n\"0\" => true\n\" 0.1 \" => true\n\"abc\" => false\n\"1 a\" => false\n\"2e10\" => true\nNote: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.",
    "Difficulty" : "Hard",
    "Number" : "65",
    "Source" : "LeetCode",
    "Title" : "Valid Number"
  }, {
    "Description" : "Given a non-negative integer represented as a non-empty array of digits, plus one to the integer.\n\nYou may assume the integer do not contain any leading zero, except the number 0 itself.\n\nThe digits are stored such that the most significant digit is at the head of the list.",
    "Difficulty" : "Easy",
    "Number" : "66",
    "Source" : "LeetCode",
    "Title" : "Plus One"
  }, {
    "Description" : "Given two binary strings, return their sum (also a binary string).\n\nFor example,\na = \"11\"\nb = \"1\"\nReturn \"100\".",
    "Difficulty" : "Easy",
    "Number" : "67",
    "Source" : "LeetCode",
    "Title" : "Add Binary"
  }, {
    "Description" : "Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.\n\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly L characters.\n\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text, it should be left justified and no extra space is inserted between words.\n\nFor example,\nwords: [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\nL: 16.\n\nReturn the formatted lines as:\n[\n   \"This    is    an\",\n   \"example  of text\",\n   \"justification.  \"\n]\nNote: Each word is guaranteed not to exceed L in length.",
    "Difficulty" : "Hard",
    "Number" : "68",
    "Source" : "LeetCode",
    "Title" : "Text Justification"
  }, {
    "Description" : "Implement int sqrt(int x).\n\nCompute and return the square root of x.",
    "Difficulty" : "Easy",
    "Number" : "69",
    "Source" : "LeetCode",
    "Title" : "Sqrt(x)"
  }, {
    "Description" : "You are climbing a stair case. It takes n steps to reach to the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\nNote: Given n will be a positive integer.",
    "Difficulty" : "Easy",
    "Number" : "70",
    "Source" : "LeetCode",
    "Title" : "Climbing Stairs"
  }, {
    "Description" : "Given an absolute path for a file (Unix-style), simplify it.\n\nFor example,\npath = \"/home/\", => \"/home\"\npath = \"/a/./b/../../c/\", => \"/c\"\n\n\nCorner Cases:\nDid you consider the case where path = \"/../\"?\nIn this case, you should return \"/\".\nAnother corner case is the path might contain multiple slashes '/' together, such as \"/home//foo/\".\nIn this case, you should ignore redundant slashes and return \"/home/foo\".",
    "Difficulty" : "Medium",
    "Number" : "71",
    "Source" : "LeetCode",
    "Title" : "Simplify Path"
  }, {
    "Description" : "Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)\n\nYou have the following 3 operations permitted on a word:\n\na) Insert a character\nb) Delete a character\nc) Replace a character",
    "Difficulty" : "Hard",
    "Number" : "72",
    "Source" : "LeetCode",
    "Title" : "Edit Distance"
  }, {
    "Description" : "Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.\n\nFollow up:\nDid you use extra space?\nA straight forward solution using O(mn) space is probably a bad idea.\nA simple improvement uses O(m + n) space, but still not the best solution.\nCould you devise a constant space solution?",
    "Difficulty" : "Medium",
    "Number" : "73",
    "Source" : "LeetCode",
    "Title" : "Set Matrix Zeroes"
  }, {
    "Description" : "Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\n\nIntegers in each row are sorted from left to right.\nThe first integer of each row is greater than the last integer of the previous row.\nFor example,\n\nConsider the following matrix:\n\n[\n  [1,   3,  5,  7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n]\nGiven target = 3, return true.",
    "Difficulty" : "Medium",
    "Number" : "74",
    "Source" : "LeetCode",
    "Title" : "Search a 2D Matrix"
  }, {
    "Description" : "Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.\n\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\n\nNote:\nYou are not suppose to use the library's sort function for this problem.\n\nFollow up:\nA rather straight forward solution is a two-pass algorithm using counting sort.\nFirst, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.\n\nCould you come up with an one-pass algorithm using only constant space?",
    "Difficulty" : "Medium",
    "Number" : "75",
    "Source" : "LeetCode",
    "Title" : "Sort Colors"
  }, {
    "Description" : "Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\n\nFor example,\nS = \"ADOBECODEBANC\"\nT = \"ABC\"\nMinimum window is \"BANC\".\n\nNote:\nIf there is no such window in S that covers all characters in T, return the empty string \"\".\n\nIf there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.",
    "Difficulty" : "Hard",
    "Number" : "76",
    "Source" : "LeetCode",
    "Title" : "Minimum Window Substring"
  }, {
    "Description" : "Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.\n\nFor example,\nIf n = 4 and k = 2, a solution is:\n\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]",
    "Difficulty" : "Medium",
    "Number" : "77",
    "Source" : "LeetCode",
    "Title" : "Combinations"
  }, {
    "Description" : "Given a set of distinct integers, nums, return all possible subsets.\n\nNote: The solution set must not contain duplicate subsets.\n\nFor example,\nIf nums = [1,2,3], a solution is:\n\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n",
    "Difficulty" : "Medium",
    "Number" : "78",
    "Source" : "LeetCode",
    "Title" : "Subsets"
  }, {
    "Description" : "Given a 2D board and a word, find if the word exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\nFor example,\nGiven board =\n\n[\n  ['A','B','C','E'],\n  ['S','F','C','S'],\n  ['A','D','E','E']\n]\nword = \"ABCCED\", -> returns true,\nword = \"SEE\", -> returns true,\nword = \"ABCB\", -> returns false.\n",
    "Difficulty" : "Medium",
    "Number" : "79",
    "Source" : "LeetCode",
    "Title" : "Word Search"
  }, {
    "Description" : "Follow up for \"Remove Duplicates\":\nWhat if duplicates are allowed at most twice?\n\nFor example,\nGiven sorted array nums = [1,1,1,2,2,3],\n\nYour function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn't matter what you leave beyond the new length.",
    "Difficulty" : "Medium",
    "Number" : "80",
    "Source" : "LeetCode",
    "Title" : "Remove Duplicates from Sorted Array II"
  }, {
    "Description" : "Follow up for \"Search in Rotated Sorted Array\":\nWhat if duplicates are allowed?\n\nWould this affect the run-time complexity? How and why?\nSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n\n(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\n\nWrite a function to determine if a given target is in the array.\n\nThe array may contain duplicates.",
    "Difficulty" : "Medium",
    "Number" : "81",
    "Source" : "LeetCode",
    "Title" : "Search in Rotated Sorted Array II"
  }, {
    "Description" : "Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.\n\nFor example,\nGiven 1->2->3->3->4->4->5, return 1->2->5.\nGiven 1->1->1->2->3, return 2->3.\n\n",
    "Difficulty" : "Medium",
    "Number" : "82",
    "Source" : "LeetCode",
    "Title" : "Remove Duplicates from Sorted List II"
  }, {
    "Description" : "Given a sorted linked list, delete all duplicates such that each element appear only once.\n\nFor example,\nGiven 1->1->2, return 1->2.\nGiven 1->1->2->3->3, return 1->2->3.",
    "Difficulty" : "Easy",
    "Number" : "83",
    "Source" : "LeetCode",
    "Title" : "Remove Duplicates from Sorted List"
  }, {
    "Description" : "Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.\n<img src=\"http://www.leetcode.com/wp-content/uploads/2012/04/histogram.png\" />\n\nAbove is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].\n\n<img src=\"http://www.leetcode.com/wp-content/uploads/2012/04/histogram_area.png\" />\nThe largest rectangle is shown in the shaded area, which has area = 10 unit.\n\nFor example,\nGiven heights = [2,1,5,6,2,3],\nreturn 10.",
    "Difficulty" : "Hard",
    "Number" : "84",
    "Source" : "LeetCode",
    "Title" : "Largest Rectangle in Histogram"
  }, {
    "Description" : "Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\n\nFor example, given the following matrix:\n\n1 0 1 0 0\n1 0 1 1 1\n1 1 1 1 1\n1 0 0 1 0\nReturn 6.",
    "Difficulty" : "Hard",
    "Number" : "85",
    "Source" : "LeetCode",
    "Title" : "Maximal Rectangle"
  }, {
    "Description" : "Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\n\nYou should preserve the original relative order of the nodes in each of the two partitions.\n\nFor example,\nGiven 1->4->3->2->5->2 and x = 3,\nreturn 1->2->2->4->3->5.",
    "Difficulty" : "Medium",
    "Number" : "86",
    "Source" : "LeetCode",
    "Title" : "Partition List"
  }, {
    "Description" : "Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.\n\nBelow is one possible representation of s1 = \"great\":\n\n    great\n   /    \\\n  gr    eat\n / \\    /  \\\ng   r  e   at\n           / \\\n          a   t\nTo scramble the string, we may choose any non-leaf node and swap its two children.\n\nFor example, if we choose the node \"gr\" and swap its two children, it produces a scrambled string \"rgeat\".\n\n    rgeat\n   /    \\\n  rg    eat\n / \\    /  \\\nr   g  e   at\n           / \\\n          a   t\nWe say that \"rgeat\" is a scrambled string of \"great\".\n\nSimilarly, if we continue to swap the children of nodes \"eat\" and \"at\", it produces a scrambled string \"rgtae\".\n\n    rgtae\n   /    \\\n  rg    tae\n / \\    /  \\\nr   g  ta  e\n       / \\\n      t   a\nWe say that \"rgtae\" is a scrambled string of \"great\".\n\nGiven two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.",
    "Difficulty" : "Hard",
    "Number" : "87",
    "Source" : "LeetCode",
    "Title" : "Scramble String"
  }, {
    "Description" : "Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.\n\nNote:\nYou may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.",
    "Difficulty" : "Easy",
    "Number" : "88",
    "Source" : "LeetCode",
    "Title" : "Merge Sorted Array"
  }, {
    "Description" : "The gray code is a binary numeral system where two successive values differ in only one bit.\n\nGiven a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.\n\nFor example, given n = 2, return [0,1,3,2]. Its gray code sequence is:\n\n00 - 0\n01 - 1\n11 - 3\n10 - 2\nNote:\nFor a given n, a gray code sequence is not uniquely defined.\n\nFor example, [0,2,3,1] is also a valid gray code sequence according to the above definition.\n\nFor now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.",
    "Difficulty" : "Medium",
    "Number" : "89",
    "Source" : "LeetCode",
    "Title" : "Gray Code"
  }, {
    "Description" : "Given a collection of integers that might contain duplicates, nums, return all possible subsets.\n\nNote: The solution set must not contain duplicate subsets.\n\nFor example,\nIf nums = [1,2,2], a solution is:\n\n[\n  [2],\n  [1],\n  [1,2,2],\n  [2,2],\n  [1,2],\n  []\n]",
    "Difficulty" : "Medium",
    "Number" : "90",
    "Source" : "LeetCode",
    "Title" : "Subsets II"
  }, {
    "Description" : "A message containing letters from A-Z is being encoded to numbers using the following mapping:\n\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\nGiven an encoded message containing digits, determine the total number of ways to decode it.\n\nFor example,\nGiven encoded message \"12\", it could be decoded as \"AB\" (1 2) or \"L\" (12).\n\nThe number of ways decoding \"12\" is 2.",
    "Difficulty" : "Medium",
    "Number" : "91",
    "Source" : "LeetCode",
    "Title" : "Decode Ways"
  }, {
    "Description" : "Reverse a linked list from position m to n. Do it in-place and in one-pass.\n\nFor example:\nGiven 1->2->3->4->5->NULL, m = 2 and n = 4,\n\nreturn 1->4->3->2->5->NULL.\n\nNote:\nGiven m, n satisfy the following condition:\n1 ≤ m ≤ n ≤ length of list.",
    "Difficulty" : "Medium",
    "Number" : "92",
    "Source" : "LeetCode",
    "Title" : "Reverse Linked List II"
  }, {
    "Description" : "Given a string containing only digits, restore it by returning all possible valid IP address combinations.\n\nFor example:\nGiven \"25525511135\",\n\nreturn [\"255.255.11.135\", \"255.255.111.35\"]. (Order does not matter)",
    "Difficulty" : "Medium",
    "Number" : "93",
    "Source" : "LeetCode",
    "Title" : "Restore IP Addresses"
  }, {
    "Description" : "Given a binary tree, return the inorder traversal of its nodes' values.\n\nFor example:\nGiven binary tree [1,null,2,3],\n   1\n    \\\n     2\n    /\n   3\nreturn [1,3,2].\n\nNote: Recursive solution is trivial, could you do it iteratively?",
    "Difficulty" : "Medium",
    "Number" : "94",
    "Source" : "LeetCode",
    "Title" : "Binary Tree Inorder Traversal"
  }, {
    "Description" : "Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1...n.\n\nFor example,\nGiven n = 3, your program should return all 5 unique BST's shown below.\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3",
    "Difficulty" : "Medium",
    "Number" : "95",
    "Source" : "LeetCode",
    "Title" : "Unique Binary Search Trees II"
  }, {
    "Description" : "Given n, how many structurally unique BST's (binary search trees) that store values 1...n?\n\nFor example,\nGiven n = 3, there are a total of 5 unique BST's.\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3",
    "Difficulty" : "Medium",
    "Number" : "96",
    "Source" : "LeetCode",
    "Title" : "Unique Binary Search Trees"
  }, {
    "Description" : "Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.\n\nFor example,\nGiven:\ns1 = \"aabcc\",\ns2 = \"dbbca\",\n\nWhen s3 = \"aadbbcbcac\", return true.\nWhen s3 = \"aadbbbaccc\", return false.",
    "Difficulty" : "Hard",
    "Number" : "97",
    "Source" : "LeetCode",
    "Title" : "Interleaving String"
  }, {
    "Description" : "Given a binary tree, determine if it is a valid binary search tree (BST).\n\nAssume a BST is defined as follows:\n\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\nExample 1:\n    2\n   / \\\n  1   3\nBinary tree [2,1,3], return true.\nExample 2:\n    1\n   / \\\n  2   3\nBinary tree [1,2,3], return false.",
    "Difficulty" : "Medium",
    "Number" : "98",
    "Source" : "LeetCode",
    "Title" : "Validate Binary Search Tree"
  }, {
    "Description" : "Two elements of a binary search tree (BST) are swapped by mistake.\n\nRecover the tree without changing its structure.\n\nNote:\nA solution using O(n) space is pretty straight forward. Could you devise a constant space solution?",
    "Difficulty" : "Hard",
    "Number" : "99",
    "Source" : "LeetCode",
    "Title" : "Recover Binary Search Tree"
  }, {
    "Description" : "Given two binary trees, write a function to check if they are equal or not.\n\nTwo binary trees are considered equal if they are structurally identical and the nodes have the same value.",
    "Difficulty" : "Easy",
    "Number" : "100",
    "Source" : "LeetCode",
    "Title" : "Same Tree"
  }, {
    "Description" : "Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\n\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\nBut the following [1,2,2,null,3,null,3] is not:\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\nNote:\nBonus points if you could solve it both recursively and iteratively.",
    "Difficulty" : "Easy",
    "Number" : "101",
    "Source" : "LeetCode",
    "Title" : "Symmetric Tree"
  }, {
    "Description" : "Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).\n\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\nreturn its zigzag level order traversal as:\n[\n  [3],\n  [20,9],\n  [15,7]\n]",
    "Difficulty" : "Medium",
    "Number" : "103",
    "Source" : "LeetCode",
    "Title" : "Binary Tree Zigzag Level Order Traversal"
  }, {
    "Description" : "Given a binary tree, find its maximum depth.\n\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "Difficulty" : "Easy",
    "Number" : "104",
    "Source" : "LeetCode",
    "Title" : "Maximum Depth of Binary Tree"
  }, {
    "Description" : "Given preorder and inorder traversal of a tree, construct the binary tree.\n\nNote:\nYou may assume that duplicates do not exist in the tree.",
    "Difficulty" : "Medium",
    "Number" : "105",
    "Source" : "LeetCode",
    "Title" : "Construct Binary Tree from Preorder and Inorder Traversal"
  }, {
    "Description" : "Given inorder and postorder traversal of a tree, construct the binary tree.\n\nNote:\nYou may assume that duplicates do not exist in the tree.",
    "Difficulty" : "Medium",
    "Number" : "106",
    "Source" : "LeetCode",
    "Title" : "Construct Binary Tree from Inorder and Postorder Traversal"
  }, {
    "Description" : "Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).\n\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\nreturn its bottom-up level order traversal as:\n[\n  [15,7],\n  [9,20],\n  [3]\n]",
    "Difficulty" : "Easy",
    "Number" : "107",
    "Source" : "LeetCode",
    "Title" : "Binary Tree Level Order Traversal II"
  }, {
    "Description" : "Given an array where elements are sorted in ascending order, convert it to a height balanced BST.",
    "Difficulty" : "Easy",
    "Number" : "108",
    "Source" : "LeetCode",
    "Title" : "Convert Sorted Array to Binary Search Tree"
  }, {
    "Description" : "Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.",
    "Difficulty" : "Medium",
    "Number" : "109",
    "Source" : "LeetCode",
    "Title" : "Convert Sorted List to Binary Search Tree"
  }, {
    "Description" : "Given a binary tree, determine if it is height-balanced.\n\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.",
    "Difficulty" : "Easy",
    "Number" : "110",
    "Source" : "LeetCode",
    "Title" : "Balanced Binary Tree"
  }, {
    "Description" : "Given a binary tree, find its minimum depth.\n\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.",
    "Difficulty" : "Easy",
    "Number" : "111",
    "Source" : "LeetCode",
    "Title" : "Minimum Depth of Binary Tree"
  }, {
    "Description" : "Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\n\nFor example:\nGiven the below binary tree and sum = 22,\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\      \\\n        7    2      1\nreturn true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.",
    "Difficulty" : "Easy",
    "Number" : "112",
    "Source" : "LeetCode",
    "Title" : "Path Sum"
  }, {
    "Description" : "Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.\n\nFor example:\nGiven the below binary tree and sum = 22,\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\    / \\\n        7    2  5   1\nreturn\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]",
    "Difficulty" : "Medium",
    "Number" : "113",
    "Source" : "LeetCode",
    "Title" : "Path Sum II"
  }, {
    "Description" : "Given a binary tree, flatten it to a linked list in-place.\n\nFor example,\nGiven\n\n         1\n        / \\\n       2   5\n      / \\   \\\n     3   4   6\nThe flattened tree should look like:\n   1\n    \\\n     2\n      \\\n       3\n        \\\n         4\n          \\\n           5\n            \\\n             6\n\nHints:\nIf you notice carefully in the flattened tree, each node's right child points to the next node of a pre-order traversal.",
    "Difficulty" : "Medium",
    "Number" : "114",
    "Source" : "LeetCode",
    "Title" : "Flatten Binary Tree to Linked List"
  }, {
    "Description" : "Given a string S and a string T, count the number of distinct subsequences of T in S.\n\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ACE\" is a subsequence of \"ABCDE\" while \"AEC\" is not).\n\nHere is an example:\nS = \"rabbbit\", T = \"rabbit\"\n\nReturn 3.",
    "Difficulty" : "Hard",
    "Number" : "115",
    "Source" : "LeetCode",
    "Title" : "Distinct Subsequences"
  }, {
    "Description" : "Given a binary tree\n\n    struct TreeLinkNode {\n      TreeLinkNode *left;\n      TreeLinkNode *right;\n      TreeLinkNode *next;\n    }\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\n\nInitially, all next pointers are set to NULL.\n\nNote:\n\nYou may only use constant extra space.\nYou may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).\nFor example,\nGiven the following perfect binary tree,\n         1\n       /  \\\n      2    3\n     / \\  / \\\n    4  5  6  7\nAfter calling your function, the tree should look like:\n         1 -> NULL\n       /  \\\n      2 -> 3 -> NULL\n     / \\  / \\\n    4->5->6->7 -> NULL",
    "Difficulty" : "Medium",
    "Number" : "116",
    "Source" : "LeetCode",
    "Title" : "Populating Next Right Pointers in Each Node"
  }, {
    "Description" : "Follow up for problem \"Populating Next Right Pointers in Each Node\".\n\nWhat if the given tree could be any binary tree? Would your previous solution still work?\n\nNote:\n\nYou may only use constant extra space.\nFor example,\nGiven the following binary tree,\n         1\n       /  \\\n      2    3\n     / \\    \\\n    4   5    7\nAfter calling your function, the tree should look like:\n         1 -> NULL\n       /  \\\n      2 -> 3 -> NULL\n     / \\    \\\n    4-> 5 -> 7 -> NULL",
    "Difficulty" : "Medium",
    "Number" : "117",
    "Source" : "LeetCode",
    "Title" : "Populating Next Right Pointers in Each Node II"
  }, {
    "Description" : "Given numRows, generate the first numRows of Pascal's triangle.\n\nFor example, given numRows = 5,\nReturn\n\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]",
    "Difficulty" : "Easy",
    "Number" : "118",
    "Source" : "LeetCode",
    "Title" : "Pascal's Triangle"
  }, {
    "Description" : "Given an index k, return the kth row of the Pascal's triangle.\n\nFor example, given k = 3,\nReturn [1,3,3,1].\n\nNote:\nCould you optimize your algorithm to use only O(k) extra space?",
    "Difficulty" : "Easy",
    "Number" : "119",
    "Source" : "LeetCode",
    "Title" : "Pascal's Triangle II"
  }, {
    "Description" : "Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.\n\nFor example, given the following triangle\n[\n     [2],\n    [3,4],\n   [6,5,7],\n  [4,1,8,3]\n]\nThe minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).\n\nNote:\nBonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.",
    "Difficulty" : "Medium",
    "Number" : "120",
    "Source" : "LeetCode",
    "Title" : "Triangle"
  }, {
    "Description" : "Say you have an array for which the ith element is the price of a given stock on day i.\n\nIf you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.\n\nExample 1:\nInput: [7, 1, 5, 3, 6, 4]\nOutput: 5\n\nmax. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)\nExample 2:\nInput: [7, 6, 4, 3, 1]\nOutput: 0\n\nIn this case, no transaction is done, i.e. max profit = 0.",
    "Difficulty" : "Easy",
    "Number" : "121",
    "Source" : "LeetCode",
    "Title" : "Best Time to Buy and Sell Stock"
  }, {
    "Description" : "Say you have an array for which the ith element is the price of a given stock on day i.\n\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\n\n",
    "Difficulty" : "Easy",
    "Number" : "122",
    "Source" : "LeetCode",
    "Title" : "Best Time to Buy and Sell Stock II"
  }, {
    "Description" : "Total Accepted: 77046\nTotal Submissions: 271208\nDifficulty: Hard\nContributors: Admin\nSay you have an array for which the ith element is the price of a given stock on day i.\n\nDesign an algorithm to find the maximum profit. You may complete at most two transactions.\n\nNote:\nYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).",
    "Difficulty" : "Hard",
    "Number" : "123",
    "Source" : "LeetCode",
    "Title" : "Best Time to Buy and Sell Stock III"
  }, {
    "Description" : "Given a binary tree, find the maximum path sum.\n\nFor this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.\n\nFor example:\nGiven the below binary tree,\n\n       1\n      / \\\n     2   3\nReturn 6.",
    "Difficulty" : "Hard",
    "Number" : "124",
    "Source" : "LeetCode",
    "Title" : "Binary Tree Maximum Path Sum"
  }, {
    "Description" : "Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\n\nFor example,\n\"A man, a plan, a canal: Panama\" is a palindrome.\n\"race a car\" is not a palindrome.\n\nNote:\nHave you consider that the string might be empty? This is a good question to ask during an interview.\n\nFor the purpose of this problem, we define empty string as valid palindrome.",
    "Difficulty" : "Easy",
    "Number" : "125",
    "Source" : "LeetCode",
    "Title" : "Valid Palindrome"
  }, {
    "Description" : "Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:\n\nOnly one letter can be changed at a time\nEach transformed word must exist in the word list. Note that beginWord is not a transformed word.\nFor example,\n\nGiven:\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nReturn\n  [\n    [\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],\n    [\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]\n  ]\nNote:\nReturn an empty list if there is no such transformation sequence.\nAll words have the same length.\nAll words contain only lowercase alphabetic characters.\nYou may assume no duplicates in the word list.\nYou may assume beginWord and endWord are non-empty and are not the same.\nUPDATE (2017/1/20):\nThe wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.",
    "Difficulty" : "Hard",
    "Number" : "126",
    "Source" : "LeetCode",
    "Title" : "Word Ladder II"
  }, {
    "Description" : "Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:\n\nOnly one letter can be changed at a time.\nEach transformed word must exist in the word list. Note that beginWord is not a transformed word.\nFor example,\n\nGiven:\nbeginWord = \"hit\"\nendWord = \"cog\"\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nAs one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\nreturn its length 5.\n\nNote:\nReturn 0 if there is no such transformation sequence.\nAll words have the same length.\nAll words contain only lowercase alphabetic characters.\nYou may assume no duplicates in the word list.\nYou may assume beginWord and endWord are non-empty and are not the same.\nUPDATE (2017/1/20):\nThe wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.",
    "Difficulty" : "Medium",
    "Number" : "127",
    "Source" : "LeetCode",
    "Title" : "Word Ladder"
  }, {
    "Description" : "Given an unsorted array of integers, find the length of the longest consecutive elements sequence.\n\nFor example,\nGiven [100, 4, 200, 1, 3, 2],\nThe longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.\n\nYour algorithm should run in O(n) complexity.",
    "Difficulty" : "Hard",
    "Number" : "128",
    "Source" : "LeetCode",
    "Title" : "Longest Consecutive Sequence"
  }, {
    "Description" : "Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.\n\nAn example is the root-to-leaf path 1->2->3 which represents the number 123.\n\nFind the total sum of all root-to-leaf numbers.\n\nFor example,\n\n    1\n   / \\\n  2   3\nThe root-to-leaf path 1->2 represents the number 12.\nThe root-to-leaf path 1->3 represents the number 13.\n\nReturn the sum = 12 + 13 = 25.",
    "Difficulty" : "Medium",
    "Number" : "129",
    "Source" : "LeetCode",
    "Title" : "Sum Root to Leaf Numbers"
  }, {
    "Description" : "Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.\n\nA region is captured by flipping all 'O's into 'X's in that surrounded region.\n\nFor example,\nX X X X\nX O O X\nX X O X\nX O X X\nAfter running your function, the board should be:\n\nX X X X\nX X X X\nX X X X\nX O X X",
    "Difficulty" : "Medium",
    "Number" : "130",
    "Source" : "LeetCode",
    "Title" : "Surrounded Regions"
  }, {
    "Description" : "Given a string s, partition s such that every substring of the partition is a palindrome.\n\nReturn all possible palindrome partitioning of s.\n\nFor example, given s = \"aab\",\nReturn\n\n[\n  [\"aa\",\"b\"],\n  [\"a\",\"a\",\"b\"]\n]",
    "Difficulty" : "Medium",
    "Number" : "131",
    "Source" : "LeetCode",
    "Title" : "Palindrome Partitioning"
  }, {
    "Description" : "Given a string s, partition s such that every substring of the partition is a palindrome.\n\nReturn the minimum cuts needed for a palindrome partitioning of s.\n\nFor example, given s = \"aab\",\nReturn 1 since the palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.\n\n",
    "Difficulty" : "Hard",
    "Number" : "132",
    "Source" : "LeetCode",
    "Title" : "Palindrome Partitioning II"
  }, {
    "Description" : "Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.\n\n\nOJ's undirected graph serialization:\nNodes are labeled uniquely.\n\nWe use # as a separator for each node, and , as a separator for node label and each neighbor of the node.\nAs an example, consider the serialized graph {0,1,2#1,2#2,2}.\n\nThe graph has a total of three nodes, and therefore contains three parts as separated by #.\n\nFirst node is labeled as 0. Connect node 0 to both nodes 1 and 2.\nSecond node is labeled as 1. Connect node 1 to node 2.\nThird node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.\nVisually, the graph looks like the following:\n\n       1\n      / \\\n     /   \\\n    0 --- 2\n         / \\\n         \\_/",
    "Difficulty" : "Medium",
    "Number" : "133",
    "Source" : "LeetCode",
    "Title" : "Clone Graph"
  }, {
    "Description" : "There are N gas stations along a circular route, where the amount of gas at station i is gas[i].\n\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.\n\nReturn the starting gas station's index if you can travel around the circuit once, otherwise return -1.\n\nNote:\nThe solution is guaranteed to be unique.",
    "Difficulty" : "Medium",
    "Number" : "134",
    "Source" : "LeetCode",
    "Title" : "Gas Station"
  }, {
    "Description" : "There are N children standing in a line. Each child is assigned a rating value.\n\nYou are giving candies to these children subjected to the following requirements:\n\nEach child must have at least one candy.\nChildren with a higher rating get more candies than their neighbors.\nWhat is the minimum candies you must give?",
    "Difficulty" : "Hard",
    "Number" : "135",
    "Source" : "LeetCode",
    "Title" : "Candy"
  }, {
    "Description" : "Given an array of integers, every element appears twice except for one. Find that single one.\n\nNote:\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?",
    "Difficulty" : "Easy",
    "Number" : "136",
    "Source" : "LeetCode",
    "Title" : "Single Number"
  }, {
    "Description" : "Given an array of integers, every element appears three times except for one, which appears exactly once. Find that single one.\n\nNote:\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?",
    "Difficulty" : "Medium",
    "Number" : "132",
    "Source" : "LeetCode",
    "Title" : "Single Number II"
  }, {
    "Description" : "A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.\n\nReturn a deep copy of the list.",
    "Difficulty" : "Medium",
    "Number" : "138",
    "Source" : "LeetCode",
    "Title" : "Copy List with Random Pointer"
  }, {
    "Description" : "Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.\n\nFor example, given\ns = \"leetcode\",\ndict = [\"leet\", \"code\"].\n\nReturn true because \"leetcode\" can be segmented as \"leet code\".\n\nUPDATE (2017/1/4):\nThe wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.",
    "Difficulty" : "Medium",
    "Number" : "139",
    "Source" : "LeetCode",
    "Title" : "Word Break"
  }, {
    "Description" : "Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. You may assume the dictionary does not contain duplicate words.\n\nReturn all such possible sentences.\n\nFor example, given\ns = \"catsanddog\",\ndict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"].\n\nA solution is [\"cats and dog\", \"cat sand dog\"].\n\nUPDATE (2017/1/4):\nThe wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.",
    "Difficulty" : "Hard",
    "Number" : "140",
    "Source" : "LeetCode",
    "Title" : "Word Break II"
  }, {
    "Description" : "Given a linked list, determine if it has a cycle in it.\n\nFollow up:\nCan you solve it without using extra space?",
    "Difficulty" : "Easy",
    "Number" : "141",
    "Source" : "LeetCode",
    "Title" : "Linked List Cycle"
  }, {
    "Description" : "Given a linked list, return the node where the cycle begins. If there is no cycle, return null.\n\nNote: Do not modify the linked list.\n\nFollow up:\nCan you solve it without using extra space?",
    "Difficulty" : "Medium",
    "Number" : "142",
    "Source" : "LeetCode",
    "Title" : "Linked List Cycle II"
  }, {
    "Description" : "Given a singly linked list L: L0→L1→…→Ln-1→Ln,\nreorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…\n\nYou must do this in-place without altering the nodes' values.\n\nFor example,\nGiven {1,2,3,4}, reorder it to {1,4,2,3}.",
    "Difficulty" : "Medium",
    "Number" : "143",
    "Source" : "LeetCode",
    "Title" : "Reorder List"
  }, {
    "Description" : "Given a binary tree, return the preorder traversal of its nodes' values.\n\nFor example:\nGiven binary tree {1,#,2,3},\n   1\n    \\\n     2\n    /\n   3\nreturn [1,2,3].\n\nNote: Recursive solution is trivial, could you do it iteratively?",
    "Difficulty" : "Medium",
    "Number" : "144",
    "Source" : "LeetCode",
    "Title" : "Binary Tree Preorder Traversal"
  }, {
    "Description" : "Given a binary tree, return the postorder traversal of its nodes' values.\n\nFor example:\nGiven binary tree {1,#,2,3},\n   1\n    \\\n     2\n    /\n   3\nreturn [3,2,1].\n\nNote: Recursive solution is trivial, could you do it iteratively?",
    "Difficulty" : "Hard",
    "Number" : "145",
    "Source" : "LeetCode",
    "Title" : "Binary Tree Postorder Traversal"
  }, {
    "Description" : "Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.\n\nget(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\nput(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\n\nFollow up:\nCould you do both operations in O(1) time complexity?\n\nExample:\n\nLRUCache cache = new LRUCache( 2 /* capacity */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // returns 1\ncache.put(3, 3);    // evicts key 2\ncache.get(2);       // returns -1 (not found)\ncache.put(4, 4);    // evicts key 1\ncache.get(1);       // returns -1 (not found)\ncache.get(3);       // returns 3\ncache.get(4);       // returns 4",
    "Difficulty" : "Hard",
    "Number" : "146",
    "Source" : "LeetCode",
    "Title" : "LRU Cache"
  }, {
    "Description" : "Sort a linked list using insertion sort.",
    "Difficulty" : "Medium",
    "Number" : "147",
    "Source" : "LeetCode",
    "Title" : "Insertion Sort List"
  }, {
    "Description" : "Sort a linked list in O(n log n) time using constant space complexity.",
    "Difficulty" : "Medium",
    "Number" : "148",
    "Source" : "LeetCode",
    "Title" : "Sort List"
  }, {
    "Description" : "Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.",
    "Difficulty" : "Hard",
    "Number" : "149",
    "Source" : "LeetCode",
    "Title" : "Max Points on a Line"
  }, {
    "Description" : "Evaluate the value of an arithmetic expression in Reverse Polish Notation.\n\nValid operators are +, -, *, /. Each operand may be an integer or another expression.\n\nSome examples:\n  [\"2\", \"1\", \"+\", \"3\", \"*\"] -> ((2 + 1) * 3) -> 9\n  [\"4\", \"13\", \"5\", \"/\", \"+\"] -> (4 + (13 / 5)) -> 6",
    "Difficulty" : "Medium",
    "Number" : "150",
    "Source" : "LeetCode",
    "Title" : "Evaluate Reverse Polish Notation"
  }, {
    "Description" : "Given an input string, reverse the string word by word.\n\nFor example,\nGiven s = \"the sky is blue\",\nreturn \"blue is sky the\".",
    "Difficulty" : "Medium",
    "Number" : "151",
    "Source" : "LeetCode",
    "Title" : "Reverse Words in a String"
  }, {
    "Description" : "Find the contiguous subarray within an array (containing at least one number) which has the largest product.\n\nFor example, given the array [2,3,-2,4],\nthe contiguous subarray [2,3] has the largest product = 6.",
    "Difficulty" : "Medium",
    "Number" : "152",
    "Source" : "LeetCode",
    "Title" : "Maximum Product Subarray"
  }, {
    "Description" : "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n\n(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\n\nFind the minimum element.\n\nYou may assume no duplicate exists in the array.",
    "Difficulty" : "Medium",
    "Number" : "153",
    "Source" : "LeetCode",
    "Title" : "Find Minimum in Rotated Sorted Array"
  }, {
    "Description" : "Follow up for \"Find Minimum in Rotated Sorted Array\":\nWhat if duplicates are allowed?\n\nWould this affect the run-time complexity? How and why?\nSuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n\n(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\n\nFind the minimum element.\n\nThe array may contain duplicates.",
    "Difficulty" : "Hard",
    "Number" : "154",
    "Source" : "LeetCode",
    "Title" : "Find Minimum in Rotated Sorted Array II"
  }, {
    "Description" : "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\npush(x) -- Push element x onto stack.\npop() -- Removes the element on top of the stack.\ntop() -- Get the top element.\ngetMin() -- Retrieve the minimum element in the stack.\nExample:\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --> Returns -3.\nminStack.pop();\nminStack.top();      --> Returns 0.\nminStack.getMin();   --> Returns -2.",
    "Difficulty" : "Easy",
    "Number" : "155",
    "Source" : "LeetCode",
    "Title" : "Min Stack"
  }, {
    "Description" : "Total Accepted: 20971\nTotal Submissions: 48774\nDifficulty: Medium\nContributors: Admin\nGiven a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.\n\nFor example:\nGiven a binary tree {1,2,3,4,5},\n    1\n   / \\\n  2   3\n / \\\n4   5\nreturn the root of the binary tree [4,5,2,#,#,3,1].\n   4\n  / \\\n 5   2\n    / \\\n   3   1  ",
    "Difficulty" : "Medium",
    "Number" : "156",
    "Source" : "LeetCode",
    "Title" : "Binary Tree Upside Down"
  }, {
    "Description" : "The API: int read4(char *buf) reads 4 characters at a time from a file.\n\nThe return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.\n\nBy using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.\n\nNote:\nThe read function will only be called once for each test case.",
    "Difficulty" : "Easy",
    "Number" : "157",
    "Solutions" : {
      "Python" : [ {
        "code" : "<code>\n# The read4 API is already defined for you.\n# @param buf, a list of characters\n# @return an integer\n# def read4(buf):\n\nclass Solution(object):\n    def read(self, buf, n):\n        \"\"\"\n        :type buf: Destination buffer (List[str])\n        :type n: Maximum number of characters to read (int)\n        :rtype: The number of characters read (int)\n        \"\"\"\n        buffer = [''] * 4\n        index = 0\n        while n &gt; 0:\n            actual_read = read4(buffer)\n            if actual_read == 0:\n                return index\n            for i in xrange(min(actual_read, n)):\n                buf[index] = buffer[i]\n                index += 1\n                n -= 1\n        return index\n</code>",
        "runtime" : ""
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Read N Characters Given Read4"
  }, {
    "Description" : "The API: int read4(char *buf) reads 4 characters at a time from a file.\n\nThe return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.\n\nBy using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.\n\nNote:\nThe read function may be called multiple times.",
    "Difficulty" : "Hard",
    "Number" : "158",
    "Solutions" : {
      "Python" : [ {
        "code" : "<code>\nclass Solution(object):\n\n    def __init__(self):\n        self.buffer = [''] * 4\n        self.index4 = 0\n        self.actual_read4 = 0\n\n    def read(self, buf, n):\n        \"\"\"\n        :type buf: Destination buffer (List[str])\n        :type n: Maximum number of characters to read (int)\n        :rtype: The number of characters read (int)\n        \"\"\"\n        i = 0\n        while i &lt; n:\n            if self.index4 &gt;= self.actual_read4:\n                self.index4 = 0\n                self.actual_read4 = read4(self.buffer)\n                if self.actual_read4 == 0:\n                    return i\n\n            buf[i] = self.buffer[self.index4]\n            i += 1\n            self.index4 += 1\n        return i\n</code>",
        "runtime" : ""
      } ]
    },
    "Source" : "LeetCode",
    "Title" : "Read N Characters Given Read4 II - Call multiple times"
  }, {
    "Description" : "Given a string, find the length of the longest substring T that contains at most 2 distinct characters.\n\nFor example, Given s = “eceba”,\n\nT is \"ece\" which its length is 3.",
    "Difficulty" : "Hard",
    "Number" : "159",
    "Source" : "LeetCode",
    "Title" : "Longest Substring with At Most Two Distinct Characters"
  }, {
    "Description" : "Write a program to find the node at which the intersection of two singly linked lists begins.\n\n\nFor example, the following two linked lists:\n\nA:          a1 → a2\n                   ↘\n                     c1 → c2 → c3\n                   ↗            \nB:     b1 → b2 → b3\nbegin to intersect at node c1.\n\nNotes:\n\nIf the two linked lists have no intersection at all, return null.\nThe linked lists must retain their original structure after the function returns.\nYou may assume there are no cycles anywhere in the entire linked structure.\nYour code should preferably run in O(n) time and use only O(1) memory.",
    "Difficulty" : "Easy",
    "Number" : "160",
    "Source" : "LeetCode",
    "Title" : "Intersection of Two Linked Lists"
  }, {
    "Description" : "Given two strings S and T, determine if they are both one edit distance apart.",
    "Difficulty" : "Medium",
    "Number" : "161",
    "Source" : "LeetCode",
    "Title" : "One Edit Distance"
  }, {
    "Description" : "A peak element is an element that is greater than its neighbors.\n\nGiven an input array where num[i] ≠ num[i+1], find a peak element and return its index.\n\nThe array may contain multiple peaks, in that case return the index to any one of the peaks is fine.\n\nYou may imagine that num[-1] = num[n] = -∞.\n\nFor example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.",
    "Difficulty" : "Medium",
    "Number" : "162",
    "Source" : "LeetCode",
    "Title" : "Find Peak Element"
  }, {
    "Description" : "Given a sorted integer array where the range of elements are in the inclusive range [lower, upper], return its missing ranges.\n\nFor example, given [0, 1, 3, 50, 75], lower = 0 and upper = 99, return [\"2\", \"4->49\", \"51->74\", \"76->99\"].",
    "Difficulty" : "Medium",
    "Number" : "163",
    "Source" : "LeetCode",
    "Title" : "Missing Ranges"
  }, {
    "Description" : "Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\n\nTry to solve it in linear time/space.\n\nReturn 0 if the array contains less than 2 elements.\n\nYou may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.",
    "Difficulty" : "Hard",
    "Number" : "164",
    "Source" : "LeetCode",
    "Title" : "Maximum Gap"
  }, {
    "Description" : "Compare two version numbers version1 and version2.\nIf version1 > version2 return 1, if version1 < version2 return -1, otherwise return 0.\n\nYou may assume that the version strings are non-empty and contain only digits and the . character.\nThe . character does not represent a decimal point and is used to separate number sequences.\nFor instance, 2.5 is not \"two and a half\" or \"half way to version three\", it is the fifth second-level revision of the second first-level revision.\n\nHere is an example of version numbers ordering:\n\n0.1 < 1.1 < 1.2 < 13.37",
    "Difficulty" : "Medium",
    "Number" : "165",
    "Source" : "LeetCode",
    "Title" : "Compare Version Numbers"
  }, {
    "Description" : "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\n\nIf the fractional part is repeating, enclose the repeating part in parentheses.\n\nFor example,\n\nGiven numerator = 1, denominator = 2, return \"0.5\".\nGiven numerator = 2, denominator = 1, return \"2\".\nGiven numerator = 2, denominator = 3, return \"0.(6)\".",
    "Difficulty" : "Medium",
    "Number" : "166",
    "Source" : "LeetCode",
    "Title" : "Fraction to Recurring Decimal"
  }, {
    "Description" : "Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.\n\nThe function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.\n\nYou may assume that each input would have exactly one solution and you may not use the same element twice.\n\nInput: numbers={2, 7, 11, 15}, target=9\nOutput: index1=1, index2=2",
    "Difficulty" : "Easy",
    "Number" : "167",
    "Source" : "LeetCode",
    "Title" : "Two Sum II - Input array is sorted"
  }, {
    "Description" : "Given a positive integer, return its corresponding column title as appear in an Excel sheet.\n\nFor example:\n\n    1 -> A\n    2 -> B\n    3 -> C\n    ...\n    26 -> Z\n    27 -> AA\n    28 -> AB ",
    "Difficulty" : "Easy",
    "Number" : "168",
    "Source" : "LeetCode",
    "Title" : "Excel Sheet Column Title"
  }, {
    "Description" : "Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\n\nYou may assume that the array is non-empty and the majority element always exist in the array.",
    "Difficulty" : "Easy",
    "Number" : "169",
    "Source" : "LeetCode",
    "Title" : "Majority Element"
  }, {
    "Description" : "Design and implement a TwoSum class. It should support the following operations: add and find.\n\nadd - Add the number to an internal data structure.\nfind - Find if there exists any pair of numbers which sum is equal to the value.\n\nFor example,\nadd(1); add(3); add(5);\nfind(4) -> true\nfind(7) -> false",
    "Difficulty" : "Easy",
    "Number" : "170",
    "Source" : "LeetCode",
    "Title" : "Two Sum III - Data structure design"
  }, {
    "Description" : "Related to question Excel Sheet Column Title\n\nGiven a column title as appear in an Excel sheet, return its corresponding column number.\n\nFor example:\n\n    A -> 1\n    B -> 2\n    C -> 3\n    ...\n    Z -> 26\n    AA -> 27\n    AB -> 28 ",
    "Difficulty" : "Easy",
    "Number" : "171",
    "Source" : "LeetCode",
    "Title" : "Excel Sheet Column Number"
  }, {
    "Description" : "Given an integer n, return the number of trailing zeroes in n!.\n\nNote: Your solution should be in logarithmic time complexity.",
    "Difficulty" : "Easy",
    "Number" : "172",
    "Source" : "LeetCode",
    "Title" : "Factorial Trailing Zeroes"
  }, {
    "Description" : "Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.\n\nCalling next() will return the next smallest number in the BST.\n\nNote: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.",
    "Difficulty" : "Medium",
    "Number" : "173",
    "Source" : "LeetCode",
    "Title" : "Binary Search Tree Iterator"
  }, {
    "Description" : "The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.\n\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\n\nSome of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers).\n\nIn order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.\n\n\nWrite a function to determine the knight's minimum initial health so that he is able to rescue the princess.\n\nFor example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN.\n\n-2 (K)\t-3\t3\n-5\t-10\t1\n10\t30\t-5 (P)\n\nNotes:\n\nThe knight's health has no upper bound.\nAny room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.",
    "Difficulty" : "Hard",
    "Number" : "174",
    "Source" : "LeetCode",
    "Title" : "Dungeon Game"
  }, {
    "Description" : "Given a list of non negative integers, arrange them such that they form the largest number.\n\nFor example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.\n\nNote: The result may be very large, so you need to return a string instead of an integer.",
    "Difficulty" : "Medium",
    "Number" : "179",
    "Source" : "LeetCode",
    "Title" : "Largest Number"
  }, {
    "Description" : "Given an input string, reverse the string word by word. A word is defined as a sequence of non-space characters.\n\nThe input string does not contain leading or trailing spaces and the words are always separated by a single space.\n\nFor example,\nGiven s = \"the sky is blue\",\nreturn \"blue is sky the\".\n\nCould you do it in-place without allocating extra space?",
    "Difficulty" : "Medium",
    "Number" : "186",
    "Source" : "LeetCode",
    "Title" : "Reverse Words in a String II"
  }, {
    "Description" : "All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: \"ACGAATTCCG\". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.\n\nWrite a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\n\nFor example,\n\nGiven s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\",\n\nReturn:\n[\"AAAAACCCCC\", \"CCCCCAAAAA\"].",
    "Difficulty" : "Medium",
    "Number" : "187",
    "Source" : "LeetCode",
    "Title" : "Repeated DNA Sequences"
  }, {
    "Description" : "Say you have an array for which the ith element is the price of a given stock on day i.\n\nDesign an algorithm to find the maximum profit. You may complete at most k transactions.\n\nNote:\nYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).",
    "Difficulty" : "Hard",
    "Number" : "188",
    "Source" : "LeetCode",
    "Title" : "Best Time to Buy and Sell Stock IV"
  }, {
    "Description" : "Rotate an array of n elements to the right by k steps.\n\nFor example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].\n\nNote:\nTry to come up as many solutions as you can, there are at least 3 different ways to solve this problem.\n\n\nHint:\nCould you do it in-place with O(1) extra space?",
    "Difficulty" : "Easy",
    "Number" : "189",
    "Source" : "LeetCode",
    "Title" : "Rotate Array"
  }, {
    "Description" : "Reverse bits of a given 32 bits unsigned integer.\n\nFor example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).\n\nFollow up:\nIf this function is called many times, how would you optimize it?",
    "Difficulty" : "Easy",
    "Number" : "190",
    "Source" : "LeetCode",
    "Title" : "Reverse Bits"
  }, {
    "Description" : "Write a function that takes an unsigned integer and returns the number of ’1' bits it has (also known as the Hamming weight).\n\nFor example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, so the function should return 3.",
    "Difficulty" : "Easy",
    "Number" : "191",
    "Source" : "LeetCode",
    "Title" : "Number of 1 Bits"
  }, {
    "Description" : "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.",
    "Difficulty" : "Easy",
    "Number" : "198",
    "Source" : "LeetCode",
    "Title" : "House Robber"
  }, {
    "Description" : "Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\n\nFor example:\nGiven the following binary tree,\n   1            <---\n /   \\\n2     3         <---\n \\     \\\n  5     4       <---\nYou should return [1, 3, 4].",
    "Difficulty" : "Medium",
    "Number" : "199",
    "Source" : "LeetCode",
    "Title" : "Binary Tree Right Side View"
  }, {
    "Description" : "Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\nExample 1:\n\n11110\n11010\n11000\n00000\nAnswer: 1\n\nExample 2:\n\n11000\n11000\n00100\n00011\nAnswer: 3",
    "Difficulty" : "Medium",
    "Number" : "200",
    "Source" : "LeetCode",
    "Title" : "Number of Islands"
  }, {
    "Description" : "Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.\n\nFor example, given the range [5, 7], you should return 4.",
    "Difficulty" : "Medium",
    "Number" : "201",
    "Source" : "LeetCode",
    "Title" : "Bitwise AND of Numbers Range"
  }, {
    "Description" : "Write an algorithm to determine if a number is \"happy\".\n\nA happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.\n\nExample: 19 is a happy number\n\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1",
    "Difficulty" : "Easy",
    "Number" : "202",
    "Source" : "LeetCode",
    "Title" : "Happy Number"
  }, {
    "Description" : "Remove all elements from a linked list of integers that have value val.\n\nExample\nGiven: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6\nReturn: 1 --> 2 --> 3 --> 4 --> 5",
    "Difficulty" : "Easy",
    "Number" : "203",
    "Source" : "LeetCode",
    "Title" : "Remove Linked List Elements"
  }, {
    "Description" : "Description:\n\nCount the number of prime numbers less than a non-negative number, n.",
    "Difficulty" : "Easy",
    "Number" : "204",
    "Source" : "LeetCode",
    "Title" : "Count Primes"
  }, {
    "Description" : "Given two strings s and t, determine if they are isomorphic.\n\nTwo strings are isomorphic if the characters in s can be replaced to get t.\n\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.\n\nFor example,\nGiven \"egg\", \"add\", return true.\n\nGiven \"foo\", \"bar\", return false.\n\nGiven \"paper\", \"title\", return true.\n\nNote:\nYou may assume both s and t have the same length.",
    "Difficulty" : "Easy",
    "Number" : "205",
    "Source" : "LeetCode",
    "Title" : "Isomorphic Strings"
  }, {
    "Description" : "Reverse a singly linked list.\n\nHint:\nA linked list can be reversed either iteratively or recursively. Could you implement both?",
    "Difficulty" : "Easy",
    "Number" : "206",
    "Source" : "LeetCode",
    "Title" : "Reverse Linked List"
  }, {
    "Description" : "There are a total of n courses you have to take, labeled from 0 to n - 1.\n\nSome courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\n\nGiven the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?\n\nFor example:\n\n2, [[1,0]]\nThere are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.\n\n2, [[1,0],[0,1]]\nThere are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\nNote:\nThe input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.\nYou may assume that there are no duplicate edges in the input prerequisites.\nclick to show more hints.\n\nHints:\nThis problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.\nTopological Sort via DFS - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.\nTopological sort could also be done via BFS.",
    "Difficulty" : "Medium",
    "Number" : "207",
    "Source" : "LeetCode",
    "Title" : "Course Schedule"
  }, {
    "Description" : "Implement a trie with insert, search, and startsWith methods.\n\nNote:\nYou may assume that all inputs are consist of lowercase letters a-z.",
    "Difficulty" : "Medium",
    "Number" : "208",
    "Source" : "LeetCode",
    "Title" : "Implement Trie (Prefix Tree)"
  }, {
    "Description" : "Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.\n\nFor example, given the array [2,3,1,2,4,3] and s = 7,\nthe subarray [4,3] has the minimal length under the problem constraint.\n\nMore practice:\nIf you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).",
    "Difficulty" : "Medium",
    "Number" : "209",
    "Source" : "LeetCode",
    "Title" : "Minimum Size Subarray Sum"
  }, {
    "Description" : "There are a total of n courses you have to take, labeled from 0 to n - 1.\n\nSome courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\n\nGiven the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.\n\nThere may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.\n\nFor example:\n\n2, [[1,0]]\nThere are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]\n\n4, [[1,0],[2,0],[3,1],[3,2]]\nThere are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].\n\nNote:\nThe input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.\nYou may assume that there are no duplicate edges in the input prerequisites.",
    "Difficulty" : "Medium",
    "Number" : "210",
    "Source" : "LeetCode",
    "Title" : "Course Schedule II"
  }, {
    "Description" : "Design a data structure that supports the following two operations:\n\nvoid addWord(word)\nbool search(word)\nsearch(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.\n\nFor example:\n\naddWord(\"bad\")\naddWord(\"dad\")\naddWord(\"mad\")\nsearch(\"pad\") -> false\nsearch(\"bad\") -> true\nsearch(\".ad\") -> true\nsearch(\"b..\") -> true\nNote:\nYou may assume that all words are consist of lowercase letters a-z.",
    "Difficulty" : "Medium",
    "Number" : "211",
    "Source" : "LeetCode",
    "Title" : "Add and Search Word - Data structure design"
  }, {
    "Description" : "Given a 2D board and a list of words from the dictionary, find all words in the board.\n\nEach word must be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n\nFor example,\nGiven words = [\"oath\",\"pea\",\"eat\",\"rain\"] and board =\n\n[\n  ['o','a','a','n'],\n  ['e','t','a','e'],\n  ['i','h','k','r'],\n  ['i','f','l','v']\n]\nReturn [\"eat\",\"oath\"].\nNote:\nYou may assume that all inputs are consist of lowercase letters a-z.",
    "Difficulty" : "Hard",
    "Number" : "212",
    "Source" : "LeetCode",
    "Title" : "Word Search II"
  }, {
    "Description" : "After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.\n\nGiven a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.",
    "Difficulty" : "Medium",
    "Number" : "213",
    "Source" : "LeetCode",
    "Title" : "House Robber II"
  }, {
    "Description" : "Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.\n\nFor example:\n\nGiven \"aacecaaa\", return \"aaacecaaa\".\n\nGiven \"abcd\", return \"dcbabcd\".",
    "Difficulty" : "Hard",
    "Number" : "214",
    "Source" : "LeetCode",
    "Title" : "Shortest Palindrome"
  }, {
    "Description" : "Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\n\nFor example,\nGiven [3,2,1,5,6,4] and k = 2, return 5.\n\nNote: \nYou may assume k is always valid, 1 ≤ k ≤ array's length.",
    "Difficulty" : "Medium",
    "Number" : "215",
    "Source" : "LeetCode",
    "Title" : "Kth Largest Element in an Array"
  }, {
    "Description" : "Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.\n\n\nExample 1:\n\nInput: k = 3, n = 7\n\nOutput:\n\n[[1,2,4]]\n\nExample 2:\n\nInput: k = 3, n = 9\n\nOutput:\n\n[[1,2,6], [1,3,5], [2,3,4]]",
    "Difficulty" : "Medium",
    "Number" : "216",
    "Source" : "LeetCode",
    "Title" : "Combination Sum III"
  }, {
    "Description" : "Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.",
    "Difficulty" : "Easy",
    "Number" : "217",
    "Source" : "LeetCode",
    "Title" : "Contains Duplicate"
  }, {
    "Description" : "A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).\n<img src=\"https://leetcode.com/static/images/problemset/skyline1.jpg\" />\n<img src=\"https://leetcode.com/static/images/problemset/skyline2.jpg\" />\n Buildings Skyline Contour\nThe geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 < Hi ≤ INT_MAX, and Ri - Li > 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\n\nFor instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .\n\nThe output is a list of \"key points\" (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.\n\nFor instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].\n\nNotes:\n\nThe number of buildings in any input list is guaranteed to be in the range [0, 10000].\nThe input list is already sorted in ascending order by the left x position Li.\nThe output list must be sorted by the x position.\nThere must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...]",
    "Difficulty" : "Hard",
    "Number" : "218",
    "Source" : "LeetCode",
    "Title" : "The Skyline Problem"
  }, {
    "Description" : "Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.",
    "Difficulty" : "Easy",
    "Number" : "219",
    "Source" : "LeetCode",
    "Title" : "Contains Duplicate II"
  }, {
    "Description" : "Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.",
    "Difficulty" : "Medium",
    "Number" : "220",
    "Source" : "LeetCode",
    "Title" : "Contains Duplicate III"
  }, {
    "Description" : "Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\n\nFor example, given the following matrix:\n\n1 0 1 0 0\n1 0 1 1 1\n1 1 1 1 1\n1 0 0 1 0\nReturn 4.",
    "Difficulty" : "Medium",
    "Number" : "221",
    "Source" : "LeetCode",
    "Title" : "Maximal Square"
  }, {
    "Description" : "Given a complete binary tree, count the number of nodes.\n\nDefinition of a complete binary tree from Wikipedia:\nIn a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.",
    "Difficulty" : "Medium",
    "Number" : "222",
    "Source" : "LeetCode",
    "Title" : "Count Complete Tree Nodes"
  }, {
    "Description" : "Find the total area covered by two rectilinear rectangles in a 2D plane.\n\nEach rectangle is defined by its bottom left corner and top right corner as shown in the figure.\n\n<img src=\"https://leetcode.com/static/images/problemset/rectangle_area.png\" />\n\nRectangle Area\nAssume that the total area is never beyond the maximum possible value of int.",
    "Difficulty" : "Medium",
    "Number" : "223",
    "Source" : "LeetCode",
    "Title" : "Rectangle Area"
  }, {
    "Description" : "Implement a basic calculator to evaluate a simple expression string.\n\nThe expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .\n\nYou may assume that the given expression is always valid.\n\nSome examples:\n\"1 + 1\" = 2\n\" 2-1 + 2 \" = 3\n\"(1+(4+5+2)-3)+(6+8)\" = 23\nNote: Do not use the eval built-in library function.",
    "Difficulty" : "Hard",
    "Number" : "224",
    "Source" : "LeetCode",
    "Title" : "Basic Calculator"
  }, {
    "Description" : "Implement the following operations of a stack using queues.\n\npush(x) -- Push element x onto stack.\npop() -- Removes the element on top of the stack.\ntop() -- Get the top element.\nempty() -- Return whether the stack is empty.\nNotes:\nYou must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid.\nDepending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.\nYou may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).",
    "Difficulty" : "Easy",
    "Number" : "225",
    "Source" : "LeetCode",
    "Title" : "Implement Stack using Queues"
  }, {
    "Description" : "Invert a binary tree.\n\n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\nto\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1",
    "Difficulty" : "Easy",
    "Number" : "226",
    "Source" : "LeetCode",
    "Title" : "Invert Binary Tree"
  }, {
    "Description" : "Implement a basic calculator to evaluate a simple expression string.\n\nThe expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.\n\nYou may assume that the given expression is always valid.\n\nSome examples:\n\"3+2*2\" = 7\n\" 3/2 \" = 1\n\" 3+5 / 2 \" = 5\nNote: Do not use the eval built-in library function.",
    "Difficulty" : "Medium",
    "Number" : "227",
    "Source" : "LeetCode",
    "Title" : "Basic Calculator II"
  }, {
    "Description" : "Given a sorted integer array without duplicates, return the summary of its ranges.\n\nFor example, given [0,1,2,4,5,7], return [\"0->2\",\"4->5\",\"7\"].\n",
    "Difficulty" : "Medium",
    "Number" : "228",
    "Source" : "LeetCode",
    "Title" : "Summary Ranges"
  }, {
    "Description" : "Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.",
    "Difficulty" : "Medium",
    "Number" : "229",
    "Source" : "LeetCode",
    "Title" : "Majority Element II"
  }, {
    "Description" : "Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.\n\nNote: \nYou may assume k is always valid, 1 ≤ k ≤ BST's total elements.\n\nFollow up:\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?",
    "Difficulty" : "Medium",
    "Number" : "230",
    "Source" : "LeetCode",
    "Title" : "Kth Smallest Element in a BST"
  }, {
    "Description" : "Given an integer, write a function to determine if it is a power of two.",
    "Difficulty" : "Easy",
    "Number" : "231",
    "Source" : "LeetCode",
    "Title" : "Power of Two"
  }, {
    "Description" : "Implement the following operations of a queue using stacks.\n\npush(x) -- Push element x to the back of queue.\npop() -- Removes the element from in front of queue.\npeek() -- Get the front element.\nempty() -- Return whether the queue is empty.\nNotes:\nYou must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid.\nDepending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.\nYou may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).",
    "Difficulty" : "Easy",
    "Number" : "232",
    "Source" : "LeetCode",
    "Title" : "Implement Queue using Stacks"
  }, {
    "Description" : "Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.\n\nFor example:\nGiven n = 13,\nReturn 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.",
    "Difficulty" : "Hard",
    "Number" : "233",
    "Source" : "LeetCode",
    "Title" : "Number of Digit One"
  }, {
    "Description" : "Given a singly linked list, determine if it is a palindrome.\n\nFollow up:\nCould you do it in O(n) time and O(1) space?",
    "Difficulty" : "Easy",
    "Number" : "234",
    "Source" : "LeetCode",
    "Title" : "Palindrome Linked List"
  }, {
    "Description" : "Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.\n\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”\n\n        _______6______\n       /              \\\n    ___2__          ___8__\n   /      \\        /      \\\n   0      _4       7       9\n         /  \\\n         3   5\nFor example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.",
    "Difficulty" : "Easy",
    "Number" : "235",
    "Source" : "LeetCode",
    "Title" : "Lowest Common Ancestor of a Binary Search Tree"
  }, {
    "Description" : "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”\n\n        _______3______\n       /              \\\n    ___5__          ___1__\n   /      \\        /      \\\n   6      _2       0       8\n         /  \\\n         7   4\nFor example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.",
    "Difficulty" : "Medium",
    "Number" : "236",
    "Source" : "LeetCode",
    "Title" : "Lowest Common Ancestor of a Binary Tree"
  }, {
    "Description" : "Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.\n\nSupposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 3, the linked list should become 1 -> 2 -> 4 after calling your function.",
    "Difficulty" : "Easy",
    "Number" : "237",
    "Source" : "LeetCode",
    "Title" : "Delete Node in a Linked List"
  }, {
    "Description" : "Given an array of n integers where n > 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].\n\nSolve it without division and in O(n).\n\nFor example, given [1,2,3,4], return [24,12,8,6].\n\nFollow up:\nCould you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)",
    "Difficulty" : "Medium",
    "Number" : "238",
    "Source" : "LeetCode",
    "Title" : "Product of Array Except Self"
  }, {
    "Description" : "Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\n\nFor example,\nGiven nums = [1,3,-1,-3,5,3,6,7], and k = 3.\n\nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\nTherefore, return the max sliding window as [3,3,5,5,6,7].\n\nNote: \nYou may assume k is always valid, ie: 1 ≤ k ≤ input array's size for non-empty array.\n\nFollow up:\nCould you solve it in linear time?",
    "Difficulty" : "Medium",
    "Number" : "239",
    "Source" : "LeetCode",
    "Title" : "Sliding Window Maximum"
  }, {
    "Description" : "Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.\n\n\nExample 1\nInput: \"2-1-1\".\n\n((2-1)-1) = 0\n(2-(1-1)) = 2\nOutput: [0, 2]\n\n\nExample 2\nInput: \"2*3-4*5\"\n\n(2*(3-(4*5))) = -34\n((2*3)-(4*5)) = -14\n((2*(3-4))*5) = -10\n(2*((3-4)*5)) = -10\n(((2*3)-4)*5) = 10\nOutput: [-34, -14, -10, -10, 10]",
    "Difficulty" : "Medium",
    "Number" : "241",
    "Source" : "LeetCode",
    "Title" : "Different Ways to Add Parentheses"
  }, {
    "Description" : "Given two strings s and t, write a function to determine if t is an anagram of s.\n\nFor example,\ns = \"anagram\", t = \"nagaram\", return true.\ns = \"rat\", t = \"car\", return false.\n\nNote:\nYou may assume the string contains only lowercase alphabets.\n\nFollow up:\nWhat if the inputs contain unicode characters? How would you adapt your solution to such case?",
    "Difficulty" : "Easy",
    "Number" : "242",
    "Source" : "LeetCode",
    "Title" : "Valid Anagram"
  }, {
    "Description" : "Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.\n\nFor example,\nAssume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"].\n\nGiven word1 = “coding”, word2 = “practice”, return 3.\nGiven word1 = \"makes\", word2 = \"coding\", return 1.\n\nNote:\nYou may assume that word1 does not equal to word2, and word1 and word2 are both in the list.",
    "Difficulty" : "Easy",
    "Number" : "243",
    "Source" : "LeetCode",
    "Title" : "Shortest Word Distance"
  }, {
    "Description" : "This is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it?\n\nDesign a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.\n\nFor example,\nAssume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"].\n\nGiven word1 = “coding”, word2 = “practice”, return 3.\nGiven word1 = \"makes\", word2 = \"coding\", return 1.\n\nNote:\nYou may assume that word1 does not equal to word2, and word1 and word2 are both in the list.",
    "Difficulty" : "Medium",
    "Number" : "244",
    "Source" : "LeetCode",
    "Title" : "Shortest Word Distance II"
  }, {
    "Description" : "This is a follow up of Shortest Word Distance. The only difference is now word1 could be the same as word2.\n\nGiven a list of words and two words word1 and word2, return the shortest distance between these two words in the list.\n\nword1 and word2 may be the same and they represent two individual words in the list.\n\nFor example,\nAssume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"].\n\nGiven word1 = “makes”, word2 = “coding”, return 1.\nGiven word1 = \"makes\", word2 = \"makes\", return 3.\n\nNote:\nYou may assume word1 and word2 are both in the list.",
    "Difficulty" : "Medium",
    "Number" : "245",
    "Source" : "LeetCode",
    "Title" : "Shortest Word Distance III"
  }, {
    "Description" : "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\n\nWrite a function to determine if a number is strobogrammatic. The number is represented as a string.\n\nFor example, the numbers \"69\", \"88\", and \"818\" are all strobogrammatic.",
    "Difficulty" : "Easy",
    "Number" : "246",
    "Source" : "LeetCode",
    "Title" : "Strobogrammatic Number"
  }, {
    "Description" : "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\n\nFind all strobogrammatic numbers that are of length = n.\n\nFor example,\nGiven n = 2, return [\"11\",\"69\",\"88\",\"96\"].",
    "Difficulty" : "Medium",
    "Number" : "247",
    "Source" : "LeetCode",
    "Title" : "Strobogrammatic Number II"
  }, {
    "Description" : "A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).\n\nWrite a function to count the total strobogrammatic numbers that exist in the range of low <= num <= high.\n\nFor example,\nGiven low = \"50\", high = \"100\", return 3. Because 69, 88, and 96 are three strobogrammatic numbers.\n\nNote:\nBecause the range might be a large number, the low and high numbers are represented as string.",
    "Difficulty" : "Hard",
    "Number" : "248",
    "Source" : "LeetCode",
    "Title" : "Strobogrammatic Number III"
  }, {
    "Description" : "Given a string, we can \"shift\" each of its letter to its successive letter, for example: \"abc\" -> \"bcd\". We can keep \"shifting\" which forms the sequence:\n\n\"abc\" -> \"bcd\" -> ... -> \"xyz\"\nGiven a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.\n\nFor example, given: [\"abc\", \"bcd\", \"acef\", \"xyz\", \"az\", \"ba\", \"a\", \"z\"], \nA solution is:\n\n[\n  [\"abc\",\"bcd\",\"xyz\"],\n  [\"az\",\"ba\"],\n  [\"acef\"],\n  [\"a\",\"z\"]\n]",
    "Difficulty" : "Medium",
    "Number" : "249",
    "Source" : "LeetCode",
    "Title" : "Group Shifted Strings"
  }, {
    "Description" : "Given a binary tree, count the number of uni-value subtrees.\n\nA Uni-value subtree means all nodes of the subtree have the same value.\n\nFor example:\nGiven binary tree,\n              5\n             / \\\n            1   5\n           / \\   \\\n          5   5   5\nreturn 4.",
    "Difficulty" : "Medium",
    "Number" : "250",
    "Source" : "LeetCode",
    "Title" : "Count Univalue Subtrees"
  }, {
    "Description" : "Implement an iterator to flatten a 2d vector.\n\nFor example,\nGiven 2d vector =\n\n[\n  [1,2],\n  [3],\n  [4,5,6]\n]\nBy calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,2,3,4,5,6].",
    "Difficulty" : "Medium",
    "Number" : "251",
    "Source" : "LeetCode",
    "Title" : "Flatten 2D Vector"
  }, {
    "Description" : "Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), determine if a person could attend all meetings.\n\nFor example,\nGiven [[0, 30],[5, 10],[15, 20]],\nreturn false.",
    "Difficulty" : "Easy",
    "Number" : "252",
    "Source" : "LeetCode",
    "Title" : "Meeting Rooms"
  }, {
    "Description" : "Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference rooms required.\n\nFor example,\nGiven [[0, 30],[5, 10],[15, 20]],\nreturn 2.",
    "Difficulty" : "Medium",
    "Number" : "253",
    "Source" : "LeetCode",
    "Title" : "Meeting Rooms II"
  }, {
    "Description" : "Numbers can be regarded as product of its factors. For example,\n\n8 = 2 x 2 x 2;\n  = 2 x 4.\nWrite a function that takes an integer n and return all possible combinations of its factors.\n\nNote: \nYou may assume that n is always positive.\nFactors should be greater than 1 and less than n.\nExamples: \ninput: 1\noutput: \n[]\ninput: 37\noutput: \n[]\ninput: 12\noutput:\n[\n  [2, 6],\n  [2, 2, 3],\n  [3, 4]\n]\ninput: 32\noutput:\n[\n  [2, 16],\n  [2, 2, 8],\n  [2, 2, 2, 4],\n  [2, 2, 2, 2, 2],\n  [2, 4, 4],\n  [4, 8]\n]",
    "Difficulty" : "Medium",
    "Number" : "254",
    "Source" : "LeetCode",
    "Title" : "Factor Combinations"
  }, {
    "Description" : "Given an array of numbers, verify whether it is the correct preorder traversal sequence of a binary search tree.\n\nYou may assume each number in the sequence is unique.\n\nFollow up:\nCould you do it using only constant space complexity?",
    "Difficulty" : "Medium",
    "Number" : "255",
    "Source" : "LeetCode",
    "Title" : "Verify Preorder Sequence in Binary Search Tree"
  }, {
    "Description" : "There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\n\nThe cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Find the minimum cost to paint all houses.\n\nNote:\nAll costs are positive integers.",
    "Difficulty" : "Easy",
    "Number" : "256",
    "Source" : "LeetCode",
    "Title" : "Paint House"
  }, {
    "Description" : "Given a binary tree, return all root-to-leaf paths.\n\nFor example, given the following binary tree:\n\n   1\n /   \\\n2     3\n \\\n  5\nAll root-to-leaf paths are:\n\n[\"1->2->5\", \"1->3\"]",
    "Difficulty" : "Easy",
    "Number" : "257",
    "Source" : "LeetCode",
    "Title" : "Binary Tree Paths"
  }, {
    "Description" : "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\n\nFor example:\n\nGiven num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.\n\nFollow up:\nCould you do it without any loop/recursion in O(1) runtime?",
    "Difficulty" : "Easy",
    "Number" : "258",
    "Source" : "LeetCode",
    "Title" : "Add Digits"
  }, {
    "Description" : "Given an array of n integers nums and a target, find the number of index triplets i, j, k with 0 <= i < j < k < n that satisfy the condition nums[i] + nums[j] + nums[k] < target.\n\nFor example, given nums = [-2, 0, 1, 3], and target = 2.\n\nReturn 2. Because there are two triplets which sums are less than 2:\n\n[-2, 0, 1]\n[-2, 0, 3]\nFollow up:\nCould you solve it in O(n2) runtime?",
    "Difficulty" : "Medium",
    "Number" : "259",
    "Source" : "LeetCode",
    "Title" : "3Sum Smaller"
  }, {
    "Description" : "Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.\n\nFor example:\n\nGiven nums = [1, 2, 1, 3, 2, 5], return [3, 5].\n\nNote:\nThe order of the result is not important. So in the above example, [5, 3] is also correct.\nYour algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?",
    "Difficulty" : "Medium",
    "Number" : "260",
    "Source" : "LeetCode",
    "Title" : "Single Number III"
  }, {
    "Description" : "Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.\n\nFor example:\n\nGiven n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.\n\nGiven n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.\n\nHint:\n\nGiven n = 5 and edges = [[0, 1], [1, 2], [3, 4]], what should your return? Is this case a valid tree?\nAccording to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”\nNote: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.",
    "Difficulty" : "Medium",
    "Number" : "261",
    "Source" : "LeetCode",
    "Title" : "Graph Valid Tree"
  }, {
    "Description" : "Write a program to check whether a given number is an ugly number.\n\nUgly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.\n\nNote that 1 is typically treated as an ugly number.\n",
    "Difficulty" : "Easy",
    "Number" : "263",
    "Source" : "LeetCode",
    "Title" : "Ugly Number"
  }, {
    "Description" : "Write a program to find the n-th ugly number.\n\nUgly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.\n\nNote that 1 is typically treated as an ugly number, and n does not exceed 1690.",
    "Difficulty" : "Medium",
    "Number" : "264",
    "Source" : "LeetCode",
    "Title" : "Ugly Number II"
  }, {
    "Description" : "There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\n\nThe cost of painting each house with a certain color is represented by a n x k cost matrix. For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on... Find the minimum cost to paint all houses.\n\nNote:\nAll costs are positive integers.\n\nFollow up:\nCould you solve it in O(nk) runtime?",
    "Difficulty" : "Hard",
    "Number" : "265",
    "Source" : "LeetCode",
    "Title" : "Paint House II"
  }, {
    "Description" : "Given a string, determine if a permutation of the string could form a palindrome.\n\nFor example,\n\"code\" -> False, \"aab\" -> True, \"carerac\" -> True.",
    "Difficulty" : "Easy",
    "Number" : "266",
    "Source" : "LeetCode",
    "Title" : "Palindrome Permutation"
  }, {
    "Description" : "Given a string s, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form.\n\nFor example:\n\nGiven s = \"aabb\", return [\"abba\", \"baab\"].\n\nGiven s = \"abc\", return [].",
    "Difficulty" : "Medium",
    "Number" : "267",
    "Source" : "LeetCode",
    "Title" : "Palindrome Permutation II"
  }, {
    "Description" : "Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\n\nFor example,\nGiven nums = [0, 1, 3] return 2.\n\nNote:\nYour algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?",
    "Difficulty" : "Easy",
    "Number" : "268",
    "Source" : "LeetCode",
    "Title" : "Missing Number"
  }, {
    "Description" : "There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.\n\nFor example,\nGiven the following words in dictionary,\n\n[\n  \"wrt\",\n  \"wrf\",\n  \"er\",\n  \"ett\",\n  \"rftt\"\n]\nThe correct order is: \"wertf\".\n\nNote:\nYou may assume all letters are in lowercase.\nIf the order is invalid, return an empty string.\nThere may be multiple valid order of letters, return any one of them is fine.",
    "Difficulty" : "Hard",
    "Number" : "269",
    "Source" : "LeetCode",
    "Title" : "Alien Dictionary"
  }, {
    "Description" : "Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.\n\nNote:\nGiven target value is a floating point.\nYou are guaranteed to have only one unique value in the BST that is closest to the target.",
    "Difficulty" : "Easy",
    "Number" : "270",
    "Source" : "LeetCode",
    "Title" : "Closest Binary Search Tree Value"
  }, {
    "Description" : "Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.\n\nMachine 1 (sender) has the function:\n\nstring encode(vector<string> strs) {\n  // ... your code\n  return encoded_string;\n}\nMachine 2 (receiver) has the function:\nvector<string> decode(string s) {\n  //... your code\n  return strs;\n}\nSo Machine 1 does:\n\nstring encoded_string = encode(strs);\nand Machine 2 does:\n\nvector<string> strs2 = decode(encoded_string);\nstrs2 in Machine 2 should be the same as strs in Machine 1.\n\nImplement the encode and decode methods.\n\nNote:\nThe string may contain any possible characters out of 256 valid ascii characters. Your algorithm should be generalized enough to work on any possible characters.\nDo not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.\nDo not rely on any library method such as eval or serialize methods. You should implement your own encode/decode algorithm.",
    "Difficulty" : "Medium",
    "Number" : "271",
    "Source" : "LeetCode",
    "Title" : "Encode and Decode Strings"
  }, {
    "Description" : "Given a non-empty binary search tree and a target value, find k values in the BST that are closest to the target.\n\nNote:\nGiven target value is a floating point.\nYou may assume k is always valid, that is: k ≤ total nodes.\nYou are guaranteed to have only one unique set of k values in the BST that are closest to the target.\nFollow up:\nAssume that the BST is balanced, could you solve it in less than O(n) runtime (where n = total nodes)?",
    "Difficulty" : "Hard",
    "Number" : "272",
    "Source" : "LeetCode",
    "Title" : "Closest Binary Search Tree Value II"
  }, {
    "Description" : "Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.\n\nFor example,\n123 -> \"One Hundred Twenty Three\"\n12345 -> \"Twelve Thousand Three Hundred Forty Five\"\n1234567 -> \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"",
    "Difficulty" : "Hard",
    "Number" : "273",
    "Source" : "LeetCode",
    "Title" : "Integer to English Words"
  }, {
    "Description" : "Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.\n\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.\"\n\nFor example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3.\n\nNote: If there are several possible values for h, the maximum one is taken as the h-index.",
    "Difficulty" : "Medium",
    "Number" : "274",
    "Source" : "LeetCode",
    "Title" : "H-Index"
  }, {
    "Description" : "Follow up for H-Index: What if the citations array is sorted in ascending order? Could you optimize your algorithm?",
    "Difficulty" : "Medium",
    "Number" : "275",
    "Source" : "LeetCode",
    "Title" : "H-Index II"
  }, {
    "Description" : "There is a fence with n posts, each post can be painted with one of the k colors.\n\nYou have to paint all the posts such that no more than two adjacent fence posts have the same color.\n\nReturn the total number of ways you can paint the fence.\n\nNote:\nn and k are non-negative integers.",
    "Difficulty" : "Easy",
    "Number" : "276",
    "Source" : "LeetCode",
    "Title" : "Paint Fence"
  }, {
    "Description" : "Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.\n\nNow you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: \"Hi, A. Do you know B?\" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).\n\nYou are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows.\n\nNote: There will be exactly one celebrity if he/she is in the party. Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return -1.",
    "Difficulty" : "Medium",
    "Number" : "277",
    "Source" : "LeetCode",
    "Title" : "Find the Celebrity"
  }, {
    "Description" : "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\n\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\n\nYou are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.",
    "Difficulty" : "Easy",
    "Number" : "278",
    "Source" : "LeetCode",
    "Title" : "First Bad Version"
  }, {
    "Description" : "Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.\n\nFor example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.",
    "Difficulty" : "Medium",
    "Number" : "279",
    "Source" : "LeetCode",
    "Title" : "Perfect Squares"
  }, {
    "Description" : "Given an unsorted array nums, reorder it in-place such that nums[0] <= nums[1] >= nums[2] <= nums[3]....\n\nFor example, given nums = [3, 5, 2, 1, 6, 4], one possible answer is [1, 6, 2, 5, 3, 4].",
    "Difficulty" : "Medium",
    "Number" : "280",
    "Source" : "LeetCode",
    "Title" : "Wiggle Sort"
  }, {
    "Description" : "Given two 1d vectors, implement an iterator to return their elements alternately.\n\nFor example, given two 1d vectors:\n\nv1 = [1, 2]\nv2 = [3, 4, 5, 6]\nBy calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1, 3, 2, 4, 5, 6].\n\nFollow up: What if you are given k 1d vectors? How well can your code be extended to such cases?\n\nClarification for the follow up question - Update (2015-09-18):\nThe \"Zigzag\" order is not clearly defined and is ambiguous for k > 2 cases. If \"Zigzag\" does not look right to you, replace \"Zigzag\" with \"Cyclic\". For example, given the following input:\n\n[1,2,3]\n[4,5,6,7]\n[8,9]\nIt should return [1,4,8,2,5,9,3,6,7].",
    "Difficulty" : "Medium",
    "Number" : "281",
    "Source" : "LeetCode",
    "Title" : "Zigzag Iterator"
  }, {
    "Description" : "Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.\n\nExamples: \n\"123\", 6 -> [\"1+2+3\", \"1*2*3\"] \n\"232\", 8 -> [\"2*3+2\", \"2+3*2\"]\n\"105\", 5 -> [\"1*0+5\",\"10-5\"]\n\"00\", 0 -> [\"0+0\", \"0-0\", \"0*0\"]\n\"3456237490\", 9191 -> []",
    "Difficulty" : "Hard",
    "Number" : "282",
    "Source" : "LeetCode",
    "Title" : "Expression Add Operators"
  }, {
    "Description" : "Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n\nFor example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].\n\nNote:\nYou must do this in-place without making a copy of the array.\nMinimize the total number of operations.",
    "Difficulty" : "Easy",
    "Number" : "283",
    "Source" : "LeetCode",
    "Title" : "Move Zeroes"
  }, {
    "Description" : "Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next().\n\nHere is an example. Assume that the iterator is initialized to the beginning of the list: [1, 2, 3].\n\nCall next() gets you 1, the first element in the list.\n\nNow you call peek() and it returns 2, the next element. Calling next() after that still return 2.\n\nYou call next() the final time and it returns 3, the last element. Calling hasNext() after that should return false.\n\nFollow up: How would you extend your design to be generic and work with all types, not just integer?",
    "Difficulty" : "Medium",
    "Number" : "284",
    "Source" : "LeetCode",
    "Title" : "Peeking Iterator"
  }, {
    "Description" : "Given a binary search tree and a node in it, find the in-order successor of that node in the BST.\n\nNote: If the given node has no in-order successor in the tree, return null.",
    "Difficulty" : "Medium",
    "Number" : "285",
    "Source" : "LeetCode",
    "Title" : "Inorder Successor in BST"
  }, {
    "Description" : "You are given a m x n 2D grid initialized with these three possible values.\n\n-1 - A wall or an obstacle.\n0 - A gate.\nINF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.\nFill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.\n\nFor example, given the 2D grid:\nINF  -1  0  INF\nINF INF INF  -1\nINF  -1 INF  -1\n  0  -1 INF INF\nAfter running your function, the 2D grid should be:\n  3  -1   0   1\n  2   2   1  -1\n  1  -1   2  -1\n  0  -1   3   4",
    "Difficulty" : "Medium",
    "Number" : "286",
    "Source" : "LeetCode",
    "Title" : "Walls and Gates"
  }, {
    "Description" : "Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\n\nNote:\nYou must not modify the array (assume the array is read only).\nYou must use only constant, O(1) extra space.\nYour runtime complexity should be less than O(n2).\nThere is only one duplicate number in the array, but it could be repeated more than once.",
    "Difficulty" : "Medium",
    "Number" : "287",
    "Source" : "LeetCode",
    "Title" : "Find the Duplicate Number"
  }, {
    "Description" : "An abbreviation of a word follows the form <first letter><number><last letter>. Below are some examples of word abbreviations:\n\na) it                      --> it    (no abbreviation)\n\n     1\nb) d|o|g                   --> d1g\n\n              1    1  1\n     1---5----0----5--8\nc) i|nternationalizatio|n  --> i18n\n\n              1\n     1---5----0\nd) l|ocalizatio|n          --> l10n\nAssume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word's abbreviation is unique if no other word from the dictionary has the same abbreviation.\n\nExample: \nGiven dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ]\n\nisUnique(\"dear\") -> \nfalse\n\nisUnique(\"cart\") -> \ntrue\n\nisUnique(\"cane\") -> \nfalse\n\nisUnique(\"make\") -> \ntrue",
    "Difficulty" : "Medium",
    "Number" : "288",
    "Source" : "LeetCode",
    "Title" : "Unique Word Abbreviation"
  }, {
    "Description" : "According to the Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\"\n\nGiven a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\nAny live cell with fewer than two live neighbors dies, as if caused by under-population.\nAny live cell with two or three live neighbors lives on to the next generation.\nAny live cell with more than three live neighbors dies, as if by over-population..\nAny dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\nWrite a function to compute the next state (after one update) of the board given its current state.\n\nFollow up: \nCould you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.\nIn this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?",
    "Difficulty" : "Medium",
    "Number" : "289",
    "Source" : "LeetCode",
    "Title" : "Game of Life"
  }, {
    "Description" : "Given a pattern and a string str, find if str follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.\n\nExamples:\npattern = \"abba\", str = \"dog cat cat dog\" should return true.\npattern = \"abba\", str = \"dog cat cat fish\" should return false.\npattern = \"aaaa\", str = \"dog cat cat dog\" should return false.\npattern = \"abba\", str = \"dog dog dog dog\" should return false.\nNotes:\nYou may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.",
    "Difficulty" : "Easy",
    "Number" : "290",
    "Source" : "LeetCode",
    "Title" : "Word Pattern"
  }, {
    "Description" : "Given a pattern and a string str, find if str follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty substring in str.\n\nExamples:\npattern = \"abab\", str = \"redblueredblue\" should return true.\npattern = \"aaaa\", str = \"asdasdasdasd\" should return true.\npattern = \"aabb\", str = \"xyzabcxzyabc\" should return false.",
    "Difficulty" : "Hard",
    "Number" : "291",
    "Source" : "LeetCode",
    "Title" : "Word Pattern II"
  }, {
    "Description" : "You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.\n\nBoth of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.\n\nFor example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.",
    "Difficulty" : "Easy",
    "Number" : "292",
    "Source" : "LeetCode",
    "Title" : "Nim Game"
  }, {
    "Description" : "You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive \"++\" into \"--\". The game ends when a person can no longer make a move and therefore the other person will be the winner.\n\nWrite a function to compute all possible states of the string after one valid move.\n\nFor example, given s = \"++++\", after one move, it may become one of the following states:\n\n[\n  \"--++\",\n  \"+--+\",\n  \"++--\"\n]\nIf there is no valid move, return an empty list [].",
    "Difficulty" : "Easy",
    "Number" : "293",
    "Source" : "LeetCode",
    "Title" : "Flip Game"
  }, {
    "Description" : "You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive \"++\" into \"--\". The game ends when a person can no longer make a move and therefore the other person will be the winner.\n\nWrite a function to determine if the starting player can guarantee a win.\n\nFor example, given s = \"++++\", return true. The starting player can guarantee a win by flipping the middle \"++\" to become \"+--+\".\n\nFollow up:\nDerive your algorithm's runtime complexity.",
    "Difficulty" : "Medium",
    "Number" : "294",
    "Source" : "LeetCode",
    "Title" : "Flip Game II"
  }, {
    "Description" : "Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\n\nExamples: \n[2,3,4] , the median is 3\n\n[2,3], the median is (2 + 3) / 2 = 2.5\n\nDesign a data structure that supports the following two operations:\n\nvoid addNum(int num) - Add a integer number from the data stream to the data structure.\ndouble findMedian() - Return the median of all elements so far.\nFor example:\n\naddNum(1)\naddNum(2)\nfindMedian() -> 1.5\naddNum(3) \nfindMedian() -> 2",
    "Difficulty" : "Hard",
    "Number" : "295",
    "Source" : "LeetCode",
    "Title" : "Find Median from Data Stream"
  }, {
    "Description" : "A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.\n\nFor example, given three people living at (0,0), (0,4), and (2,2):\n\n1 - 0 - 0 - 0 - 1\n|   |   |   |   |\n0 - 0 - 0 - 0 - 0\n|   |   |   |   |\n0 - 0 - 1 - 0 - 0\nThe point (0,2) is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6.",
    "Difficulty" : "Hard",
    "Number" : "296",
    "Source" : "LeetCode",
    "Title" : "Best Meeting Point"
  }, {
    "Description" : "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\n\nFor example, you may serialize the following tree\n\n    1\n   / \\\n  2   3\n     / \\\n    4   5\nas \"[1,2,3,null,null,4,5]\", just the same as how LeetCode OJ serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\nNote: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.",
    "Difficulty" : "Hard",
    "Number" : "297",
    "Source" : "LeetCode",
    "Title" : "Serialize and Deserialize Binary Tree"
  }, {
    "Description" : "Given a binary tree, find the length of the longest consecutive sequence path.\n\nThe path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path need to be from parent to child (cannot be the reverse).\n\nFor example,\n   1\n    \\\n     3\n    / \\\n   2   4\n        \\\n         5\nLongest consecutive sequence path is 3-4-5, so return 3.\n   2\n    \\\n     3\n    / \n   2    \n  / \n 1\nLongest consecutive sequence path is 2-3,not3-2-1, so return 2.",
    "Difficulty" : "Medium",
    "Number" : "298",
    "Source" : "LeetCode",
    "Title" : "Binary Tree Longest Consecutive Sequence"
  }, {
    "Description" : "You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called \"bulls\") and how many digits match the secret number but locate in the wrong position (called \"cows\"). Your friend will use successive guesses and hints to eventually derive the secret number.\n\nFor example:\n\nSecret number:  \"1807\"\nFriend's guess: \"7810\"\nHint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)\nWrite a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return \"1A3B\".\n\nPlease note that both secret number and friend's guess may contain duplicate digits, for example:\n\nSecret number:  \"1123\"\nFriend's guess: \"0111\"\nIn this case, the 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return \"1A1B\".\nYou may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.",
    "Difficulty" : "Medium",
    "Number" : "299",
    "Source" : "LeetCode",
    "Title" : "Bulls and Cows"
  }, {
    "Description" : "Given an unsorted array of integers, find the length of longest increasing subsequence.\n\nFor example,\nGiven [10, 9, 2, 5, 3, 7, 101, 18],\nThe longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.\n\nYour algorithm should run in O(n2) complexity.\n\nFollow up: Could you improve it to O(n log n) time complexity?",
    "Difficulty" : "Medium",
    "Number" : "300",
    "Source" : "LeetCode",
    "Title" : "Longest Increasing Subsequence"
  }, {
    "Description" : "Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\n\nNote: The input string may contain letters other than the parentheses ( and ).\n\nExamples:\n\"()())()\" -> [\"()()()\", \"(())()\"]\n\"(a)())()\" -> [\"(a)()()\", \"(a())()\"]\n\")(\" -> [\"\"]",
    "Difficulty" : "Hard",
    "Number" : "301",
    "Source" : "LeetCode",
    "Title" : "Remove Invalid Parentheses"
  }, {
    "Description" : "An image is represented by a binary matrix with 0 as a white pixel and 1 as a black pixel. The black pixels are connected, i.e., there is only one black region. Pixels are connected horizontally and vertically. Given the location (x, y) of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n\nFor example, given the following image:\n\n[\n  \"0010\",\n  \"0110\",\n  \"0100\"\n]\nand x = 0, y = 2,\nReturn 6.",
    "Difficulty" : "Hard",
    "Number" : "302",
    "Source" : "LeetCode",
    "Title" : "Smallest Rectangle Enclosing Black Pixels"
  }, {
    "Description" : "Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.\n\nExample:\nGiven nums = [-2, 0, 3, -5, 2, -1]\n\nsumRange(0, 2) -> 1\nsumRange(2, 5) -> -1\nsumRange(0, 5) -> -3\nNote:\nYou may assume that the array does not change.\nThere are many calls to sumRange function.",
    "Difficulty" : "Easy",
    "Number" : "303",
    "Source" : "LeetCode",
    "Title" : "Range Sum Query - Immutable"
  }, {
    "Description" : "Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).\n<img src=\"https://leetcode.com/static/images/courses/range_sum_query_2d.png\" />\n\nRange Sum Query 2D\nThe above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.\n\nExample:\nGiven matrix = [\n  [3, 0, 1, 4, 2],\n  [5, 6, 3, 2, 1],\n  [1, 2, 0, 1, 5],\n  [4, 1, 0, 1, 7],\n  [1, 0, 3, 0, 5]\n]\n\nsumRegion(2, 1, 4, 3) -> 8\nsumRegion(1, 1, 2, 2) -> 11\nsumRegion(1, 2, 2, 4) -> 12\nNote:\nYou may assume that the matrix does not change.\nThere are many calls to sumRegion function.\nYou may assume that row1 ≤ row2 and col1 ≤ col2.",
    "Difficulty" : "Medium",
    "Number" : "304",
    "Source" : "LeetCode",
    "Title" : "Range Sum Query 2D - Immutable"
  }, {
    "Description" : "A 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\nExample:\n\nGiven m = 3, n = 3, positions = [[0,0], [0,1], [1,2], [2,1]].\nInitially, the 2d grid grid is filled with water. (Assume 0 represents water and 1 represents land).\n\n0 0 0\n0 0 0\n0 0 0\nOperation #1: addLand(0, 0) turns the water at grid[0][0] into a land.\n\n1 0 0\n0 0 0   Number of islands = 1\n0 0 0\nOperation #2: addLand(0, 1) turns the water at grid[0][1] into a land.\n\n1 1 0\n0 0 0   Number of islands = 1\n0 0 0\nOperation #3: addLand(1, 2) turns the water at grid[1][2] into a land.\n\n1 1 0\n0 0 1   Number of islands = 2\n0 0 0\nOperation #4: addLand(2, 1) turns the water at grid[2][1] into a land.\n\n1 1 0\n0 0 1   Number of islands = 3\n0 1 0\nWe return the result as an array: [1, 1, 2, 3]\n\nChallenge:\n\nCan you do it in time complexity O(k log mn), where k is the length of the positions?",
    "Difficulty" : "Hard",
    "Number" : "305",
    "Source" : "LeetCode",
    "Title" : "Number of Islands II"
  }, {
    "Description" : "Additive number is a string whose digits can form additive sequence.\n\nA valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.\n\nFor example:\n\"112358\" is an additive number because the digits can form an additive sequence: 1, 1, 2, 3, 5, 8.\n\n1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\n\"199100199\" is also an additive number, the additive sequence is: 1, 99, 100, 199.\n1 + 99 = 100, 99 + 100 = 199\nNote: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.\n\nGiven a string containing only digits '0'-'9', write a function to determine if it's an additive number.\n\nFollow up:\nHow would you handle overflow for very large input integers?",
    "Difficulty" : "Medium",
    "Number" : "306",
    "Source" : "LeetCode",
    "Title" : "Additive Number"
  }, {
    "Description" : "Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.\n\nThe update(i, val) function modifies nums by updating the element at index i to val.\nExample:\nGiven nums = [1, 3, 5]\n\nsumRange(0, 2) -> 9\nupdate(1, 2)\nsumRange(0, 2) -> 8\nNote:\nThe array is only modifiable by the update function.\nYou may assume the number of calls to update and sumRange function is distributed evenly.",
    "Difficulty" : "Medium",
    "Number" : "307",
    "Source" : "LeetCode",
    "Title" : "Range Sum Query - Mutable"
  }, {
    "Description" : "Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).\n\n<img src=\"https://leetcode.com/static/images/courses/range_sum_query_2d.png\" />\n\nRange Sum Query 2D\nThe above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.\n\nExample:\nGiven matrix = [\n  [3, 0, 1, 4, 2],\n  [5, 6, 3, 2, 1],\n  [1, 2, 0, 1, 5],\n  [4, 1, 0, 1, 7],\n  [1, 0, 3, 0, 5]\n]\n\nsumRegion(2, 1, 4, 3) -> 8\nupdate(3, 2, 2)\nsumRegion(2, 1, 4, 3) -> 10\nNote:\nThe matrix is only modifiable by the update function.\nYou may assume the number of calls to update and sumRegion function is distributed evenly.\nYou may assume that row1 ≤ row2 and col1 ≤ col2.",
    "Difficulty" : "Hard",
    "Number" : "308",
    "Source" : "LeetCode",
    "Title" : "Range Sum Query 2D - Mutable"
  }, {
    "Description" : "Say you have an array for which the ith element is the price of a given stock on day i.\n\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:\n\nYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\nAfter you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)\nExample:\n\nprices = [1, 2, 3, 0, 2]\nmaxProfit = 3\ntransactions = [buy, sell, cooldown, buy, sell]",
    "Difficulty" : "Medium",
    "Number" : "309",
    "Source" : "LeetCode",
    "Title" : "Best Time to Buy and Sell Stock with Cooldown"
  }, {
    "Description" : "For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.\n\nFormat\nThe graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels).\n\nYou can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.\n\nExample 1:\n\nGiven n = 4, edges = [[1, 0], [1, 2], [1, 3]]\n\n        0\n        |\n        1\n       / \\\n      2   3\nreturn [1]\n\nExample 2:\n\nGiven n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]\n\n     0  1  2\n      \\ | /\n        3\n        |\n        4\n        |\n        5\nreturn [3, 4]\n\nShow Hint \nNote:\n\n(1) According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”\n\n(2) The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.",
    "Difficulty" : "Medium",
    "Number" : "310",
    "Source" : "LeetCode",
    "Title" : "Minimum Height Trees"
  }, {
    "Description" : "Given two sparse matrices A and B, return the result of AB.\n\nYou may assume that A's column number is equal to B's row number.\n\nExample:\n\nA = [\n  [ 1, 0, 0],\n  [-1, 0, 3]\n]\n\nB = [\n  [ 7, 0, 0 ],\n  [ 0, 0, 0 ],\n  [ 0, 0, 1 ]\n]\n\n\n     |  1 0 0 |   | 7 0 0 |   |  7 0 0 |\nAB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |\n                  | 0 0 1 |",
    "Difficulty" : "Medium",
    "Number" : "311",
    "Source" : "LeetCode",
    "Title" : "Sparse Matrix Multiplication"
  }, {
    "Description" : "Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.\n\nFind the maximum coins you can collect by bursting the balloons wisely.\n\nNote: \n(1) You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.\n(2) 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100\n\nExample:\n\nGiven [3, 1, 5, 8]\n\nReturn 167\n\n    nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\n   coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167\n",
    "Difficulty" : "Hard",
    "Number" : "312",
    "Source" : "LeetCode",
    "Title" : "Burst Balloons"
  }, {
    "Description" : "Write a program to find the nth super ugly number.\n\nSuper ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32] is the sequence of the first 12 super ugly numbers given primes = [2, 7, 13, 19] of size 4.\n\nNote:\n(1) 1 is a super ugly number for any given primes.\n(2) The given numbers in primes are in ascending order.\n(3) 0 < k ≤ 100, 0 < n ≤ 106, 0 < primes[i] < 1000.\n(4) The nth super ugly number is guaranteed to fit in a 32-bit signed integer.",
    "Difficulty" : "Medium",
    "Number" : "313",
    "Source" : "LeetCode",
    "Title" : "Super Ugly Number"
  }, {
    "Description" : "Given a binary tree, return the vertical order traversal of its nodes' values. (ie, from top to bottom, column by column).\n\nIf two nodes are in the same row and column, the order should be from left to right.\n\nExamples:\n\nGiven binary tree [3,9,20,null,null,15,7],\n   3\n  /\\\n /  \\\n 9  20\n    /\\\n   /  \\\n  15   7\nreturn its vertical order traversal as:\n[\n  [9],\n  [3,15],\n  [20],\n  [7]\n]\nGiven binary tree [3,9,8,4,0,1,7],\n     3\n    /\\\n   /  \\\n   9   8\n  /\\  /\\\n /  \\/  \\\n 4  01   7\nreturn its vertical order traversal as:\n[\n  [4],\n  [9],\n  [3,0,1],\n  [8],\n  [7]\n]\nGiven binary tree [3,9,8,4,0,1,7,null,null,null,2,5] (0's right child is 2 and 1's left child is 5),\n     3\n    /\\\n   /  \\\n   9   8\n  /\\  /\\\n /  \\/  \\\n 4  01   7\n    /\\\n   /  \\\n   5   2\nreturn its vertical order traversal as:\n[\n  [4],\n  [9,5],\n  [3,0,1],\n  [8,2],\n  [7]\n]",
    "Difficulty" : "Medium",
    "Number" : "314",
    "Source" : "LeetCode",
    "Title" : "Binary Tree Vertical Order Traversal"
  }, {
    "Description" : "You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].\n\nExample:\n\nGiven nums = [5, 2, 6, 1]\n\nTo the right of 5 there are 2 smaller elements (2 and 1).\nTo the right of 2 there is only 1 smaller element (1).\nTo the right of 6 there is 1 smaller element (1).\nTo the right of 1 there is 0 smaller element.\nReturn the array [2, 1, 1, 0].",
    "Difficulty" : "Hard",
    "Number" : "315",
    "Source" : "LeetCode",
    "Title" : "Count of Smaller Numbers After Self"
  }, {
    "Description" : "Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\n\nExample:\nGiven \"bcabc\"\nReturn \"abc\"\n\nGiven \"cbacdcbc\"\nReturn \"acdb\"",
    "Difficulty" : "Hard",
    "Number" : "316",
    "Source" : "LeetCode",
    "Title" : "Remove Duplicate Letters"
  }, {
    "Description" : "You want to build a house on an empty land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values 0, 1 or 2, where:\n\nEach 0 marks an empty land which you can pass by freely.\nEach 1 marks a building which you cannot pass through.\nEach 2 marks an obstacle which you cannot pass through.\nFor example, given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2):\n\n1 - 0 - 2 - 0 - 1\n|   |   |   |   |\n0 - 0 - 0 - 0 - 0\n|   |   |   |   |\n0 - 0 - 1 - 0 - 0\nThe point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7.\n\nNote:\nThere will be at least one building. If it is not possible to build such house according to the above rules, return -1.",
    "Difficulty" : "Hard",
    "Number" : "317",
    "Source" : "LeetCode",
    "Title" : "Shortest Distance from All Buildings"
  }, {
    "Description" : "Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.\n\nExample 1:\nGiven [\"abcw\", \"baz\", \"foo\", \"bar\", \"xtfn\", \"abcdef\"]\nReturn 16\nThe two words can be \"abcw\", \"xtfn\".\n\nExample 2:\nGiven [\"a\", \"ab\", \"abc\", \"d\", \"cd\", \"bcd\", \"abcd\"]\nReturn 4\nThe two words can be \"ab\", \"cd\".\n\nExample 3:\nGiven [\"a\", \"aa\", \"aaa\", \"aaaa\"]\nReturn 0\nNo such pair of words.",
    "Difficulty" : "Medium",
    "Number" : "318",
    "Source" : "LeetCode",
    "Title" : "Maximum Product of Word Lengths"
  }, {
    "Description" : "There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.\n\nExample:\n\nGiven n = 3. \n\nAt first, the three bulbs are [off, off, off].\nAfter first round, the three bulbs are [on, on, on].\nAfter second round, the three bulbs are [on, off, on].\nAfter third round, the three bulbs are [on, off, off]. \n\nSo you should return 1, because there is only one bulb is on.",
    "Difficulty" : "Medium",
    "Number" : "319",
    "Source" : "LeetCode",
    "Title" : "Bulb Switcher"
  }, {
    "Description" : "Write a function to generate the generalized abbreviations of a word.\n\nExample:\nGiven word = \"word\", return the following list (order does not matter):\n[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]",
    "Difficulty" : "Medium",
    "Number" : "320",
    "Source" : "LeetCode",
    "Title" : "Generalized Abbreviation"
  }, {
    "Description" : "Given two arrays of length m and n with digits 0-9 representing two numbers. Create the maximum number of length k <= m + n from digits of the two. The relative order of the digits from the same array must be preserved. Return an array of the k digits. You should try to optimize your time and space complexity.\n\nExample 1:\nnums1 = [3, 4, 6, 5]\nnums2 = [9, 1, 2, 5, 8, 3]\nk = 5\nreturn [9, 8, 6, 5, 3]\n\nExample 2:\nnums1 = [6, 7]\nnums2 = [6, 0, 4]\nk = 5\nreturn [6, 7, 6, 0, 4]\n\nExample 3:\nnums1 = [3, 9]\nnums2 = [8, 9]\nk = 3\nreturn [9, 8, 9]",
    "Difficulty" : "Hard",
    "Number" : "321",
    "Source" : "LeetCode",
    "Title" : "Create Maximum Number"
  }, {
    "Description" : "You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n\nExample 1:\ncoins = [1, 2, 5], amount = 11\nreturn 3 (11 = 5 + 5 + 1)\n\nExample 2:\ncoins = [2], amount = 3\nreturn -1.\n\nNote:\nYou may assume that you have an infinite number of each kind of coin.",
    "Difficulty" : "Medium",
    "Number" : "322",
    "Source" : "LeetCode",
    "Title" : "Coin Change"
  }, {
    "Description" : "Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.\n\nExample 1:\n     0          3\n     |          |\n     1 --- 2    4\nGiven n = 5 and edges = [[0, 1], [1, 2], [3, 4]], return 2.\n\nExample 2:\n     0           4\n     |           |\n     1 --- 2 --- 3\nGiven n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]], return 1.\n\nNote:\nYou can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.",
    "Difficulty" : "Medium",
    "Number" : "323",
    "Source" : "LeetCode",
    "Title" : "Number of Connected Components in an Undirected Graph"
  }, {
    "Description" : "Given an unsorted array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....\n\nExample:\n(1) Given nums = [1, 5, 1, 1, 6, 4], one possible answer is [1, 4, 1, 5, 1, 6]. \n(2) Given nums = [1, 3, 2, 2, 3, 1], one possible answer is [2, 3, 1, 3, 1, 2].\n\nNote:\nYou may assume all input has valid answer.\n\nFollow Up:\nCan you do it in O(n) time and/or in-place with O(1) extra space?",
    "Difficulty" : "Medium",
    "Number" : "324",
    "Source" : "LeetCode",
    "Title" : "Wiggle Sort II"
  }, {
    "Description" : "Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn't one, return 0 instead.\n\nNote:\nThe sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range.\n\nExample 1:\nGiven nums = [1, -1, 5, -2, 3], k = 3,\nreturn 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest)\n\nExample 2:\nGiven nums = [-2, -1, 2, 1], k = 1,\nreturn 2. (because the subarray [-1, 2] sums to 1 and is the longest)\n\nFollow Up:\nCan you do it in O(n) time?",
    "Difficulty" : "Medium",
    "Number" : "325",
    "Source" : "LeetCode",
    "Title" : "Maximum Size Subarray Sum Equals k"
  }, {
    "Description" : "Given an integer, write a function to determine if it is a power of three.\n\nFollow up:\nCould you do it without using any loop / recursion?",
    "Difficulty" : "Easy",
    "Number" : "326",
    "Source" : "LeetCode",
    "Title" : "Power of Three"
  }, {
    "Description" : "Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive.\nRange sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive.\n\nNote:\nA naive algorithm of O(n2) is trivial. You MUST do better than that.\n\nExample:\nGiven nums = [-2, 5, -1], lower = -2, upper = 2,\nReturn 3.\nThe three ranges are : [0, 0], [2, 2], [0, 2] and their respective sums are: -2, -1, 2.",
    "Difficulty" : "Hard",
    "Number" : "327",
    "Source" : "LeetCode",
    "Title" : "Count of Range Sum"
  }, {
    "Description" : "Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.\n\nYou should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.\n\nExample:\nGiven 1->2->3->4->5->NULL,\nreturn 1->3->5->2->4->NULL.\n\nNote:\nThe relative order inside both the even and odd groups should remain as it was in the input. \nThe first node is considered odd, the second node even and so on ...",
    "Difficulty" : "Medium",
    "Number" : "328",
    "Source" : "LeetCode",
    "Title" : "Odd Even Linked List"
  }, {
    "Description" : "Given an integer matrix, find the length of the longest increasing path.\n\nFrom each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).\n\nExample 1:\n\nnums = [\n  [9,9,4],\n  [6,6,8],\n  [2,1,1]\n]\nReturn 4\nThe longest increasing path is [1, 2, 6, 9].\n\nExample 2:\n\nnums = [\n  [3,4,5],\n  [3,2,6],\n  [2,2,1]\n]\nReturn 4\nThe longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.",
    "Difficulty" : "Hard",
    "Number" : "329",
    "Source" : "LeetCode",
    "Title" : "Longest Increasing Path in a Matrix"
  }, {
    "Description" : "Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.\n\nExample 1:\nnums = [1, 3], n = 6\nReturn 1.\n\nCombinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.\nNow if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].\nPossible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].\nSo we only need 1 patch.\n\nExample 2:\nnums = [1, 5, 10], n = 20\nReturn 2.\nThe two patches can be [2, 4].\n\nExample 3:\nnums = [1, 2, 2], n = 5\nReturn 0.",
    "Difficulty" : "Hard",
    "Number" : "330",
    "Source" : "LeetCode",
    "Title" : "Patching Array"
  }, {
    "Description" : "One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as #.\n\n     _9_\n    /   \\\n   3     2\n  / \\   / \\\n 4   1  #  6\n/ \\ / \\   / \\\n# # # #   # #\nFor example, the above binary tree can be serialized to the string \"9,3,4,#,#,1,#,#,2,#,6,#,#\", where # represents a null node.\n\nGiven a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.\n\nEach comma separated value in the string must be either an integer or a character '#' representing null pointer.\n\nYou may assume that the input format is always valid, for example it could never contain two consecutive commas such as \"1,,3\".\n\nExample 1:\n\"9,3,4,#,#,1,#,#,2,#,6,#,#\"\nReturn true\n\nExample 2:\n\"1,#\"\nReturn false\n\nExample 3:\n\"9,#,#,1\"\nReturn false",
    "Difficulty" : "Medium",
    "Number" : "331",
    "Source" : "LeetCode",
    "Title" : "Verify Preorder Serialization of a Binary Tree"
  }, {
    "Description" : "Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.\n\nNote:\nIf there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [\"JFK\", \"LGA\"] has a smaller lexical order than [\"JFK\", \"LGB\"].\nAll airports are represented by three capital letters (IATA code).\nYou may assume all tickets form at least one valid itinerary.\nExample 1:\ntickets = [[\"MUC\", \"LHR\"], [\"JFK\", \"MUC\"], [\"SFO\", \"SJC\"], [\"LHR\", \"SFO\"]]\nReturn [\"JFK\", \"MUC\", \"LHR\", \"SFO\", \"SJC\"].\nExample 2:\ntickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\nReturn [\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"].\nAnother possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"]. But it is larger in lexical order.",
    "Difficulty" : "Medium",
    "Number" : "332",
    "Source" : "LeetCode",
    "Title" : "Reconstruct Itinerary"
  }, {
    "Description" : "Given a binary tree, find the largest subtree which is a Binary Search Tree (BST), where largest means subtree with largest number of nodes in it.\n\nNote:\nA subtree must include all of its descendants.\nHere's an example:\n    10\n    / \\\n   5  15\n  / \\   \\ \n 1   8   7\nThe Largest BST Subtree in this case is the highlighted one. \nThe return value is the subtree's size, which is 3.",
    "Difficulty" : "Medium",
    "Number" : "333",
    "Source" : "LeetCode",
    "Title" : "Largest BST Subtree"
  }, {
    "Description" : "Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.\n\nFormally the function should:\nReturn true if there exists i, j, k \nsuch that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 else return false.\nYour algorithm should run in O(n) time complexity and O(1) space complexity.\n\nExamples:\nGiven [1, 2, 3, 4, 5],\nreturn true.\n\nGiven [5, 4, 3, 2, 1],\nreturn false.",
    "Difficulty" : "Medium",
    "Number" : "334",
    "Source" : "LeetCode",
    "Title" : "Increasing Triplet Subsequence"
  }, {
    "Description" : "You are given an array x of n positive numbers. You start at point (0,0) and moves x[0] metres to the north, then x[1] metres to the west, x[2] metres to the south, x[3] metres to the east and so on. In other words, after each move your direction changes counter-clockwise.\n\nWrite a one-pass algorithm with O(1) extra space to determine, if your path crosses itself, or not.\n\nExample 1:\nGiven x = \n[2, 1, 1, 2]\n,\n┌───┐\n│   │\n└───┼──>\n    │\n\nReturn true (self crossing)\nExample 2:\nGiven x = \n[1, 2, 3, 4]\n,\n┌──────┐\n│      │\n│\n│\n└────────────>\n\nReturn false (not self crossing)\nExample 3:\nGiven x = \n[1, 1, 1, 1]\n,\n┌───┐\n│   │\n└───┼>\n\nReturn true (self crossing)\n",
    "Difficulty" : "Hard",
    "Number" : "335",
    "Source" : "LeetCode",
    "Title" : "Self Crossing"
  }, {
    "Description" : "Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.\n\nExample 1:\nGiven words = [\"bat\", \"tab\", \"cat\"]\nReturn [[0, 1], [1, 0]]\nThe palindromes are [\"battab\", \"tabbat\"]\nExample 2:\nGiven words = [\"abcd\", \"dcba\", \"lls\", \"s\", \"sssll\"]\nReturn [[0, 1], [1, 0], [3, 2], [2, 4]]\nThe palindromes are [\"dcbaabcd\", \"abcddcba\", \"slls\", \"llssssll\"]",
    "Difficulty" : "Hard",
    "Number" : "336",
    "Source" : "LeetCode",
    "Title" : "Palindrome Pairs"
  }, {
    "Description" : "The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \"root.\" Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \"all houses in this place forms a binary tree\". It will automatically contact the police if two directly-linked houses were broken into on the same night.\n\nDetermine the maximum amount of money the thief can rob tonight without alerting the police.\n\nExample 1:\n     3\n    / \\\n   2   3\n    \\   \\ \n     3   1\nMaximum amount of money the thief can rob = 3 + 3 + 1 = 7.\nExample 2:\n     3\n    / \\\n   4   5\n  / \\   \\ \n 1   3   1\nMaximum amount of money the thief can rob = 4 + 5 = 9.",
    "Difficulty" : "Medium",
    "Number" : "337",
    "Source" : "LeetCode",
    "Title" : "House Robber III"
  }, {
    "Description" : "Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.\n\nExample:\nFor num = 5 you should return [0,1,1,2,1,2].\n\nFollow up:\n\nIt is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?\nSpace complexity should be O(n).\nCan you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.",
    "Difficulty" : "Medium",
    "Number" : "338",
    "Source" : "LeetCode",
    "Title" : "Counting Bits"
  }, {
    "Description" : "Given a nested list of integers, return the sum of all integers in the list weighted by their depth.\n\nEach element is either an integer, or a list -- whose elements may also be integers or other lists.\n\nExample 1:\nGiven the list [[1,1],2,[1,1]], return 10. (four 1's at depth 2, one 2 at depth 1)\n\nExample 2:\nGiven the list [1,[4,[6]]], return 27. (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4*2 + 6*3 = 27)",
    "Difficulty" : "Easy",
    "Number" : "339",
    "Source" : "LeetCode",
    "Title" : "Nested List Weight Sum"
  }, {
    "Description" : "Given a string, find the length of the longest substring T that contains at most k distinct characters.\n\nFor example, Given s = “eceba” and k = 2,\n\nT is \"ece\" which its length is 3.",
    "Difficulty" : "Hard",
    "Number" : "340",
    "Source" : "LeetCode",
    "Title" : "Longest Substring with At Most K Distinct Characters"
  }, {
    "Description" : "Given a nested list of integers, implement an iterator to flatten it.\n\nEach element is either an integer, or a list -- whose elements may also be integers or other lists.\n\nExample 1:\nGiven the list [[1,1],2,[1,1]],\n\nBy calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].\n\nExample 2:\nGiven the list [1,[4,[6]]],\n\nBy calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].",
    "Difficulty" : "Medium",
    "Number" : "341",
    "Source" : "LeetCode",
    "Title" : "Flatten Nested List Iterator"
  }, {
    "Description" : "Given an integer (signed 32 bits), write a function to check whether it is a power of 4.\n\nExample:\nGiven num = 16, return true. Given num = 5, return false.\n\nFollow up: Could you solve it without loops/recursion?",
    "Difficulty" : "Easy",
    "Number" : "342",
    "Source" : "LeetCode",
    "Title" : "Power of Four"
  }, {
    "Description" : "Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.\n\nFor example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).\n\nNote: You may assume that n is not less than 2 and not larger than 58.",
    "Difficulty" : "Medium",
    "Number" : "343",
    "Source" : "LeetCode",
    "Title" : "Integer Break"
  }, {
    "Description" : "Write a function that takes a string as input and returns the string reversed.\n\nExample:\nGiven s = \"hello\", return \"olleh\".",
    "Difficulty" : "Easy",
    "Number" : "344",
    "Source" : "LeetCode",
    "Title" : "Reverse String"
  }, {
    "Description" : "Write a function that takes a string as input and reverse only the vowels of a string.\n\nExample 1:\nGiven s = \"hello\", return \"holle\".\n\nExample 2:\nGiven s = \"leetcode\", return \"leotcede\".\n\nNote:\nThe vowels does not include the letter \"y\".",
    "Difficulty" : "Easy",
    "Number" : "345",
    "Source" : "LeetCode",
    "Title" : "Reverse Vowels of a String"
  }, {
    "Description" : "Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.\n\nFor example,\nMovingAverage m = new MovingAverage(3);\nm.next(1) = 1\nm.next(10) = (1 + 10) / 2\nm.next(3) = (1 + 10 + 3) / 3\nm.next(5) = (10 + 3 + 5) / 3",
    "Difficulty" : "Easy",
    "Number" : "346",
    "Source" : "LeetCode",
    "Title" : "Moving Average from Data Stream"
  }, {
    "Description" : "Given a non-empty array of integers, return the k most frequent elements.\n\nFor example,\nGiven [1,1,1,2,2,3] and k = 2, return [1,2].\n\nNote: \nYou may assume k is always valid, 1 ≤ k ≤ number of unique elements.\nYour algorithm's time complexity must be better than O(n log n), where n is the array's size.",
    "Difficulty" : "Medium",
    "Number" : "347",
    "Source" : "LeetCode",
    "Title" : "Top K Frequent Elements"
  }, {
    "Description" : "Design a Tic-tac-toe game that is played between two players on a n x n grid.\n\nYou may assume the following rules:\n\nA move is guaranteed to be valid and is placed on an empty block.\nOnce a winning condition is reached, no more moves is allowed.\nA player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game.\nExample:\nGiven n = 3, assume that player 1 is \"X\" and player 2 is \"O\" in the board.\n\nTicTacToe toe = new TicTacToe(3);\n\ntoe.move(0, 0, 1); -> Returns 0 (no one wins)\n|X| | |\n| | | |    // Player 1 makes a move at (0, 0).\n| | | |\n\ntoe.move(0, 2, 2); -> Returns 0 (no one wins)\n|X| |O|\n| | | |    // Player 2 makes a move at (0, 2).\n| | | |\n\ntoe.move(2, 2, 1); -> Returns 0 (no one wins)\n|X| |O|\n| | | |    // Player 1 makes a move at (2, 2).\n| | |X|\n\ntoe.move(1, 1, 2); -> Returns 0 (no one wins)\n|X| |O|\n| |O| |    // Player 2 makes a move at (1, 1).\n| | |X|\n\ntoe.move(2, 0, 1); -> Returns 0 (no one wins)\n|X| |O|\n| |O| |    // Player 1 makes a move at (2, 0).\n|X| |X|\n\ntoe.move(1, 0, 2); -> Returns 0 (no one wins)\n|X| |O|\n|O|O| |    // Player 2 makes a move at (1, 0).\n|X| |X|\n\ntoe.move(2, 1, 1); -> Returns 1 (player 1 wins)\n|X| |O|\n|O|O| |    // Player 1 makes a move at (2, 1).\n|X|X|X|\nFollow up:\nCould you do better than O(n2) per move() operation?",
    "Difficulty" : "Medium",
    "Number" : "348",
    "Source" : "LeetCode",
    "Title" : "Design Tic-Tac-Toe"
  }, {
    "Description" : "Given two arrays, write a function to compute their intersection.\n\nExample:\nGiven nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].\n\nNote:\nEach element in the result must be unique.\nThe result can be in any order.",
    "Difficulty" : "Easy",
    "Number" : "349",
    "Source" : "LeetCode",
    "Title" : "Intersection of Two Arrays"
  }, {
    "Description" : "Given two arrays, write a function to compute their intersection.\n\nExample:\nGiven nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].\n\nNote:\nEach element in the result should appear as many times as it shows in both arrays.\nThe result can be in any order.\nFollow up:\nWhat if the given array is already sorted? How would you optimize your algorithm?\nWhat if nums1's size is small compared to nums2's size? Which algorithm is better?\nWhat if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?",
    "Difficulty" : "Easy",
    "Number" : "350",
    "Source" : "LeetCode",
    "Title" : "Intersection of Two Arrays II"
  }, {
    "Description" : "Given an Android 3x3 key lock screen and two integers m and n, where 1 ≤ m ≤ n ≤ 9, count the total number of unlock patterns of the Android lock screen, which consist of minimum of m keys and maximum n keys.\n\n\nRules for a valid pattern:\nEach pattern must connect at least m keys and at most n keys.\nAll the keys must be distinct.\nIf the line connecting two consecutive keys in the pattern passes through any other keys, the other keys must have previously selected in the pattern. No jumps through non selected key is allowed.\nThe order of keys used matters.\n\n<img src=\"https://discuss.leetcode.com/uploads/files/1461680355228-cptqh.png\" />\n\nExplanation:\n| 1 | 2 | 3 |\n| 4 | 5 | 6 |\n| 7 | 8 | 9 |\nInvalid move: 4 - 1 - 3 - 6 \nLine 1 - 3 passes through key 2 which had not been selected in the pattern.\n\nInvalid move: 4 - 1 - 9 - 2\nLine 1 - 9 passes through key 5 which had not been selected in the pattern.\n\nValid move: 2 - 4 - 1 - 3 - 6\nLine 1 - 3 is valid because it passes through key 2, which had been selected in the pattern\n\nValid move: 6 - 5 - 4 - 1 - 9 - 2\nLine 1 - 9 is valid because it passes through key 5, which had been selected in the pattern.\n\nExample:\nGiven m = 1, n = 1, return 9.",
    "Difficulty" : "Medium",
    "Number" : "351",
    "Source" : "LeetCode",
    "Title" : "Android Unlock Patterns"
  }, {
    "Description" : "Given a data stream input of non-negative integers a1, a2, ..., an, ..., summarize the numbers seen so far as a list of disjoint intervals.\n\nFor example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be:\n\n[1, 1]\n[1, 1], [3, 3]\n[1, 1], [3, 3], [7, 7]\n[1, 3], [7, 7]\n[1, 3], [6, 7]\nFollow up:\nWhat if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size?",
    "Difficulty" : "Hard",
    "Number" : "352",
    "Source" : "LeetCode",
    "Title" : "Data Stream as Disjoint Intervals"
  }, {
    "Description" : "Design a Snake game that is played on a device with screen size = width x height. Play the game online if you are not familiar with the game.\n\nThe snake is initially positioned at the top left corner (0,0) with length = 1 unit.\n\nYou are given a list of food's positions in row-column order. When a snake eats the food, its length and the game's score both increase by 1.\n\nEach food appears one by one on the screen. For example, the second food will not appear until the first food was eaten by the snake.\n\nWhen a food does appear on the screen, it is guaranteed that it will not appear on a block occupied by the snake.\n\nExample:\nGiven width = 3, height = 2, and food = [[1,2],[0,1]].\n\nSnake snake = new Snake(width, height, food);\n\nInitially the snake appears at position (0,0) and the food at (1,2).\n\n|S| | |\n| | |F|\n\nsnake.move(\"R\"); -> Returns 0\n\n| |S| |\n| | |F|\n\nsnake.move(\"D\"); -> Returns 0\n\n| | | |\n| |S|F|\n\nsnake.move(\"R\"); -> Returns 1 (Snake eats the first food and right after that, the second food appears at (0,1) )\n\n| |F| |\n| |S|S|\n\nsnake.move(\"U\"); -> Returns 1\n\n| |F|S|\n| | |S|\n\nsnake.move(\"L\"); -> Returns 2 (Snake eats the second food)\n\n| |S|S|\n| | |S|\n\nsnake.move(\"U\"); -> Returns -1 (Game over because snake collides with border)\n",
    "Difficulty" : "Medium",
    "Number" : "353",
    "Source" : "LeetCode",
    "Title" : "Design Snake Game"
  }, {
    "Description" : "You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.\n\nWhat is the maximum number of envelopes can you Russian doll? (put one inside other)\n\nExample:\nGiven envelopes = [[5,4],[6,4],[6,7],[2,3]], the maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).",
    "Difficulty" : "Hard",
    "Number" : "354",
    "Source" : "LeetCode",
    "Title" : "Russian Doll Envelopes"
  }, {
    "Description" : "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods:\n\npostTweet(userId, tweetId): Compose a new tweet.\ngetNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\nfollow(followerId, followeeId): Follower follows a followee.\nunfollow(followerId, followeeId): Follower unfollows a followee.\nExample:\n\nTwitter twitter = new Twitter();\n\n// User 1 posts a new tweet (id = 5).\ntwitter.postTweet(1, 5);\n\n// User 1's news feed should return a list with 1 tweet id -> [5].\ntwitter.getNewsFeed(1);\n\n// User 1 follows user 2.\ntwitter.follow(1, 2);\n\n// User 2 posts a new tweet (id = 6).\ntwitter.postTweet(2, 6);\n\n// User 1's news feed should return a list with 2 tweet ids -> [6, 5].\n// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\ntwitter.getNewsFeed(1);\n\n// User 1 unfollows user 2.\ntwitter.unfollow(1, 2);\n\n// User 1's news feed should return a list with 1 tweet id -> [5],\n// since user 1 is no longer following user 2.\ntwitter.getNewsFeed(1);",
    "Difficulty" : "Medium",
    "Number" : "355",
    "Source" : "LeetCode",
    "Title" : "Design Twitter"
  }, {
    "Description" : "Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points.\n\nExample 1:\nGiven points = [[1,1],[-1,1]], return true.\n\nExample 2:\nGiven points = [[1,1],[-1,-1]], return false.\n\nFollow up:\nCould you do better than O(n2)?",
    "Difficulty" : "Medium",
    "Number" : "356",
    "Source" : "LeetCode",
    "Title" : "Line Reflection"
  }, {
    "Description" : "Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x < 10n.\n\nExample:\nGiven n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x < 100, excluding [11,22,33,44,55,66,77,88,99])",
    "Difficulty" : "Medium",
    "Number" : "357",
    "Source" : "LeetCode",
    "Title" : "Count Numbers with Unique Digits"
  }, {
    "Description" : "Given a non-empty string s and an integer k, rearrange the string such that the same characters are at least distance k from each other.\n\nAll input strings are given in lowercase letters. If it is not possible to rearrange the string, return an empty string \"\".\n\nExample 1:\ns = \"aabbcc\", k = 3\n\nResult: \"abcabc\"\n\nThe same letters are at least distance 3 from each other.\nExample 2:\ns = \"aaabc\", k = 3 \n\nAnswer: \"\"\n\nIt is not possible to rearrange the string.\nExample 3:\ns = \"aaadbbcc\", k = 2\n\nAnswer: \"abacabcd\"\n\nAnother possible answer is: \"abcabcda\"\n\nThe same letters are at least distance 2 from each other.",
    "Difficulty" : "Hard",
    "Number" : "358",
    "Source" : "LeetCode",
    "Title" : "Rearrange String k Distance Apart"
  }, {
    "Description" : "Design a logger system that receive stream of messages along with its timestamps, each message should be printed if and only if it is not printed in the last 10 seconds.\n\nGiven a message and a timestamp (in seconds granularity), return true if the message should be printed in the given timestamp, otherwise returns false.\n\nIt is possible that several messages arrive roughly at the same time.\n\nExample:\n\nLogger logger = new Logger();\n\n// logging string \"foo\" at timestamp 1\nlogger.shouldPrintMessage(1, \"foo\"); returns true; \n\n// logging string \"bar\" at timestamp 2\nlogger.shouldPrintMessage(2,\"bar\"); returns true;\n\n// logging string \"foo\" at timestamp 3\nlogger.shouldPrintMessage(3,\"foo\"); returns false;\n\n// logging string \"bar\" at timestamp 8\nlogger.shouldPrintMessage(8,\"bar\"); returns false;\n\n// logging string \"foo\" at timestamp 10\nlogger.shouldPrintMessage(10,\"foo\"); returns false;\n\n// logging string \"foo\" at timestamp 11\nlogger.shouldPrintMessage(11,\"foo\"); returns true;",
    "Difficulty" : "Easy",
    "Number" : "359",
    "Source" : "LeetCode",
    "Title" : "Logger Rate Limiter"
  }, {
    "Description" : "Given a sorted array of integers nums and integer values a, b and c. Apply a function of the form f(x) = ax2 + bx + c to each element x in the array.\n\nThe returned array must be in sorted order.\n\nExpected time complexity: O(n)\n\nExample:\nnums = [-4, -2, 2, 4], a = 1, b = 3, c = 5,\n\nResult: [3, 9, 15, 33]\n\nnums = [-4, -2, 2, 4], a = -1, b = 3, c = 5\n\nResult: [-23, -5, 1, 7]",
    "Difficulty" : "Medium",
    "Number" : "360",
    "Source" : "LeetCode",
    "Title" : "Sort Transformed Array"
  }, {
    "Description" : "Given a 2D grid, each cell is either a wall 'W', an enemy 'E' or empty '0' (the number zero), return the maximum enemies you can kill using one bomb.\nThe bomb kills all the enemies in the same row and column from the planted point until it hits the wall since the wall is too strong to be destroyed.\nNote that you can only put the bomb at an empty cell.\n\nExample:\nFor the given grid\n\n0 E 0 0\nE 0 W E\n0 E 0 0\n\nreturn 3. (Placing a bomb at (1,1) kills 3 enemies)",
    "Difficulty" : "Medium",
    "Number" : "361",
    "Source" : "LeetCode",
    "Title" : "Bomb Enemy"
  }, {
    "Description" : "Design a hit counter which counts the number of hits received in the past 5 minutes.\n\nEach function accepts a timestamp parameter (in seconds granularity) and you may assume that calls are being made to the system in chronological order (ie, the timestamp is monotonically increasing). You may assume that the earliest timestamp starts at 1.\n\nIt is possible that several hits arrive roughly at the same time.\n\nExample:\nHitCounter counter = new HitCounter();\n\n// hit at timestamp 1.\ncounter.hit(1);\n\n// hit at timestamp 2.\ncounter.hit(2);\n\n// hit at timestamp 3.\ncounter.hit(3);\n\n// get hits at timestamp 4, should return 3.\ncounter.getHits(4);\n\n// hit at timestamp 300.\ncounter.hit(300);\n\n// get hits at timestamp 300, should return 4.\ncounter.getHits(300);\n\n// get hits at timestamp 301, should return 3.\ncounter.getHits(301); \nFollow up:\nWhat if the number of hits per second could be very large? Does your design scale?",
    "Difficulty" : "Medium",
    "Number" : "362",
    "Source" : "LeetCode",
    "Title" : "Design Hit Counter"
  }, {
    "Description" : "Given a non-empty 2D matrix matrix and an integer k, find the max sum of a rectangle in the matrix such that its sum is no larger than k.\n\nExample:\nGiven matrix = [\n  [1,  0, 1],\n  [0, -2, 3]\n]\nk = 2\nThe answer is 2. Because the sum of rectangle [[0, 1], [-2, 3]] is 2 and 2 is the max number no larger than k (k = 2).\n\nNote:\nThe rectangle inside the matrix must have an area > 0.\nWhat if the number of rows is much larger than the number of columns?",
    "Difficulty" : "Hard",
    "Number" : "363",
    "Source" : "LeetCode",
    "Title" : "Max Sum of Rectangle No Larger Than K"
  }, {
    "Description" : "Given a nested list of integers, return the sum of all integers in the list weighted by their depth.\n\nEach element is either an integer, or a list -- whose elements may also be integers or other lists.\n\nDifferent from the previous question where weight is increasing from root to leaf, now the weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight.\n\nExample 1:\nGiven the list [[1,1],2,[1,1]], return 8. (four 1's at depth 1, one 2 at depth 2)\n\nExample 2:\nGiven the list [1,[4,[6]]], return 17. (one 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1*3 + 4*2 + 6*1 = 17)",
    "Difficulty" : "Medium",
    "Number" : "364",
    "Source" : "LeetCode",
    "Title" : "Nested List Weight Sum II"
  }, {
    "Description" : "You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs.\n\nIf z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end.\n\nOperations allowed:\n\nFill any of the jugs completely with water.\nEmpty any of the jugs.\nPour water from one jug into another till the other jug is completely full or the first jug itself is empty.\nExample 1: (From the famous \"Die Hard\" example)\n\nInput: x = 3, y = 5, z = 4\nOutput: True\nExample 2:\n\nInput: x = 2, y = 6, z = 5\nOutput: False",
    "Difficulty" : "Medium",
    "Number" : "365",
    "Source" : "LeetCode",
    "Title" : "Water and Jug Problem"
  }, {
    "Description" : "Given a binary tree, collect a tree's nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.\n\nExample:\nGiven binary tree \n          1\n         / \\\n        2   3\n       / \\     \n      4   5    \nReturns [4, 5, 3], [2], [1].\n\nExplanation:\n1. Removing the leaves [4, 5, 3] would result in this tree:\n\n          1\n         / \n        2          \n2. Now removing the leaf [2] would result in this tree:\n\n          1          \n3. Now removing the leaf [1] would result in the empty tree:\n\n          []         \nReturns [4, 5, 3], [2], [1].\n",
    "Difficulty" : "Medium",
    "Number" : "366",
    "Source" : "LeetCode",
    "Title" : "Find Leaves of Binary Tree"
  }, {
    "Description" : "Given a positive integer num, write a function which returns True if num is a perfect square else False.\n\nNote: Do not use any built-in library function such as sqrt.\n\nExample 1:\n\nInput: 16\nReturns: True\nExample 2:\n\nInput: 14\nReturns: False",
    "Difficulty" : "Easy",
    "Number" : "367",
    "Source" : "LeetCode",
    "Title" : "Valid Perfect Square"
  }, {
    "Description" : "Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.\n\nIf there are multiple solutions, return any subset is fine.\n\nExample 1:\n\nnums: [1,2,3]\n\nResult: [1,2] (of course, [1,3] will also be ok)\nExample 2:\n\nnums: [1,2,4,8]\n\nResult: [1,2,4,8]",
    "Difficulty" : "Medium",
    "Number" : "368",
    "Source" : "LeetCode",
    "Title" : "Largest Divisible Subset"
  }, {
    "Description" : "Given a non-negative integer represented as non-empty a singly linked list of digits, plus one to the integer.\n\nYou may assume the integer do not contain any leading zero, except the number 0 itself.\n\nThe digits are stored such that the most significant digit is at the head of the list.\n\nExample:\nInput:\n1->2->3\n\nOutput:\n1->2->4",
    "Difficulty" : "Medium",
    "Number" : "369",
    "Source" : "LeetCode",
    "Title" : "Plus One Linked List"
  }, {
    "Description" : "Assume you have an array of length n initialized with all 0's and are given k update operations.\n\nEach operation is represented as a triplet: [startIndex, endIndex, inc] which increments each element of subarray A[startIndex ... endIndex] (startIndex and endIndex inclusive) with inc.\n\nReturn the modified array after all k operations were executed.\n\nExample:\n\nGiven:\n\n    length = 5,\n    updates = [\n        [1,  3,  2],\n        [2,  4,  3],\n        [0,  2, -2]\n    ]\n\nOutput:\n\n    [-2, 0, 3, 5, 3]\nExplanation:\n\nInitial state:\n[ 0, 0, 0, 0, 0 ]\n\nAfter applying operation [1, 3, 2]:\n[ 0, 2, 2, 2, 0 ]\n\nAfter applying operation [2, 4, 3]:\n[ 0, 2, 5, 5, 3 ]\n\nAfter applying operation [0, 2, -2]:\n[-2, 0, 3, 5, 3 ]",
    "Difficulty" : "Medium",
    "Number" : "370",
    "Source" : "LeetCode",
    "Title" : "Range Addition"
  }, {
    "Description" : "Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.\n\nExample:\nGiven a = 1 and b = 2, return 3.",
    "Difficulty" : "Easy",
    "Number" : "371",
    "Source" : "LeetCode",
    "Title" : "Sum of Two Integers"
  }, {
    "Description" : "Your task is to calculate a<sup>b</sup> mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.\n\nExample1:\n\na = 2\nb = [3]\n\nResult: 8\nExample2:\n\na = 2\nb = [1,0]\n\nResult: 1024",
    "Difficulty" : "Medium",
    "Number" : "372",
    "Source" : "LeetCode",
    "Title" : "Super Pow"
  }, {
    "Description" : "You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.\n\nDefine a pair (u,v) which consists of one element from the first array and one element from the second array.\n\nFind the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.\n\nExample 1:\nGiven nums1 = [1,7,11], nums2 = [2,4,6],  k = 3\n\nReturn: [1,2],[1,4],[1,6]\n\nThe first 3 pairs are returned from the sequence:\n[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\nExample 2:\nGiven nums1 = [1,1,2], nums2 = [1,2,3],  k = 2\n\nReturn: [1,1],[1,1]\n\nThe first 2 pairs are returned from the sequence:\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\nExample 3:\nGiven nums1 = [1,2], nums2 = [3],  k = 3 \n\nReturn: [1,3],[2,3]\n\nAll possible pairs are returned from the sequence:\n[1,3],[2,3]",
    "Difficulty" : "Medium",
    "Number" : "373",
    "Source" : "LeetCode",
    "Title" : "Find K Pairs with Smallest Sums"
  }, {
    "Description" : "We are playing the Guess Game. The game is as follows:\n\nI pick a number from 1 to n. You have to guess which number I picked.\n\nEvery time you guess wrong, I'll tell you whether the number is higher or lower.\n\nYou call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):\n\n-1 : My number is lower\n 1 : My number is higher\n 0 : Congrats! You got it!\nExample:\nn = 10, I pick 6.\n\nReturn 6.",
    "Difficulty" : "Easy",
    "Number" : "374",
    "Source" : "LeetCode",
    "Title" : "Guess Number Higher or Lower"
  }, {
    "Description" : "We are playing the Guess Game. The game is as follows:\n\nI pick a number from 1 to n. You have to guess which number I picked.\n\nEvery time you guess wrong, I'll tell you whether the number I picked is higher or lower.\n\nHowever, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked.\n\nExample:\n\nn = 10, I pick 8.\n\nFirst round:  You guess 5, I tell you that it's higher. You pay $5.\nSecond round: You guess 7, I tell you that it's higher. You pay $7.\nThird round:  You guess 9, I tell you that it's lower. You pay $9.\n\nGame over. 8 is the number I picked.\n\nYou end up paying $5 + $7 + $9 = $21.\nGiven a particular n ≥ 1, find out how much money you need to have to guarantee a win.",
    "Difficulty" : "Medium",
    "Number" : "375",
    "Source" : "LeetCode",
    "Title" : "Guess Number Higher or Lower II"
  }, {
    "Description" : "A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.\n\nFor example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.\n\nGiven a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.\n\nExamples:\nInput: [1,7,4,9,2,5]\nOutput: 6\nThe entire sequence is a wiggle sequence.\n\nInput: [1,17,5,10,13,15,10,5,16,8]\nOutput: 7\nThere are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].\n\nInput: [1,2,3,4,5,6,7,8,9]\nOutput: 2\nFollow up:\nCan you do it in O(n) time?",
    "Difficulty" : "Medium",
    "Number" : "376",
    "Source" : "LeetCode",
    "Title" : "Wiggle Subsequence"
  }, {
    "Description" : "Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.\n\nExample:\n\nnums = [1, 2, 3]\ntarget = 4\n\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n\nNote that different sequences are counted as different combinations.\n\nTherefore the output is 7.\nFollow up:\nWhat if negative numbers are allowed in the given array?\nHow does it change the problem?\nWhat limitation we need to add to the question to allow negative numbers?",
    "Difficulty" : "Medium",
    "Number" : "377",
    "Source" : "LeetCode",
    "Title" : "Combination Sum IV"
  }, {
    "Description" : "Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.\n\nNote that it is the kth smallest element in the sorted order, not the kth distinct element.\n\nExample:\n\nmatrix = [\n   [ 1,  5,  9],\n   [10, 11, 13],\n   [12, 13, 15]\n],\nk = 8,\n\nreturn 13.\nNote: \nYou may assume k is always valid, 1 ≤ k ≤ n2.",
    "Difficulty" : "Medium",
    "Number" : "378",
    "Source" : "LeetCode",
    "Title" : "Kth Smallest Element in a Sorted Matrix"
  }, {
    "Description" : "Design a Phone Directory which supports the following operations:\n\nget: Provide a number which is not assigned to anyone.\ncheck: Check if a number is available or not.\nrelease: Recycle or release a number.\nExample:\n\n// Init a phone directory containing a total of 3 numbers: 0, 1, and 2.\nPhoneDirectory directory = new PhoneDirectory(3);\n\n// It can return any available phone number. Here we assume it returns 0.\ndirectory.get();\n\n// Assume it returns 1.\ndirectory.get();\n\n// The number 2 is available, so return true.\ndirectory.check(2);\n\n// It returns 2, the only number that is left.\ndirectory.get();\n\n// The number 2 is no longer available, so return false.\ndirectory.check(2);\n\n// Release number 2 back to the pool.\ndirectory.release(2);\n\n// Number 2 is available again, return true.\ndirectory.check(2);",
    "Difficulty" : "Medium",
    "Number" : "379",
    "Source" : "LeetCode",
    "Title" : "Design Phone Directory"
  }, {
    "Description" : "Design a data structure that supports all following operations in average O(1) time.\n\ninsert(val): Inserts an item val to the set if not already present.\nremove(val): Removes an item val from the set if present.\ngetRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.\nExample:\n\n// Init an empty set.\nRandomizedSet randomSet = new RandomizedSet();\n\n// Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomSet.insert(1);\n\n// Returns false as 2 does not exist in the set.\nrandomSet.remove(2);\n\n// Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomSet.insert(2);\n\n// getRandom should return either 1 or 2 randomly.\nrandomSet.getRandom();\n\n// Removes 1 from the set, returns true. Set now contains [2].\nrandomSet.remove(1);\n\n// 2 was already in the set, so return false.\nrandomSet.insert(2);\n\n// Since 2 is the only number in the set, getRandom always return 2.\nrandomSet.getRandom();",
    "Difficulty" : "Medium",
    "Number" : "380",
    "Source" : "LeetCode",
    "Title" : "Insert Delete GetRandom O(1)"
  }, {
    "Description" : "Design a data structure that supports all following operations in average O(1) time.\n\nNote: Duplicate elements are allowed.\ninsert(val): Inserts an item val to the collection.\nremove(val): Removes an item val from the collection if present.\ngetRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.\nExample:\n\n// Init an empty collection.\nRandomizedCollection collection = new RandomizedCollection();\n\n// Inserts 1 to the collection. Returns true as the collection did not contain 1.\ncollection.insert(1);\n\n// Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].\ncollection.insert(1);\n\n// Inserts 2 to the collection, returns true. Collection now contains [1,1,2].\ncollection.insert(2);\n\n// getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3.\ncollection.getRandom();\n\n// Removes 1 from the collection, returns true. Collection now contains [1,2].\ncollection.remove(1);\n\n// getRandom should return 1 and 2 both equally likely.\ncollection.getRandom();",
    "Difficulty" : "Hard",
    "Number" : "381",
    "Source" : "LeetCode",
    "Title" : "Insert Delete GetRandom O(1) - Duplicates allowed"
  }, {
    "Description" : "Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen.\n\nFollow up:\nWhat if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?\n\nExample:\n\n// Init a singly linked list [1,2,3].\nListNode head = new ListNode(1);\nhead.next = new ListNode(2);\nhead.next.next = new ListNode(3);\nSolution solution = new Solution(head);\n\n// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.\nsolution.getRandom();",
    "Difficulty" : "Medium",
    "Number" : "382",
    "Source" : "LeetCode",
    "Title" : "Linked List Random Node"
  }, {
    "Description" : "Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.\n\nEach letter in the magazine string can only be used once in your ransom note.\n\nNote:\nYou may assume that both strings contain only lowercase letters.\n\ncanConstruct(\"a\", \"b\") -> false\ncanConstruct(\"aa\", \"ab\") -> false\ncanConstruct(\"aa\", \"aab\") -> true",
    "Difficulty" : "Easy",
    "Number" : "383",
    "Source" : "LeetCode",
    "Title" : "Ransom Note"
  }, {
    "Description" : "Shuffle a set of numbers without duplicates.\n\nExample:\n\n// Init an array with set 1, 2, and 3.\nint[] nums = {1,2,3};\nSolution solution = new Solution(nums);\n\n// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.\nsolution.shuffle();\n\n// Resets the array back to its original configuration [1,2,3].\nsolution.reset();\n\n// Returns the random shuffling of array [1,2,3].\nsolution.shuffle();",
    "Difficulty" : "Medium",
    "Number" : "384",
    "Source" : "LeetCode",
    "Title" : "Shuffle an Array"
  }, {
    "Description" : "Given a nested list of integers represented as a string, implement a parser to deserialize it.\n\nEach element is either an integer, or a list -- whose elements may also be integers or other lists.\n\nNote: You may assume that the string is well-formed:\n\nString is non-empty.\nString does not contain white spaces.\nString contains only digits 0-9, [, - ,, ].\nExample 1:\n\nGiven s = \"324\",\n\nYou should return a NestedInteger object which contains a single integer 324.\nExample 2:\n\nGiven s = \"[123,[456,[789]]]\",\n\nReturn a NestedInteger object containing a nested list with 2 elements:\n\n1. An integer containing value 123.\n2. A nested list containing two elements:\n    i.  An integer containing value 456.\n    ii. A nested list with one element:\n         a. An integer containing value 789.",
    "Difficulty" : "Medium",
    "Number" : "385",
    "Source" : "LeetCode",
    "Title" : "Mini Parser"
  }, {
    "Description" : "Given an integer n, return 1 - n in lexicographical order.\n\nFor example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].\n\nPlease optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.",
    "Difficulty" : "Medium",
    "Number" : "386",
    "Source" : "LeetCode",
    "Title" : "Lexicographical Numbers"
  }, {
    "Description" : "Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\n\nExamples:\n\ns = \"leetcode\"\nreturn 0.\n\ns = \"loveleetcode\",\nreturn 2.\nNote: You may assume the string contain only lowercase letters.",
    "Difficulty" : "Easy",
    "Number" : "387",
    "Source" : "LeetCode",
    "Title" : "First Unique Character in a String"
  }, {
    "Description" : "Suppose we abstract our file system by a string in the following manner:\n\nThe string \"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\" represents:\n\ndir\n    subdir1\n    subdir2\n        file.ext\nThe directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext.\n\nThe string \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\" represents:\n\ndir\n    subdir1\n        file1.ext\n        subsubdir1\n    subdir2\n        subsubdir2\n            file2.ext\nThe directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext.\n\nWe are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is \"dir/subdir2/subsubdir2/file2.ext\", and its length is 32 (not including the double quotes).\n\nGiven a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0.\n\nNote:\nThe name of a file contains at least a . and an extension.\nThe name of a directory or sub-directory will not contain a ..\nTime complexity required: O(n) where n is the size of the input string.\n\nNotice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png.",
    "Difficulty" : "Medium",
    "Number" : "388",
    "Source" : "LeetCode",
    "Title" : "Longest Absolute File Path"
  }, {
    "Description" : "Given two strings s and t which consist of only lowercase letters.\n\nString t is generated by random shuffling string s and then add one more letter at a random position.\n\nFind the letter that was added in t.\n\nExample:\n\nInput:\ns = \"abcd\"\nt = \"abcde\"\n\nOutput:\ne\n\nExplanation:\n'e' is the letter that was added.",
    "Difficulty" : "Easy",
    "Number" : "389",
    "Source" : "LeetCode",
    "Title" : "Find the Difference"
  }, {
    "Description" : "There is a list of sorted integers from 1 to n. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.\n\nRepeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers.\n\nWe keep repeating the steps again, alternating left to right and right to left, until a single number remains.\n\nFind the last number that remains starting with a list of length n.\n\nExample:\n\nInput:\nn = 9,\n1 2 3 4 5 6 7 8 9\n2 4 6 8\n2 6\n6\n\nOutput:\n6",
    "Difficulty" : "Medium",
    "Number" : "390",
    "Source" : "LeetCode",
    "Title" : "Elimination Game"
  }, {
    "Description" : "Given N axis-aligned rectangles where N > 0, determine if they all together form an exact cover of a rectangular region.\n\nEach rectangle is represented as a bottom-left point and a top-right point. For example, a unit square is represented as [1,1,2,2]. (coordinate of bottom-left point is (1, 1) and top-right point is (2, 2)).\n\n\nExample 1:\n\nrectangles = [\n  [1,1,3,3],\n  [3,1,4,2],\n  [3,2,4,4],\n  [1,3,2,4],\n  [2,3,3,4]\n]\n\nReturn true. All 5 rectangles together form an exact cover of a rectangular region.\n\nExample 2:\n\nrectangles = [\n  [1,1,2,3],\n  [1,3,2,4],\n  [3,1,4,2],\n  [3,2,4,4]\n]\n\nReturn false. Because there is a gap between the two rectangular regions.\n\nExample 3:\n\nrectangles = [\n  [1,1,3,3],\n  [3,1,4,2],\n  [1,3,2,4],\n  [3,2,4,4]\n]\n\nReturn false. Because there is a gap in the top center.\n\nExample 4:\n\nrectangles = [\n  [1,1,3,3],\n  [3,1,4,2],\n  [1,3,2,4],\n  [2,2,4,4]\n]\n\nReturn false. Because two of the rectangles overlap with each other.\nShow Company Tags\n",
    "Difficulty" : "Hard",
    "Number" : "391",
    "Source" : "LeetCode",
    "Title" : "Perfect Rectangle"
  }, {
    "Description" : "Given a string s and a string t, check if s is subsequence of t.\n\nYou may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (<=100).\n\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).\n\nExample 1:\ns = \"abc\", t = \"ahbgdc\"\n\nReturn true.\n\nExample 2:\ns = \"axc\", t = \"ahbgdc\"\n\nReturn false.\n\nFollow up:\nIf there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?",
    "Difficulty" : "Medium",
    "Number" : "392",
    "Source" : "LeetCode",
    "Title" : "Is Subsequence"
  }, {
    "Description" : "A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:\n\nFor 1-byte character, the first bit is a 0, followed by its unicode code.\nFor n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.\nThis is how the UTF-8 encoding would work:\n\n   Char. number range  |        UTF-8 octet sequence\n      (hexadecimal)    |              (binary)\n   --------------------+---------------------------------------------\n   0000 0000-0000 007F | 0xxxxxxx\n   0000 0080-0000 07FF | 110xxxxx 10xxxxxx\n   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\nGiven an array of integers representing the data, return whether it is a valid utf-8 encoding.\n\nNote:\nThe input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.\n\nExample 1:\n\ndata = [197, 130, 1], which represents the octet sequence: 11000101 10000010 00000001.\n\nReturn true.\nIt is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\nExample 2:\n\ndata = [235, 140, 4], which represented the octet sequence: 11101011 10001100 00000100.\n\nReturn false.\nThe first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\nThe next byte is a continuation byte which starts with 10 and that's correct.\nBut the second continuation byte does not start with 10, so it is invalid.",
    "Difficulty" : "Medium",
    "Number" : "393",
    "Source" : "LeetCode",
    "Title" : "UTF-8 Validation"
  }, {
    "Description" : "Given an encoded string, return it's decoded string.\n\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\n\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].\n\nExamples:\n\ns = \"3[a]2[bc]\", return \"aaabcbc\".\ns = \"3[a2[c]]\", return \"accaccacc\".\ns = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\".",
    "Difficulty" : "Medium",
    "Number" : "394",
    "Source" : "LeetCode",
    "Title" : "Decode String"
  }, {
    "Description" : "Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.\n\nExample 1:\n\nInput:\ns = \"aaabb\", k = 3\n\nOutput:\n3\n\nThe longest substring is \"aaa\", as 'a' is repeated 3 times.\nExample 2:\n\nInput:\ns = \"ababbc\", k = 2\n\nOutput:\n5\n\nThe longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times.",
    "Difficulty" : "Medium",
    "Number" : "395",
    "Source" : "LeetCode",
    "Title" : "Longest Substring with At Least K Repeating Characters"
  }, {
    "Description" : "Given an array of integers A and let n to be its length.\n\nAssume Bk to be an array obtained by rotating the array A k positions clock-wise, we define a \"rotation function\" F on A as follow:\n\nF(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1].\n\nCalculate the maximum value of F(0), F(1), ..., F(n-1).\n\nNote:\nn is guaranteed to be less than 105.\n\nExample:\n\nA = [4, 3, 2, 6]\n\nF(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\nF(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\nF(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\nF(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\n\nSo the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.",
    "Difficulty" : "Medium",
    "Number" : "396",
    "Source" : "LeetCode",
    "Title" : "Rotate Function"
  }, {
    "Description" : "Given a positive integer n and you can do operations as follow:\n\nIf n is even, replace n with n/2.\nIf n is odd, you can replace n with either n + 1 or n - 1.\nWhat is the minimum number of replacements needed for n to become 1?\n\nExample 1:\n\nInput:\n8\n\nOutput:\n3\n\nExplanation:\n8 -> 4 -> 2 -> 1\nExample 2:\n\nInput:\n7\n\nOutput:\n4\n\nExplanation:\n7 -> 8 -> 4 -> 2 -> 1\nor\n7 -> 6 -> 3 -> 2 -> 1",
    "Difficulty" : "Medium",
    "Number" : "397",
    "Source" : "LeetCode",
    "Title" : "Integer Replacement"
  }, {
    "Description" : "Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.\n\nNote:\nThe array size can be very large. Solution that uses too much extra space will not pass the judge.\n\nExample:\n\nint[] nums = new int[] {1,2,3,3,3};\nSolution solution = new Solution(nums);\n\n// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\nsolution.pick(3);\n\n// pick(1) should return 0. Since in the array only nums[0] is equal to 1.\nsolution.pick(1);",
    "Difficulty" : "Medium",
    "Number" : "398",
    "Source" : "LeetCode",
    "Title" : "Random Pick Index"
  }, {
    "Description" : "Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.\n\nExample:\nGiven a / b = 2.0, b / c = 3.0. \nqueries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? . \nreturn [6.0, 0.5, -1.0, 1.0, -1.0 ].\n\nThe input is: vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries , where equations.size() == values.size(), and the values are positive. This represents the equations. Return vector<double>.\n\nAccording to the example above:\n\nequations = [ [\"a\", \"b\"], [\"b\", \"c\"] ],\nvalues = [2.0, 3.0],\nqueries = [ [\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"] ]. \nThe input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.",
    "Difficulty" : "Medium",
    "Number" : "399",
    "Source" : "LeetCode",
    "Title" : "Evaluate Division"
  }, {
    "Description" : "Find the n<sup>th</sup> digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...\n\nNote:\nn is positive and will fit within the range of a 32-bit signed integer (n < 231).\n\nExample 1:\n\nInput:\n3\n\nOutput:\n3\nExample 2:\n\nInput:\n11\n\nOutput:\n0\n\nExplanation:\nThe 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.",
    "Difficulty" : "Easy",
    "Number" : "400",
    "Source" : "LeetCode",
    "Title" : "Nth Digit"
  }, {
    "Description" : "A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).\n\nEach LED represents a zero or one, with the least significant bit on the right.\n\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/8/8b/Binary_clock_samui_moon.jpg\" width=\"300px\" />\n\nFor example, the above binary watch reads \"3:25\".\n\nGiven a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.\n\nExample:\n\nInput: n = 1\nReturn: [\"1:00\", \"2:00\", \"4:00\", \"8:00\", \"0:01\", \"0:02\", \"0:04\", \"0:08\", \"0:16\", \"0:32\"]\nNote:\nThe order of output does not matter.\nThe hour must not contain a leading zero, for example \"01:00\" is not valid, it should be \"1:00\".\nThe minute must be consist of two digits and may contain a leading zero, for example \"10:2\" is not valid, it should be \"10:02\".",
    "Difficulty" : "Easy",
    "Number" : "401",
    "Source" : "LeetCode",
    "Title" : "Binary Watch"
  }, {
    "Description" : "Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.\n\nNote:\nThe length of num is less than 10002 and will be ≥ k.\nThe given num does not contain any leading zero.\nExample 1:\n\nInput: num = \"1432219\", k = 3\nOutput: \"1219\"\nExplanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\nExample 2:\n\nInput: num = \"10200\", k = 1\nOutput: \"200\"\nExplanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\nExample 3:\n\nInput: num = \"10\", k = 2\nOutput: \"0\"\nExplanation: Remove all the digits from the number and it is left with nothing which is 0.",
    "Difficulty" : "Medium",
    "Number" : "402",
    "Source" : "LeetCode",
    "Title" : "Remove K Digits"
  }, {
    "Description" : "A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n\nGiven a list of stones' positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.\n\nIf the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. Note that the frog can only jump in the forward direction.\n\nNote:\n\nThe number of stones is ≥ 2 and is < 1,100.\nEach stone's position will be a non-negative integer < 2<sup>31</sup>.\nThe first stone's position is always 0.\nExample 1:\n\n[0,1,3,5,6,8,12,17]\n\nThere are a total of 8 stones.\nThe first stone at the 0th unit, second stone at the 1st unit,\nthird stone at the 3rd unit, and so on...\nThe last stone at the 17th unit.\n\nReturn true. The frog can jump to the last stone by jumping \n1 unit to the 2nd stone, then 2 units to the 3rd stone, then \n2 units to the 4th stone, then 3 units to the 6th stone, \n4 units to the 7th stone, and 5 units to the 8th stone.\nExample 2:\n\n[0,1,2,3,4,8,9,11]\n\nReturn false. There is no way to jump to the last stone as \nthe gap between the 5th and 6th stone is too large.",
    "Difficulty" : "Hard",
    "Number" : "403",
    "Source" : "LeetCode",
    "Title" : "Frog Jump"
  }, {
    "Description" : "Find the sum of all left leaves in a given binary tree.\n\nExample:\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\nThere are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.",
    "Difficulty" : "Easy",
    "Number" : "404",
    "Source" : "LeetCode",
    "Title" : "Sum of Left Leaves"
  }, {
    "Description" : "Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.\n\nNote:\n\nAll letters in hexadecimal (a-f) must be in lowercase.\nThe hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character '0'; otherwise, the first character in the hexadecimal string will not be the zero character.\nThe given number is guaranteed to fit within the range of a 32-bit signed integer.\nYou must not use any method provided by the library which converts/formats the number to hex directly.\nExample 1:\n\nInput:\n26\n\nOutput:\n\"1a\"\nExample 2:\n\nInput:\n-1\n\nOutput:\n\"ffffffff\"",
    "Difficulty" : "Easy",
    "Number" : "405",
    "Source" : "LeetCode",
    "Title" : "Convert a Number to Hexadecimal"
  }, {
    "Description" : "Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.\n\nNote:\nThe number of people is less than 1,100.\n\nExample\n\nInput:\n[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]\n\nOutput:\n[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]",
    "Difficulty" : "Medium",
    "Number" : "406",
    "Source" : "LeetCode",
    "Title" : "Queue Reconstruction by Height"
  }, {
    "Description" : "Given an m x n matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.\n\nNote:\nBoth m and n are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.\n\nExample:\n\nGiven the following 3x6 height map:\n[\n  [1,4,3,1,3,2],\n  [3,2,1,3,2,4],\n  [2,3,3,2,3,1]\n]\n\nReturn 4.\n\nThe above image represents the elevation map [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]] before the rain.\n\nAfter the rain, water are trapped between the blocks. The total volume of water trapped is 4.",
    "Difficulty" : "Hard",
    "Number" : "407",
    "Source" : "LeetCode",
    "Title" : "Trapping Rain Water II"
  }, {
    "Description" : "Given a non-empty string s and an abbreviation abbr, return whether the string matches with the given abbreviation.\n\nA string such as \"word\" contains only the following valid abbreviations:\n\n[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]\nNotice that only the above abbreviations are valid abbreviations of the string \"word\". Any other string is not a valid abbreviation of \"word\".\n\nNote:\nAssume s contains only lowercase letters and abbr contains only lowercase letters and digits.\n\nExample 1:\nGiven s = \"internationalization\", abbr = \"i12iz4n\":\n\nReturn true.\nExample 2:\nGiven s = \"apple\", abbr = \"a2e\":\n\nReturn false.",
    "Difficulty" : "Easy",
    "Number" : "408",
    "Source" : "LeetCode",
    "Title" : "Valid Word Abbreviation"
  }, {
    "Description" : "Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.\n\nThis is case sensitive, for example \"Aa\" is not considered a palindrome here.\n\nNote:\nAssume the length of given string will not exceed 1,010.\n\nExample:\n\nInput:\n\"abccccdd\"\n\nOutput:\n7\n\nExplanation:\nOne longest palindrome that can be built is \"dccaccd\", whose length is 7.",
    "Difficulty" : "Easy",
    "Number" : "409",
    "Source" : "LeetCode",
    "Title" : "Longest Palindrome"
  }, {
    "Description" : "Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.\n\nNote:\nIf n is the length of array, assume the following constraints are satisfied:\n\n1 ≤ n ≤ 1000\n1 ≤ m ≤ min(50, n)\nExamples:\n\nInput:\nnums = [7,2,5,10,8]\nm = 2\n\nOutput:\n18\n\nExplanation:\nThere are four ways to split nums into two subarrays.\nThe best way is to split it into [7,2,5] and [10,8],\nwhere the largest sum among the two subarrays is only 18.",
    "Difficulty" : "Hard",
    "Number" : "410",
    "Source" : "LeetCode",
    "Title" : "Split Array Largest Sum"
  }, {
    "Description" : "A string such as \"word\" contains the following abbreviations:\n\n[\"word\", \"1ord\", \"w1rd\", \"wo1d\", \"wor1\", \"2rd\", \"w2d\", \"wo2\", \"1o1d\", \"1or1\", \"w1r1\", \"1o2\", \"2r1\", \"3d\", \"w3\", \"4\"]\nGiven a target string and a set of strings in a dictionary, find an abbreviation of this target string with the smallest possible length such that it does not conflict with abbreviations of the strings in the dictionary.\n\nEach number or letter in the abbreviation is considered length = 1. For example, the abbreviation \"a32bc\" has length = 4.\n\nNote:\nIn the case of multiple answers as shown in the second example below, you may return any one of them.\nAssume length of target string = m, and dictionary size = n. You may assume that m ≤ 21, n ≤ 1000, and log2(n) + m ≤ 20.\nExamples:\n\"apple\", [\"blade\"] -> \"a4\" (because \"5\" or \"4e\" conflicts with \"blade\")\n\n\"apple\", [\"plain\", \"amber\", \"blade\"] -> \"1p3\" (other valid answers include \"ap3\", \"a3e\", \"2p2\", \"3le\", \"3l1\").",
    "Difficulty" : "Hard",
    "Number" : "411",
    "Source" : "LeetCode",
    "Title" : "Minimum Unique Word Abbreviation"
  }, {
    "Description" : "\nBut for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.\n\nExample:\n\nn = 15,\n\nReturn:\n[\n    \"1\",\n    \"2\",\n    \"Fizz\",\n    \"4\",\n    \"Buzz\",\n    \"Fizz\",\n    \"7\",\n    \"8\",\n    \"Fizz\",\n    \"Buzz\",\n    \"11\",\n    \"Fizz\",\n    \"13\",\n    \"14\",\n    \"FizzBuzz\"\n]",
    "Difficulty" : "Easy",
    "Number" : "412",
    "Source" : "LeetCode",
    "Title" : "Fizz Buzz"
  }, {
    "Description" : "A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, these are arithmetic sequence:\n\n1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9\nThe following sequence is not arithmetic.\n\n1, 1, 2, 5, 7\n\nA zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 <= P < Q < N.\n\nA slice (P, Q) of array A is called arithmetic if the sequence:\nA[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 < Q.\n\nThe function should return the number of arithmetic slices in the array A.\n\n\nExample:\n\nA = [1, 2, 3, 4]\n\nreturn: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.",
    "Difficulty" : "Medium",
    "Number" : "413",
    "Source" : "LeetCode",
    "Title" : "Arithmetic Slices"
  }, {
    "Description" : "Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).\n\nExample 1:\nInput: [3, 2, 1]\n\nOutput: 1\n\nExplanation: The third maximum is 1.\nExample 2:\nInput: [1, 2]\n\nOutput: 2\n\nExplanation: The third maximum does not exist, so the maximum (2) is returned instead.\nExample 3:\nInput: [2, 2, 3, 1]\n\nOutput: 1\n\nExplanation: Note that the third maximum here means the third maximum distinct number.\nBoth numbers with value 2 are both considered as second maximum.",
    "Difficulty" : "Easy",
    "Number" : "414",
    "Source" : "LeetCode",
    "Title" : "Third Maximum Number"
  }, {
    "Description" : "Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.\n\nNote:\n\nThe length of both num1 and num2 is < 5100.\nBoth num1 and num2 contains only digits 0-9.\nBoth num1 and num2 does not contain any leading zero.\nYou must not use any built-in BigInteger library or convert the inputs to integer directly.",
    "Difficulty" : "Easy",
    "Number" : "415",
    "Source" : "LeetCode",
    "Title" : "Add Strings"
  }, {
    "Description" : "Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n\nNote:\nEach of the array element will not exceed 100.\nThe array size will not exceed 200.\nExample 1:\n\nInput: [1, 5, 11, 5]\n\nOutput: true\n\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\nExample 2:\n\nInput: [1, 2, 3, 5]\n\nOutput: false\n\nExplanation: The array cannot be partitioned into equal sum subsets.",
    "Difficulty" : "Medium",
    "Number" : "416",
    "Source" : "LeetCode",
    "Title" : "Partition Equal Subset Sum"
  }, {
    "Description" : "Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the \"Pacific ocean\" touches the left and top edges of the matrix and the \"Atlantic ocean\" touches the right and bottom edges.\n\nWater can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.\n\nFind the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\n\nNote:\nThe order of returned grid coordinates does not matter.\nBoth m and n are less than 150.\nExample:\n\nGiven the following 5x5 matrix:\n\n  Pacific ~   ~   ~   ~   ~ \n       ~  1   2   2   3  (5) *\n       ~  3   2   3  (4) (4) *\n       ~  2   4  (5)  3   1  *\n       ~ (6) (7)  1   4   5  *\n       ~ (5)  1   1   2   4  *\n          *   *   *   *   * Atlantic\n\nReturn:\n\n[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).",
    "Difficulty" : "Medium",
    "Number" : "417",
    "Source" : "LeetCode",
    "Title" : "Pacific Atlantic Water Flow"
  }, {
    "Description" : "Given a rows x cols screen and a sentence represented by a list of non-empty words, find how many times the given sentence can be fitted on the screen.\n\nNote:\n\nA word cannot be split into two lines.\nThe order of words in the sentence must remain unchanged.\nTwo consecutive words in a line must be separated by a single space.\nTotal words in the sentence won't exceed 100.\nLength of each word is greater than 0 and won't exceed 10.\n1 ≤ rows, cols ≤ 20,000.\nExample 1:\n\nInput:\nrows = 2, cols = 8, sentence = [\"hello\", \"world\"]\n\nOutput: \n1\n\nExplanation:\nhello---\nworld---\n\nThe character '-' signifies an empty space on the screen.\nExample 2:\n\nInput:\nrows = 3, cols = 6, sentence = [\"a\", \"bcd\", \"e\"]\n\nOutput: \n2\n\nExplanation:\na-bcd- \ne-a---\nbcd-e-\n\nThe character '-' signifies an empty space on the screen.\nExample 3:\n\nInput:\nrows = 4, cols = 5, sentence = [\"I\", \"had\", \"apple\", \"pie\"]\n\nOutput: \n1\n\nExplanation:\nI-had\napple\npie-I\nhad--\n\nThe character '-' signifies an empty space on the screen.",
    "Difficulty" : "Medium",
    "Number" : "418",
    "Source" : "LeetCode",
    "Title" : "Sentence Screen Fitting"
  }, {
    "Description" : "Given an 2D board, count how many battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:\n\nYou receive a valid board, made of only battleships or empty slots.\nBattleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.\nAt least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.\nExample:\nX..X\n...X\n...X\nIn the above board there are 2 battleships.\nInvalid Example:\n...X\nXXXX\n...X\nThis is an invalid board that you will not receive - as battleships will always have a cell separating between them.\nFollow up:\nCould you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?",
    "Difficulty" : "Medium",
    "Number" : "419",
    "Source" : "LeetCode",
    "Title" : "Battleships in a Board"
  }, {
    "Description" : "A password is considered strong if below conditions are all met:\n\nIt has at least 6 characters and at most 20 characters.\nIt must contain at least one lowercase letter, at least one uppercase letter, and at least one digit.\nIt must NOT contain three repeating characters in a row (\"...aaa...\" is weak, but \"...aa...a...\" is strong, assuming other conditions are met).\nWrite a function strongPasswordChecker(s), that takes a string s as input, and return the MINIMUM change required to make s a strong password. If s is already strong, return 0.\n\nInsertion, deletion or replace of any one character are all considered as one change.",
    "Difficulty" : "Hard",
    "Number" : "420",
    "Source" : "LeetCode",
    "Title" : "Strong Password Checker"
  }, {
    "Description" : "Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai < 2<sup>31</sup>.\n\nFind the maximum result of ai XOR aj, where 0 ≤ i, j < n.\n\nCould you do this in O(n) runtime?\n\nExample:\n\nInput: [3, 10, 5, 25, 2, 8]\n\nOutput: 28\n\nExplanation: The maximum result is 5 ^ 25 = 28.",
    "Difficulty" : "Medium",
    "Number" : "421",
    "Source" : "LeetCode",
    "Title" : "Maximum XOR of Two Numbers in an Array"
  }, {
    "Description" : "Given a sequence of words, check whether it forms a valid word square.\n\nA sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 ≤ k < max(numRows, numColumns).\n\nNote:\nThe number of words given is at least 1 and does not exceed 500.\nWord length will be at least 1 and does not exceed 500.\nEach word contains only lowercase English alphabet a-z.\nExample 1:\n\nInput:\n[\n  \"abcd\",\n  \"bnrt\",\n  \"crmy\",\n  \"dtye\"\n]\n\nOutput:\ntrue\n\nExplanation:\nThe first row and first column both read \"abcd\".\nThe second row and second column both read \"bnrt\".\nThe third row and third column both read \"crmy\".\nThe fourth row and fourth column both read \"dtye\".\n\nTherefore, it is a valid word square.\nExample 2:\n\nInput:\n[\n  \"abcd\",\n  \"bnrt\",\n  \"crm\",\n  \"dt\"\n]\n\nOutput:\ntrue\n\nExplanation:\nThe first row and first column both read \"abcd\".\nThe second row and second column both read \"bnrt\".\nThe third row and third column both read \"crm\".\nThe fourth row and fourth column both read \"dt\".\n\nTherefore, it is a valid word square.\nExample 3:\n\nInput:\n[\n  \"ball\",\n  \"area\",\n  \"read\",\n  \"lady\"\n]\n\nOutput:\nfalse\n\nExplanation:\nThe third row reads \"read\" while the third column reads \"lead\".\n\nTherefore, it is NOT a valid word square.",
    "Difficulty" : "Easy",
    "Number" : "422",
    "Source" : "LeetCode",
    "Title" : "Valid Word Square"
  }, {
    "Description" : "Given a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order.\n\nNote:\nInput contains only lowercase English letters.\nInput is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as \"abc\" or \"zerone\" are not permitted.\nInput length is less than 50,000.\nExample 1:\nInput: \"owoztneoer\"\n\nOutput: \"012\"\nExample 2:\nInput: \"fviefuro\"\n\nOutput: \"45\"",
    "Difficulty" : "Medium",
    "Number" : "423",
    "Source" : "LeetCode",
    "Title" : "Reconstruct Original Digits from English"
  }, {
    "Description" : "Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.\n\nNote:\nBoth the string's length and k will not exceed 104.\n\nExample 1:\n\nInput:\ns = \"ABAB\", k = 2\n\nOutput:\n4\n\nExplanation:\nReplace the two 'A's with two 'B's or vice versa.\nExample 2:\n\nInput:\ns = \"AABABBA\", k = 1\n\nOutput:\n4\n\nExplanation:\nReplace the one 'A' in the middle with 'B' and form \"AABBBBA\".\nThe substring \"BBBB\" has the longest repeating letters, which is 4.",
    "Difficulty" : "Medium",
    "Number" : "424",
    "Source" : "LeetCode",
    "Title" : "Longest Repeating Character Replacement"
  }, {
    "Description" : "Given a set of words (without duplicates), find all word squares you can build from them.\n\nA sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 ≤ k < max(numRows, numColumns).\n\nFor example, the word sequence [\"ball\",\"area\",\"lead\",\"lady\"] forms a word square because each word reads the same both horizontally and vertically.\n\nb a l l\na r e a\nl e a d\nl a d y\nNote:\nThere are at least 1 and at most 1000 words.\nAll words will have the exact same length.\nWord length is at least 1 and at most 5.\nEach word contains only lowercase English alphabet a-z.\nExample 1:\n\nInput:\n[\"area\",\"lead\",\"wall\",\"lady\",\"ball\"]\n\nOutput:\n[\n  [ \"wall\",\n    \"area\",\n    \"lead\",\n    \"lady\"\n  ],\n  [ \"ball\",\n    \"area\",\n    \"lead\",\n    \"lady\"\n  ]\n]\n\nExplanation:\nThe output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).\nExample 2:\n\nInput:\n[\"abat\",\"baba\",\"atan\",\"atal\"]\n\nOutput:\n[\n  [ \"baba\",\n    \"abat\",\n    \"baba\",\n    \"atan\"\n  ],\n  [ \"baba\",\n    \"abat\",\n    \"baba\",\n    \"atal\"\n  ]\n]\n\nExplanation:\nThe output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).",
    "Difficulty" : "Hard",
    "Number" : "425",
    "Source" : "LeetCode",
    "Title" : "Word Squares"
  }, {
    "Description" : "Implement a data structure supporting the following operations:\n\nInc(Key) - Inserts a new key with value 1. Or increments an existing key by 1. Key is guaranteed to be a non-empty string.\nDec(Key) - If Key's value is 1, remove it from the data structure. Otherwise decrements an existing key by 1. If the key does not exist, this function does nothing. Key is guaranteed to be a non-empty string.\nGetMaxKey() - Returns one of the keys with maximal value. If no element exists, return an empty string \"\".\nGetMinKey() - Returns one of the keys with minimal value. If no element exists, return an empty string \"\".\nChallenge: Perform all these in O(1) time complexity.",
    "Difficulty" : "Hard",
    "Number" : "432",
    "Source" : "LeetCode",
    "Title" : "All O(1) Data Structure"
  }, {
    "Description" : "Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.\n\nPlease note that the string does not contain any non-printable characters.\n\nExample:\n\nInput: \"Hello, my name is John\"\nOutput: 5",
    "Difficulty" : "Easy",
    "Number" : "434",
    "Source" : "LeetCode",
    "Title" : "Number of Segments in a String"
  }, {
    "Description" : "Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n\nNote:\nYou may assume the interval's end point is always bigger than its start point.\nIntervals like [1,2] and [2,3] have borders \"touching\" but they don't overlap each other.\nExample 1:\nInput: [ [1,2], [2,3], [3,4], [1,3] ]\n\nOutput: 1\n\nExplanation: [1,3] can be removed and the rest of intervals are non-overlapping.\nExample 2:\nInput: [ [1,2], [1,2], [1,2] ]\n\nOutput: 2\n\nExplanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.\nExample 3:\nInput: [ [1,2], [2,3] ]\n\nOutput: 0\n\nExplanation: You don't need to remove any of the intervals since they're already non-overlapping.",
    "Difficulty" : "Medium",
    "Number" : "435",
    "Source" : "LeetCode",
    "Title" : "Non-overlapping Intervals"
  }, {
    "Description" : "Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the \"right\" of i.\n\nFor any interval i, you need to store the minimum interval j's index, which means that the interval j has the minimum start point to build the \"right\" relationship for interval i. If the interval j doesn't exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.\n\nNote:\nYou may assume the interval's end point is always bigger than its start point.\nYou may assume none of these intervals have the same start point.\nExample 1:\nInput: [ [1,2] ]\n\nOutput: [-1]\n\nExplanation: There is only one interval in the collection, so it outputs -1.\nExample 2:\nInput: [ [3,4], [2,3], [1,2] ]\n\nOutput: [-1, 0, 1]\n\nExplanation: There is no satisfied \"right\" interval for [3,4].\nFor [2,3], the interval [3,4] has minimum-\"right\" start point;\nFor [1,2], the interval [2,3] has minimum-\"right\" start point.\nExample 3:\nInput: [ [1,4], [2,3], [3,4] ]\n\nOutput: [-1, 2, -1]\n\nExplanation: There is no satisfied \"right\" interval for [1,4] and [3,4].\nFor [2,3], the interval [3,4] has minimum-\"right\" start point.",
    "Difficulty" : "Medium",
    "Number" : "436",
    "Source" : "LeetCode",
    "Title" : "Find Right Interval"
  }, {
    "Description" : "You are given a binary tree in which each node contains an integer value.\n\nFind the number of paths that sum to a given value.\n\nThe path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).\n\nThe tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.\n\nExample:\n\nroot = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\n\n      10\n     /  \\\n    5   -3\n   / \\    \\\n  3   2   11\n / \\   \\\n3  -2   1\n\nReturn 3. The paths that sum to 8 are:\n\n1.  5 -> 3\n2.  5 -> 2 -> 1\n3. -3 -> 11",
    "Difficulty" : "Easy",
    "Number" : "437",
    "Source" : "LeetCode",
    "Title" : "Path Sum III"
  }, {
    "Description" : "Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\n\nStrings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\n\nThe order of output does not matter.\n\nExample 1:\n\nInput:\ns: \"cbaebabacd\" p: \"abc\"\n\nOutput:\n[0, 6]\n\nExplanation:\nThe substring with start index = 0 is \"cba\", which is an anagram of \"abc\".\nThe substring with start index = 6 is \"bac\", which is an anagram of \"abc\".\nExample 2:\n\nInput:\ns: \"abab\" p: \"ab\"\n\nOutput:\n[0, 1, 2]\n\nExplanation:\nThe substring with start index = 0 is \"ab\", which is an anagram of \"ab\".\nThe substring with start index = 1 is \"ba\", which is an anagram of \"ab\".\nThe substring with start index = 2 is \"ab\", which is an anagram of \"ab\".",
    "Difficulty" : "Easy",
    "Number" : "438",
    "Source" : "LeetCode",
    "Title" : "Find All Anagrams in a String"
  }, {
    "Description" : "Given a string representing arbitrarily nested ternary expressions, calculate the result of the expression. You can always assume that the given expression is valid and only consists of digits 0-9, ?, :, T and F (T and F represent True and False respectively).\n\nNote:\n\nThe length of the given string is ≤ 10000.\nEach number will contain only one digit.\nThe conditional expressions group right-to-left (as usual in most languages).\nThe condition will always be either T or F. That is, the condition will never be a digit.\nThe result of the expression will always evaluate to either a digit 0-9, T or F.\nExample 1:\n\nInput: \"T?2:3\"\n\nOutput: \"2\"\n\nExplanation: If true, then result is 2; otherwise result is 3.\nExample 2:\n\nInput: \"F?1:T?4:5\"\n\nOutput: \"4\"\n\nExplanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:\n\n             \"(F ? 1 : (T ? 4 : 5))\"                   \"(F ? 1 : (T ? 4 : 5))\"\n          -> \"(F ? 1 : 4)\"                 or       -> \"(T ? 4 : 5)\"\n          -> \"4\"                                    -> \"4\"\nExample 3:\n\nInput: \"T?T?F:5:3\"\n\nOutput: \"F\"\n\nExplanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:\n\n             \"(T ? (T ? F : 5) : 3)\"                   \"(T ? (T ? F : 5) : 3)\"\n          -> \"(T ? F : 3)\"                 or       -> \"(T ? F : 5)\"\n          -> \"F\"                                    -> \"F\"",
    "Difficulty" : "Medium",
    "Number" : "439",
    "Source" : "LeetCode",
    "Title" : "Ternary Expression Parser"
  }, {
    "Description" : "Given integers n and k, find the lexicographically k-th smallest integer in the range from 1 to n.\n\nNote: 1 ≤ k ≤ n ≤ 10<sup>9</sup>.\n\nExample:\n\nInput:\nn: 13   k: 2\n\nOutput:\n10\n\nExplanation:\nThe lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.",
    "Difficulty" : "Hard",
    "Number" : "440",
    "Source" : "LeetCode",
    "Title" : "K-th Smallest in Lexicographical Order"
  }, {
    "Description" : "You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.\n\nGiven n, find the total number of full staircase rows that can be formed.\n\nn is a non-negative integer and fits within the range of a 32-bit signed integer.\n\nExample 1:\n\nn = 5\n\nThe coins can form the following rows:\n¤\n¤ ¤\n¤ ¤\n\nBecause the 3rd row is incomplete, we return 2.\nExample 2:\n\nn = 8\n\nThe coins can form the following rows:\n¤\n¤ ¤\n¤ ¤ ¤\n¤ ¤\n\nBecause the 4th row is incomplete, we return 3.",
    "Difficulty" : "Easy",
    "Number" : "441",
    "Source" : "LeetCode",
    "Title" : "Arranging Coins"
  }, {
    "Description" : "Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.\n\nFind all the elements that appear twice in this array.\n\nCould you do it without extra space and in O(n) runtime?\n\nExample:\nInput:\n[4,3,2,7,8,2,3,1]\n\nOutput:\n[2,3]",
    "Difficulty" : "Medium",
    "Number" : "442",
    "Source" : "LeetCode",
    "Title" : "Find All Duplicates in an Array"
  }, {
    "Description" : "Check whether the original sequence org can be uniquely reconstructed from the sequences in seqs. The org sequence is a permutation of the integers from 1 to n, with 1 ≤ n ≤ 104. Reconstruction means building a shortest common supersequence of the sequences in seqs (i.e., a shortest sequence so that all sequences in seqs are subsequences of it). Determine whether there is only one sequence that can be reconstructed from seqs and it is the org sequence.\n\nExample 1:\n\nInput:\norg: [1,2,3], seqs: [[1,2],[1,3]]\n\nOutput:\nfalse\n\nExplanation:\n[1,2,3] is not the only one sequence that can be reconstructed, because [1,3,2] is also a valid sequence that can be reconstructed.\nExample 2:\n\nInput:\norg: [1,2,3], seqs: [[1,2]]\n\nOutput:\nfalse\n\nExplanation:\nThe reconstructed sequence can only be [1,2].\nExample 3:\n\nInput:\norg: [1,2,3], seqs: [[1,2],[1,3],[2,3]]\n\nOutput:\ntrue\n\nExplanation:\nThe sequences [1,2], [1,3], and [2,3] can uniquely reconstruct the original sequence [1,2,3].\nExample 4:\n\nInput:\norg: [4,1,5,2,6,3], seqs: [[5,2,6,3],[4,1,5,2]]\n\nOutput:\ntrue\nUPDATE (2017/1/8):\nThe seqs parameter had been changed to a list of list of strings (instead of a 2d array of strings). Please reload the code definition to get the latest changes.",
    "Difficulty" : "Medium",
    "Number" : "444",
    "Source" : "LeetCode",
    "Title" : "Sequence Reconstruction"
  }, {
    "Description" : "You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\nFollow up:\nWhat if you cannot modify the input lists? In other words, reversing the lists is not allowed.\n\nExample:\n\nInput: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)\nOutput: 7 -> 8 -> 0 -> 7",
    "Difficulty" : "Medium",
    "Number" : "445",
    "Source" : "LeetCode",
    "Title" : "Add Two Numbers II"
  }, {
    "Description" : "A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, these are arithmetic sequences:\n\n1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9\nThe following sequence is not arithmetic.\n\n1, 1, 2, 5, 7\n\nA zero-indexed array A consisting of N numbers is given. A subsequence slice of that array is any sequence of integers (P0, P1, ..., Pk) such that 0 ≤ P0 < P1 < ... < Pk < N.\n\nA subsequence slice (P0, P1, ..., Pk) of array A is called arithmetic if the sequence A[P0], A[P1], ..., A[Pk-1], A[Pk] is arithmetic. In particular, this means that k ≥ 2.\n\nThe function should return the number of arithmetic subsequence slices in the array A.\n\nThe input contains N integers. Every integer is in the range of -231 and 231-1 and 0 ≤ N ≤ 1000. The output is guaranteed to be less than 231-1.\n\n\nExample:\n\nInput: [2, 4, 6, 8, 10]\n\nOutput: 7\n\nExplanation:\nAll arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]",
    "Difficulty" : "Hard",
    "Number" : "446",
    "Source" : "LeetCode",
    "Title" : "Arithmetic Slices II - Subsequence"
  }, {
    "Description" : "Given n points in the plane that are all pairwise distinct, a \"boomerang\" is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).\n\nFind the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).\n\nExample:\nInput:\n[[0,0],[1,0],[2,0]]\n\nOutput:\n2\n\nExplanation:\nThe two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]",
    "Difficulty" : "Easy",
    "Number" : "447",
    "Source" : "LeetCode",
    "Title" : "Number of Boomerangs"
  }, {
    "Description" : "Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.\n\nFind all the elements of [1, n] inclusive that do not appear in this array.\n\nCould you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.\n\nExample:\n\nInput:\n[4,3,2,7,8,2,3,1]\n\nOutput:\n[5,6]",
    "Difficulty" : "Easy",
    "Number" : "448",
    "Source" : "LeetCode",
    "Title" : "Find All Numbers Disappeared in an Array"
  }, {
    "Description" : "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n\nDesign an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.\n\nThe encoded string should be as compact as possible.\n\nNote: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.",
    "Difficulty" : "Medium",
    "Number" : "449",
    "Source" : "LeetCode",
    "Title" : "Serialize and Deserialize BST"
  }, {
    "Description" : "Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\n\nBasically, the deletion can be divided into two stages:\n\nSearch for a node to remove.\nIf the node is found, delete the node.\nNote: Time complexity should be O(height of tree).\n\nExample:\n\nroot = [5,3,6,2,4,null,7]\nkey = 3\n\n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\nGiven key to delete is 3. So we find the node with value 3 and delete it.\n\nOne valid answer is [5,4,6,2,null,null,7], shown in the following BST.\n\n    5\n   / \\\n  4   6\n /     \\\n2       7\n\nAnother valid answer is [5,2,6,null,4,null,7].\n\n    5\n   / \\\n  2   6\n   \\   \\\n    4   7",
    "Difficulty" : "Medium",
    "Number" : "450",
    "Source" : "LeetCode",
    "Title" : "Delete Node in a BST"
  }, {
    "Description" : "Given a string, sort it in decreasing order based on the frequency of characters.\n\nExample 1:\n\nInput:\n\"tree\"\n\nOutput:\n\"eert\"\n\nExplanation:\n'e' appears twice while 'r' and 't' both appear once.\nSo 'e' must appear before both 'r' and 't'. Therefore \"eetr\" is also a valid answer.\nExample 2:\n\nInput:\n\"cccaaa\"\n\nOutput:\n\"cccaaa\"\n\nExplanation:\nBoth 'c' and 'a' appear three times, so \"aaaccc\" is also a valid answer.\nNote that \"cacaca\" is incorrect, as the same characters must be together.\nExample 3:\n\nInput:\n\"Aabb\"\n\nOutput:\n\"bbAa\"\n\nExplanation:\n\"bbaA\" is also a valid answer, but \"Aabb\" is incorrect.\nNote that 'A' and 'a' are treated as two different characters.",
    "Difficulty" : "Medium",
    "Number" : "451",
    "Source" : "LeetCode",
    "Title" : "Sort Characters By Frequency"
  }, {
    "Description" : "There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.\n\nAn arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.\n\nExample:\n\nInput:\n[[10,16], [2,8], [1,6], [7,12]]\n\nOutput:\n2\n\nExplanation:\nOne way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).",
    "Difficulty" : "Medium",
    "Number" : "452",
    "Source" : "LeetCode",
    "Title" : "Minimum Number of Arrows to Burst Balloons"
  }, {
    "Description" : "Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.\n\nExample:\n\nInput:\n[1,2,3]\n\nOutput:\n3\n\nExplanation:\nOnly three moves are needed (remember each move increments two elements):\n\n[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]",
    "Difficulty" : "Easy",
    "Number" : "453",
    "Source" : "LeetCode",
    "Title" : "Minimum Moves to Equal Array Elements"
  }, {
    "Description" : "Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.\n\nTo make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.\n\nExample:\n\nInput:\nA = [ 1, 2]\nB = [-2,-1]\nC = [-1, 2]\nD = [ 0, 2]\n\nOutput:\n2\n\nExplanation:\nThe two tuples are:\n1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0",
    "Difficulty" : "Medium",
    "Number" : "454",
    "Source" : "LeetCode",
    "Title" : "4Sum II"
  }, {
    "Description" : "Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\n\nNote:\nYou may assume the greed factor is always positive. \nYou cannot assign more than one cookie to one child.\n\nExample 1:\nInput: [1,2,3], [1,1]\n\nOutput: 1\n\nExplanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\nExample 2:\nInput: [1,2], [1,2,3]\n\nOutput: 2\n\nExplanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \nYou have 3 cookies and their sizes are big enough to gratify all of the children, \nYou need to output 2.",
    "Difficulty" : "Easy",
    "Number" : "455",
    "Source" : "LeetCode",
    "Title" : "Assign Cookies"
  }, {
    "Description" : "Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such that i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.\n\nNote: n will be less than 15,000.\n\nExample 1:\nInput: [1, 2, 3, 4]\n\nOutput: False\n\nExplanation: There is no 132 pattern in the sequence.\nExample 2:\nInput: [3, 1, 4, 2]\n\nOutput: True\n\nExplanation: There is a 132 pattern in the sequence: [1, 4, 2].\nExample 3:\nInput: [-1, 3, 2, 0]\n\nOutput: True\n\nExplanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].",
    "Difficulty" : "Medium",
    "Number" : "456",
    "Source" : "LeetCode",
    "Title" : "132 Pattern"
  }, {
    "Description" : "Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.\n\nExample 1:\nInput: \"abab\"\n\nOutput: True\n\nExplanation: It's the substring \"ab\" twice.\nExample 2:\nInput: \"aba\"\n\nOutput: False\nExample 3:\nInput: \"abcabcabcabc\"\n\nOutput: True\n\nExplanation: It's the substring \"abc\" four times. (And the substring \"abcabc\" twice.)",
    "Difficulty" : "Easy",
    "Number" : "459",
    "Source" : "LeetCode",
    "Title" : "Repeated Substring Pattern"
  }, {
    "Description" : "Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put.\n\nget(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\nput(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.\n\nFollow up:\nCould you do both operations in O(1) time complexity?\n\nExample:\n\nLFUCache cache = new LFUCache( 2 /* capacity */ );\n\ncache.put(1, 1);\ncache.put(2, 2);\ncache.get(1);       // returns 1\ncache.put(3, 3);    // evicts key 2\ncache.get(2);       // returns -1 (not found)\ncache.get(3);       // returns 3.\ncache.put(4, 4);    // evicts key 1.\ncache.get(1);       // returns -1 (not found)\ncache.get(3);       // returns 3\ncache.get(4);       // returns 4",
    "Difficulty" : "Hard",
    "Number" : "460",
    "Source" : "LeetCode",
    "Title" : "LFU Cache"
  }, {
    "Description" : "The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n\nGiven two integers x and y, calculate the Hamming distance.\n\nNote:\n0 ≤ x, y < 231.\n\nExample:\n\nInput: x = 1, y = 4\n\nOutput: 2\n\nExplanation:\n1   (0 0 0 1)\n4   (0 1 0 0)\n       ↑   ↑\n\nThe above arrows point to positions where the corresponding bits are different.",
    "Difficulty" : "Easy",
    "Number" : "461",
    "Source" : "LeetCode",
    "Title" : "Hamming Distance"
  }, {
    "Description" : "Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.\n\nYou may assume the array's length is at most 10,000.\n\nExample:\n\nInput:\n[1,2,3]\n\nOutput:\n2\n\nExplanation:\nOnly two moves are needed (remember each move increments or decrements one element):\n\n[1,2,3]  =>  [2,2,3]  =>  [2,2,2]",
    "Difficulty" : "Medium",
    "Number" : "462",
    "Source" : "LeetCode",
    "Title" : "Minimum Moves to Equal Array Elements II"
  }, {
    "Description" : "You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have \"lakes\" (water inside that isn't connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\n\nExample:\n\n[[0,1,0,0],\n [1,1,1,0],\n [0,1,0,0],\n [1,1,0,0]]\n\nAnswer: 16\nExplanation: The perimeter is the 16 yellow stripes in the image below:\n<img src=\"https://leetcode.com/static/images/problemset/island.png\" />",
    "Difficulty" : "Easy",
    "Number" : "463",
    "Source" : "LeetCode",
    "Title" : "Island Perimeter"
  }, {
    "Description" : "In the \"100 game,\" two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.\n\nWhat if we change the game so that players cannot re-use integers?\n\nFor example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total >= 100.\n\nGiven an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally.\n\nYou can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.\n\nExample\n\nInput:\nmaxChoosableInteger = 10\ndesiredTotal = 11\n\nOutput:\nfalse\n\nExplanation:\nNo matter which integer the first player choose, the first player will lose.\nThe first player can choose an integer from 1 up to 10.\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\nSame with other integers chosen by the first player, the second player will always win.",
    "Difficulty" : "Medium",
    "Number" : "464",
    "Source" : "LeetCode",
    "Title" : "Can I Win"
  }, {
    "Description" : "A group of friends went on holiday and sometimes lent each other money. For example, Alice paid for Bill's lunch for $10. Then later Chris gave Alice $5 for a taxi ride. We can model each transaction as a tuple (x, y, z) which means person x gave person y $z. Assuming Alice, Bill, and Chris are person 0, 1, and 2 respectively (0, 1, 2 are the person's ID), the transactions can be represented as [[0, 1, 10], [2, 0, 5]].\n\nGiven a list of transactions between a group of people, return the minimum number of transactions required to settle the debt.\n\nNote:\n\nA transaction will be given as a tuple (x, y, z). Note that x ≠ y and z > 0.\nPerson's IDs may not be linear, e.g. we could have the persons 0, 1, 2 or we could also have the persons 0, 2, 6.\nExample 1:\n\nInput:\n[[0,1,10], [2,0,5]]\n\nOutput:\n2\n\nExplanation:\nPerson #0 gave person #1 $10.\nPerson #2 gave person #0 $5.\n\nTwo transactions are needed. One way to settle the debt is person #1 pays person #0 and #2 $5 each.\nExample 2:\n\nInput:\n[[0,1,10], [1,0,1], [1,2,5], [2,0,5]]\n\nOutput:\n1\n\nExplanation:\nPerson #0 gave person #1 $10.\nPerson #1 gave person #0 $1.\nPerson #1 gave person #2 $5.\nPerson #2 gave person #0 $5.\n\nTherefore, person #1 only need to give person #0 $4, and all debt is settled.",
    "Difficulty" : "Hard",
    "Number" : "465",
    "Source" : "LeetCode",
    "Title" : "Optimal Account Balancing"
  }, {
    "Description" : "Define S = [s,n] as the string S which consists of n connected strings s. For example, [\"abc\", 3] =\"abcabcabc\".\n\nOn the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, “abc” can be obtained from “abdbec” based on our definition, but it can not be obtained from “acbbe”.\n\nYou are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 ≤ n1 ≤ 106 and 1 ≤ n2 ≤ 106. Now consider the strings S1 and S2, where S1=[s1,n1] and S2=[s2,n2]. Find the maximum integer M such that [S2,M] can be obtained from S1.\n\nExample:\n\nInput:\ns1=\"acb\", n1=4\ns2=\"ab\", n2=2\n\nReturn:\n2",
    "Difficulty" : "Hard",
    "Number" : "466",
    "Source" : "LeetCode",
    "Title" : "Count The Repetitions"
  }, {
    "Description" : "Consider the string s to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so s will look like this: \"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".\n\nNow we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s.\n\nNote: p consists of only lowercase English letters and the size of p might be over 10000.\n\nExample 1:\nInput: \"a\"\nOutput: 1\n\nExplanation: Only the substring \"a\" of string \"a\" is in the string \u0010s.\nExample 2:\nInput: \"cac\"\nOutput: 2\nExplanation: There are two substrings \"a\", \"c\" of string \"cac\" in the string s.\nExample 3:\nInput: \"zab\"\nOutput: 6\nExplanation: There are six substrings \"z\", \"a\", \"b\", \"za\", \"ab\", \"zab\" of string \"zab\" in the string s.",
    "Difficulty" : "Medium",
    "Number" : "467",
    "Source" : "LeetCode",
    "Title" : "Unique Substrings in Wraparound String"
  }, {
    "Description" : "Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.\n\nIPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots (\".\"), e.g.,172.16.254.1;\n\nBesides, leading zeros in the IPv4 is invalid. For example, the address 172.16.254.01 is invalid.\n\nIPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (\":\"). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases).\n\nHowever, we don't replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address.\n\nBesides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is invalid.\n\nNote: You may assume there is no extra space or special characters in the input string.\n\nExample 1:\nInput: \"172.16.254.1\"\n\nOutput: \"IPv4\"\n\nExplanation: This is a valid IPv4 address, return \"IPv4\".\nExample 2:\nInput: \"2001:0db8:85a3:0:0:8A2E:0370:7334\"\n\nOutput: \"IPv6\"\n\nExplanation: This is a valid IPv6 address, return \"IPv6\".\nExample 3:\nInput: \"256.256.256.256\"\n\nOutput: \"Neither\"\n\nExplanation: This is neither a IPv4 address nor a IPv6 address.",
    "Difficulty" : "Medium",
    "Number" : "468",
    "Source" : "LeetCode",
    "Title" : "Validate IP Address"
  }, {
    "Description" : "Given a list of points that form a polygon when joined sequentially, find if this polygon is convex (Convex polygon definition).\n\nNote:\n\nThere are at least 3 and at most 10,000 points.\nCoordinates are in the range -10,000 to 10,000.\nYou may assume the polygon formed by given points is always a simple polygon (Simple polygon definition). In other words, we ensure that exactly two edges intersect at each vertex, and that edges otherwise don't intersect each other.\nExample 1:\n\n[[0,0],[0,1],[1,1],[1,0]]\n\nAnswer: True\n\nExplanation:\n<img src=\"https://leetcode.com/static/images/problemset/polygon_convex.png\" width=\"100px\" />\nExample 2:\n\n[[0,0],[0,10],[10,10],[10,0],[5,5]]\n\nAnswer: False\n\nExplanation:\n<img src=\"https://leetcode.com/static/images/problemset/polygon_not_convex.png\" width=\"100px\" />",
    "Difficulty" : "Medium",
    "Number" : "469",
    "Source" : "LeetCode",
    "Title" : "Convex Polygon"
  }, {
    "Description" : "Given a non-empty string, encode the string such that its encoded length is the shortest.\n\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times.\n\nNote:\nk will be a positive integer and encoded string will not be empty or have extra space.\nYou may assume that the input string contains only lowercase English letters. The string's length is at most 160.\nIf an encoding process does not make the string shorter, then do not encode it. If there are several solutions, return any of them is fine.\nExample 1:\n\nInput: \"aaa\"\nOutput: \"aaa\"\nExplanation: There is no way to encode it such that it is shorter than the input string, so we do not encode it.\nExample 2:\n\nInput: \"aaaaa\"\nOutput: \"5[a]\"\nExplanation: \"5[a]\" is shorter than \"aaaaa\" by 1 character.\nExample 3:\n\nInput: \"aaaaaaaaaa\"\nOutput: \"10[a]\"\nExplanation: \"a9[a]\" or \"9[a]a\" are also valid solutions, both of them have the same length = 5, which is the same as \"10[a]\".\nExample 4:\n\nInput: \"aabcaabcd\"\nOutput: \"2[aabc]d\"\nExplanation: \"aabc\" occurs twice, so one answer can be \"2[aabc]d\".\nExample 5:\n\nInput: \"abbbabbbcabbbabbbc\"\nOutput: \"2[2[abbb]c]\"\nExplanation: \"abbbabbbc\" occurs twice, but \"abbbabbbc\" can also be encoded to \"2[abbb]c\", so one answer can be \"2[2[abbb]c]\".",
    "Difficulty" : "Hard",
    "Number" : "471",
    "Source" : "LeetCode",
    "Title" : "Encode String with Shortest Length"
  }, {
    "Description" : "Given a list of words (without duplicates), please write a program that returns all concatenated words in the given list of words.\n\nA concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\n\nExample:\nInput: [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\n\nOutput: [\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\n\nExplanation: \"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\"; \n \"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\"; \n\"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\".\nNote:\nThe number of elements of the given array will not exceed 10,000\nThe length sum of elements in the given array will not exceed 600,000.\nAll the input string will only include lower case letters.\nThe returned elements order does not matter.",
    "Difficulty" : "Hard",
    "Number" : "472",
    "Source" : "LeetCode",
    "Title" : "Concatenated Words"
  }, {
    "Description" : "Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.\n\nYour input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.\n\nExample 1:\nInput: [1,1,2,2,2]\nOutput: true\n\nExplanation: You can form a square with length 2, one side of the square came two sticks with length 1.\nExample 2:\nInput: [3,3,3,3,4]\nOutput: false\n\nExplanation: You cannot find a way to form a square with all the matchsticks.\nNote:\nThe length sum of the given matchsticks is in the range of 0 to 10^9.\nThe length of the given matchstick array will not exceed 15.",
    "Difficulty" : "Medium",
    "Number" : "473",
    "Source" : "LeetCode",
    "Title" : "Matchsticks to Square"
  }, {
    "Description" : "In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.\n\nFor now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.\n\nNow your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.\n\nNote:\nThe given numbers of 0s and 1s will both not exceed 100\nThe size of given string array won't exceed 600.\nExample 1:\nInput: Array = {\"10\", \"0001\", \"111001\", \"1\", \"0\"}, m = 5, n = 3\nOutput: 4\n\nExplanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”\nExample 2:\nInput: Array = {\"10\", \"0\", \"1\"}, m = 1, n = 1\nOutput: 2\n\nExplanation: You could form \"10\", but then you'd have nothing left. Better form \"0\" and \"1\".",
    "Difficulty" : "Medium",
    "Number" : "474",
    "Source" : "LeetCode",
    "Title" : "Ones and Zeroes"
  }, {
    "Description" : "Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses.\n\nNow, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.\n\nSo, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.\n\nNote:\nNumbers of houses and heaters you are given are non-negative and will not exceed 25000.\nPositions of houses and heaters you are given are non-negative and will not exceed 10^9.\nAs long as a house is in the heaters' warm radius range, it can be warmed.\nAll the heaters follow your radius standard and the warm radius will the same.\nExample 1:\nInput: [1,2,3],[2]\nOutput: 1\nExplanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.\nExample 2:\nInput: [1,2,3,4],[1,4]\nOutput: 1\nExplanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.",
    "Difficulty" : "Easy",
    "Number" : "475",
    "Source" : "LeetCode",
    "Title" : "Heaters"
  }, {
    "Description" : "Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.\n\nNote:\nThe given integer is guaranteed to fit within the range of a 32-bit signed integer.\nYou could assume no leading zero bit in the integer’s binary representation.\nExample 1:\nInput: 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\nExample 2:\nInput: 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.",
    "Difficulty" : "Easy",
    "Number" : "476",
    "Source" : "LeetCode",
    "Title" : "Number Complement"
  }, {
    "Description" : "The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n\nNow your job is to find the total Hamming distance between all pairs of the given numbers.\n\nExample:\nInput: 4, 14, 2\n\nOutput: 6\n\nExplanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\nshowing the four bits relevant in this case). So the answer will be:\nHammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\nNote:\nElements of the given array are in the range of 0 to 10^9\nLength of the array will not exceed 10^4.",
    "Difficulty" : "Medium",
    "Number" : "477",
    "Source" : "LeetCode",
    "Title" : "Total Hamming Distance"
  }, {
    "Description" : "Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\n\nExamples: \n[2,3,4] , the median is 3\n\n[2,3], the median is (2 + 3) / 2 = 2.5\n\nGiven an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.\n\nFor example,\nGiven nums = [1,3,-1,-3,5,3,6,7], and k = 3.\n\nWindow position                Median\n---------------               -----\n[1  3  -1] -3  5  3  6  7       1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7       3\n 1  3  -1  -3 [5  3  6] 7       5\n 1  3  -1  -3  5 [3  6  7]      6\nTherefore, return the median sliding window as [1,-1,-1,3,5,6].\n\nNote: \nYou may assume k is always valid, ie: 1 ≤ k ≤ input array's size for non-empty array.",
    "Difficulty" : "Hard",
    "Number" : "480",
    "Source" : "LeetCode",
    "Title" : "Sliding Window Median"
  }, {
    "Description" : "A magical string S consists of only '1' and '2' and obeys the following rules:\n\nThe string S is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string S itself.\n\nThe first few elements of string S is the following: S = \"1221121221221121122……\"\n\nIf we group the consecutive '1's and '2's in S, it will be:\n\n1 22 11 2 1 22 1 22 11 2 11 22 ......\n\nand the occurrences of '1's or '2's in each group are:\n\n1 2\t2 1 1 2 1 2 2 1 2 2 ......\n\nYou can see that the occurrence sequence above is the S itself.\n\nGiven an integer N as input, return the number of '1's in the first N number in the magical string S.\n\nNote: N will not exceed 100,000.\n\nExample 1:\nInput: 6\nOutput: 3\nExplanation: The first 6 elements of magical string S is \"12211\" and it contains three 1's, so return 3.",
    "Difficulty" : "Medium",
    "Number" : "481",
    "Source" : "LeetCode",
    "Title" : "Magical String"
  }, {
    "Description" : "Now you are given a string S, which represents a software license key which we would like to format. The string S is composed of alphanumerical characters and dashes. The dashes split the alphanumerical characters within the string into groups. (i.e. if there are M dashes, the string is split into M+1 groups). The dashes in the given string are possibly misplaced.\n\nWe want each group of characters to be of length K (except for possibly the first group, which could be shorter, but still must contain at least one character). To satisfy this requirement, we will reinsert dashes. Additionally, all the lower case letters in the string must be converted to upper case.\n\nSo, you are given a non-empty string S, representing a license key to format, and an integer K. And you need to return the license key formatted according to the description above.\n\nExample 1:\nInput: S = \"2-4A0r7-4k\", K = 4\n\nOutput: \"24A0-R74K\"\n\nExplanation: The string S has been split into two parts, each part has 4 characters.\nExample 2:\nInput: S = \"2-4A0r7-4k\", K = 3\n\nOutput: \"24-A0R-74K\"\n\nExplanation: The string S has been split into three parts, each part has 3 characters except the first part as it could be shorter as said above.\nNote:\nThe length of string S will not exceed 12,000, and K is a positive integer.\nString S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).\nString S is non-empty.",
    "Difficulty" : "Medium",
    "Number" : "482",
    "Source" : "LeetCode",
    "Title" : "License Key Formatting"
  }, {
    "Description" : "For an integer n, we call k>=2 a good base of n, if all digits of n base k are 1.\n\nNow given a string representing n, you should return the smallest good base of n in string format. \n\nExample 1:\nInput: \"13\"\nOutput: \"3\"\nExplanation: 13 base 3 is 111.\nExample 2:\nInput: \"4681\"\nOutput: \"8\"\nExplanation: 4681 base 8 is 11111.\nExample 3:\nInput: \"1000000000000000000\"\nOutput: \"999999999999999999\"\nExplanation: 1000000000000000000 base 999999999999999999 is 11.\nNote:\nThe range of n is [3, 10^18].\nThe string representing n is always valid and will not have leading zeros.",
    "Difficulty" : "Hard",
    "Number" : "483",
    "Source" : "LeetCode",
    "Title" : "Smallest Good Base"
  }, {
    "Description" : "By now, you are given a secret signature consisting of character 'D' and 'I'. 'D' represents a decreasing relationship between two numbers, 'I' represents an increasing relationship between two numbers. And our secret signature was constructed by a special integer array, which contains uniquely all the different number from 1 to n (n is the length of the secret signature plus 1). For example, the secret signature \"DI\" can be constructed by array [2,1,3] or [3,1,2], but won't be constructed by array [3,2,4] or [2,1,3,4], which are both illegal constructing special string that can't represent the \"DI\" secret signature.\n\nOn the other hand, now your job is to find the lexicographically smallest permutation of [1, 2, ... n] could refer to the given secret signature in the input.\n\nExample 1:\nInput: \"I\"\nOutput: [1,2]\nExplanation: [1,2] is the only legal initial spectial string can construct secret signature \"I\", where the number 1 and 2 construct an increasing relationship.\nExample 2:\nInput: \"DI\"\nOutput: [2,1,3]\nExplanation: Both [2,1,3] and [3,1,2] can construct the secret signature \"DI\", \nbut since we want to find the one with the smallest lexicographical permutation, you need to output [2,1,3]\nNote:\n\nThe input string will only contain the character 'D' and 'I'.\nThe length of input string is a positive integer and will not exceed 10,000",
    "Difficulty" : "Medium",
    "Number" : "484",
    "Source" : "LeetCode",
    "Title" : "Find Permutation"
  }, {
    "Description" : "Given a binary array, find the maximum number of consecutive 1s in this array.\n\nExample 1:\nInput: [1,1,0,1,1,1]\nOutput: 3\nExplanation: The first two digits or the last three digits are consecutive 1s.\n    The maximum number of consecutive 1s is 3.\nNote:\n\nThe input array will only contain 0 and 1.\nThe length of input array is a positive integer and will not exceed 10,000",
    "Difficulty" : "Easy",
    "Number" : "485",
    "Source" : "LeetCode",
    "Title" : "Max Consecutive Ones"
  }, {
    "Description" : "Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.\n\nGiven an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.\n\nExample 1:\nInput: [1, 5, 2]\nOutput: False\nExplanation: Initially, player 1 can choose between 1 and 2. \nIf he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). \nSo, final score of player 1 is 1 + 2 = 3, and player 2 is 5. \nHence, player 1 will never be the winner and you need to return False.\nExample 2:\nInput: [1, 5, 233, 7]\nOutput: True\nExplanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.\nFinally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\nNote:\n1 <= length of the array <= 20.\nAny scores in the given array are non-negative integers and will not exceed 10,000,000.\nIf the scores of both players are equal, then player 1 is still the winner.",
    "Difficulty" : "Medium",
    "Number" : "486",
    "Source" : "LeetCode",
    "Title" : "Predict the Winner"
  }, {
    "Description" : "Given a binary array, find the maximum number of consecutive 1s in this array if you can flip at most one 0.\n\nExample 1:\nInput: [1,0,1,1,0]\nOutput: 4\nExplanation: Flip the first zero will get the the maximum number of consecutive 1s.\n    After flipping, the maximum number of consecutive 1s is 4.\nNote:\n\nThe input array will only contain 0 and 1.\nThe length of input array is a positive integer and will not exceed 10,000\nFollow up:\nWhat if the input numbers come in one by one as an infinite stream? In other words, you can't store all numbers coming from the stream as it's too large to hold in memory. Could you solve it efficiently?",
    "Difficulty" : "Medium",
    "Number" : "487",
    "Source" : "LeetCode",
    "Title" : "Max Consecutive Ones II"
  }, {
    "Description" : "Think about Zuma Game. You have a row of balls on the table, colored red(R), yellow(Y), blue(B), green(G), and white(W). You also have several balls in your hand.\n\nEach time, you may choose a ball in your hand, and insert it into the row (including the leftmost place and rightmost place). Then, if there is a group of 3 or more balls in the same color touching, remove these balls. Keep doing this until no more balls can be removed.\n\nFind the minimal balls you have to insert to remove all the balls on the table. If you cannot remove all the balls, output -1.\n\nExamples:\n\nInput: \"WRRBBW\", \"RB\"\nOutput: -1\nExplanation: WRRBBW -> WRR[R]BBW -> WBBW -> WBB[B]W -> WW\n\nInput: \"WWRRBBWW\", \"WRBRW\"\nOutput: 2\nExplanation: WWRRBBWW -> WWRR[R]BBWW -> WWBBWW -> WWBB[B]WW -> WWWW -> empty\n\nInput:\"G\", \"GGGGG\"\nOutput: 2\nExplanation: G -> G[G] -> GG[G] -> empty \n\nInput: \"RBYYBBRRB\", \"YRBGB\"\nOutput: 3\nExplanation: RBYYBBRRB -> RBYY[Y]BBRRB -> RBBBRRB -> RRRB -> B -> B[B] -> BB[B] -> empty \n\nNote:\nYou may assume that the initial row of balls on the table won’t have any 3 or more consecutive balls with the same color.\nThe number of balls on the table won't exceed 20, and the string represents these balls is called \"board\" in the input.\nThe number of balls in your hand won't exceed 5, and the string represents these balls is called \"hand\" in the input.\nBoth input strings will be non-empty and only contain characters 'R','Y','B','G','W'.",
    "Difficulty" : "Hard",
    "Number" : "488",
    "Source" : "LeetCode",
    "Title" : "Zuma Game"
  }, {
    "Description" : "There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.\n\nGiven the ball's start position, the destination and the maze, determine whether the ball could stop at the destination.\n\nThe maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.\n\nExample 1\n\nInput 1: a maze represented by a 2D array\n\n0 0 1 0 0\n0 0 0 0 0\n0 0 0 1 0\n1 1 0 1 1\n0 0 0 0 0\n\nInput 2: start coordinate (rowStart, colStart) = (0, 4)\nInput 3: destination coordinate (rowDest, colDest) = (4, 4)\n\nOutput: true\nExplanation: One possible way is : left -> down -> left -> down -> right -> down -> right.\n<img src=\"https://leetcode.com/static/images/problemset/maze_1_example_1.png\" />\n\nExample 2\n\nInput 1: a maze represented by a 2D array\n\n0 0 1 0 0\n0 0 0 0 0\n0 0 0 1 0\n1 1 0 1 1\n0 0 0 0 0\n\nInput 2: start coordinate (rowStart, colStart) = (0, 4)\nInput 3: destination coordinate (rowDest, colDest) = (3, 2)\n\nOutput: false\nExplanation: There is no way for the ball to stop at the destination.\n<img src=\"https://leetcode.com/static/images/problemset/maze_1_example_2.png\" />\n\nNote:\nThere is only one ball and one destination in the maze.\nBoth the ball and the destination exist on an empty space, and they will not be at the same position initially.\nThe given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.\nThe maze contains at least 2 empty spaces, and both the width and height of the maze won't exceed 100.",
    "Difficulty" : "Medium",
    "Number" : "490",
    "Source" : "LeetCode",
    "Title" : "The Maze"
  }, {
    "Description" : "Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .\n\nExample:\nInput: [4, 6, 7, 7]\nOutput: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]\nNote:\nThe length of the given array will not exceed 15.\nThe range of integer in the given array is [-100,100].\nThe given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.",
    "Difficulty" : "Medium",
    "Number" : "491",
    "Source" : "LeetCode",
    "Title" : "Increasing Subsequences"
  }, {
    "Description" : "For a web developer, it is very important to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:\n\n1. The area of the rectangular web page you designed must equal to the given target area.\n\n2. The width W should not be larger than the length L, which means L >= W.\n\n3. The difference between length L and width W should be as small as possible.\nYou need to output the length L and the width W of the web page you designed in sequence.\nExample:\nInput: 4\nOutput: [2, 2]\nExplanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. \nBut according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.\nNote:\nThe given area won't exceed 10,000,000 and is a positive integer\nThe web page's width and length you designed must be positive integers.",
    "Difficulty" : "Easy",
    "Number" : "492",
    "Source" : "LeetCode",
    "Title" : "Construct the Rectangle"
  }, {
    "Description" : "You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.\n\nFind out how many ways to assign symbols to make sum of integers equal to target S.\n\nExample 1:\nInput: nums is [1, 1, 1, 1, 1], S is 3. \nOutput: 5\nExplanation: \n\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n\nThere are 5 ways to assign symbols to make the sum of nums be target 3.\nNote:\nThe length of the given array is positive and will not exceed 20.\nThe sum of elements in the given array will not exceed 1000.\nYour output answer is guaranteed to be fitted in a 32-bit integer.",
    "Difficulty" : "Medium",
    "Number" : "494",
    "Source" : "LeetCode",
    "Title" : "Target Sum"
  }, {
    "Description" : "In LLP world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking ascending time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition.\n\nYou may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.\n\nExample 1:\nInput: [1,4], 2\nOutput: 4\nExplanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. \nThis poisoned status will last 2 seconds until the end of time point 2. \nAnd at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. \nSo you finally need to output 4.\nExample 2:\nInput: [1,2], 2\nOutput: 3\nExplanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. \nThis poisoned status will last 2 seconds until the end of time point 2. \nHowever, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. \nSince the poisoned status won't add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. \nSo you finally need to output 3.\nNote:\nYou may assume the length of given time series array won't exceed 10000.\nYou may assume the numbers in the Teemo's attacking time series and his poisoning time duration per attacking are non-negative integers, which won't exceed 10,000,000.",
    "Difficulty" : "Medium",
    "Number" : "495",
    "Source" : "LeetCode",
    "Title" : "Teemo Attacking"
  }, {
    "Description" : "You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2.\n\nThe Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.\n\nExample 1:\nInput: nums1 = [4,1,2], nums2 = [1,3,4,2].\nOutput: [-1,3,-1]\nExplanation:\n    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.\n    For number 1 in the first array, the next greater number for it in the second array is 3.\n    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.\nExample 2:\nInput: nums1 = [2,4], nums2 = [1,2,3,4].\nOutput: [3,-1]\nExplanation:\n    For number 2 in the first array, the next greater number for it in the second array is 3.\n    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.\nNote:\nAll elements in nums1 and nums2 are unique.\nThe length of both nums1 and nums2 would not exceed 1000.",
    "Difficulty" : "Easy",
    "Number" : "496",
    "Source" : "LeetCode",
    "Title" : "Next Greater Element I"
  }, {
    "Description" : "Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.\n\nExample:\nInput:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\nOutput:  [1,2,4,7,5,3,6,8,9]\nExplanation:\n\nNote:\nThe total number of elements of the given matrix will not exceed 10,000.",
    "Difficulty" : "Medium",
    "Number" : "498",
    "Source" : "LeetCode",
    "Title" : "Diagonal Traverse"
  }, {
    "Description" : "There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up (u), down (d), left (l) or right (r), but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction. There is also a hole in this maze. The ball will drop into the hole if it rolls on to the hole.\n\nGiven the ball position, the hole position and the maze, find out how the ball could drop into the hole by moving the shortest distance. The distance is defined by the number of empty spaces traveled by the ball from the start position (excluded) to the hole (included). Output the moving directions by using 'u', 'd', 'l' and 'r'. Since there could be several different shortest ways, you should output the lexicographically smallest way. If the ball cannot reach the hole, output \"impossible\".\n\nThe maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The ball and the hole coordinates are represented by row and column indexes.\n\nExample 1\n\nInput 1: a maze represented by a 2D array\n\n0 0 0 0 0\n1 1 0 0 1\n0 0 0 0 0\n0 1 0 0 1\n0 1 0 0 0\n\nInput 2: ball coordinate (rowBall, colBall) = (4, 3)\nInput 3: hole coordinate (rowHole, colHole) = (0, 1)\n\nOutput: \"lul\"\nExplanation: There are two shortest ways for the ball to drop into the hole.\nThe first way is left -> up -> left, represented by \"lul\".\nThe second way is up -> left, represented by 'ul'.\nBoth ways have shortest distance 6, but the first way is lexicographically smaller because 'l' < 'u'. So the output is \"lul\".\n<img src=\"https://leetcode.com/static/images/problemset/maze_2_example_1.png\" width=\"500px\" />\n\nExample 2\n\nInput 1: a maze represented by a 2D array\n\n0 0 0 0 0\n1 1 0 0 1\n0 0 0 0 0\n0 1 0 0 1\n0 1 0 0 0\n\nInput 2: ball coordinate (rowBall, colBall) = (4, 3)\nInput 3: hole coordinate (rowHole, colHole) = (3, 0)\nOutput: \"impossible\"\nExplanation: The ball cannot reach the hole.\n<img src=\"https://leetcode.com/static/images/problemset/maze_2_example_2.png\" width=\"500px\" />\n\nNote:\nThere is only one ball and one hole in the maze.\nBoth the ball and hole exist on an empty space, and they will not be at the same position initially.\nThe given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.\nThe maze contains at least 2 empty spaces, and the width and the height of the maze won't exceed 30.",
    "Difficulty" : "Hard",
    "Number" : "499",
    "Source" : "LeetCode",
    "Title" : "The Maze III"
  }, {
    "Description" : "Given a List of words, return the words that can be typed using letters of alphabet on only one row's of American keyboard like the image below.\n\n\nAmerican keyboard\n<img src=\"https://leetcode.com/static/images/problemset/keyboard.png\" width=\"600px;\" />\n\nExample 1:\nInput: [\"Hello\", \"Alaska\", \"Dad\", \"Peace\"]\nOutput: [\"Alaska\", \"Dad\"]\nNote:\nYou may use one character in the keyboard more than once.\nYou may assume the input string will only contain letters of alphabet.",
    "Difficulty" : "Easy",
    "Number" : "500",
    "Source" : "LeetCode",
    "Title" : "Keyboard Row"
  }, {
    "Description" : "Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.\n\nAssume a BST is defined as follows:\n\nThe left subtree of a node contains only nodes with keys less than or equal to the node's key.\nThe right subtree of a node contains only nodes with keys greater than or equal to the node's key.\nBoth the left and right subtrees must also be binary search trees.\nFor example:\nGiven BST [1,null,2,2],\n   1\n    \\\n     2\n    /\n   2\nreturn [2].\n\nNote: If a tree has more than one mode, you can return them in any order.\n\nFollow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).",
    "Difficulty" : "Easy",
    "Number" : "501",
    "Source" : "LeetCode",
    "Title" : "Find Mode in Binary Search Tree"
  }, {
    "Description" : "Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.\n\nYou are given several projects. For each project i, it has a pure profit Pi and a minimum capital of Ci is needed to start the corresponding project. Initially, you have W capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\n\nTo sum up, pick a list of at most k distinct projects from given projects to maximize your final capital, and output your final maximized capital.\n\nExample 1:\nInput: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].\n\nOutput: 4\n\nExplanation: Since your initial capital is 0, you can only start the project indexed 0.\n             After finishing it you will obtain profit 1 and your capital becomes 1.\n             With capital 1, you can either start the project indexed 1 or the project indexed 2.\n             Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\n             Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\nNote:\nYou may assume all numbers in the input are non-negative integers.\nThe length of Profits array and Capital array will not exceed 50,000.\nThe answer is guaranteed to fit in a 32-bit signed integer.",
    "Difficulty" : "Hard",
    "Number" : "502",
    "Source" : "LeetCode",
    "Title" : "IPO"
  }, {
    "Description" : "Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number.\n\nExample 1:\nInput: [1,2,1]\nOutput: [2,-1,2]\nExplanation: The first 1's next greater number is 2; \nThe number 2 can't find next greater number; \nThe second 1's next greater number needs to search circularly, which is also 2.\nNote: The length of given array won't exceed 10000.",
    "Difficulty" : "Medium",
    "Number" : "503",
    "Source" : "LeetCode",
    "Title" : "Next Greater Element II"
  }, {
    "Description" : "There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.\n\nGiven the ball's start position, the destination and the maze, find the shortest distance for the ball to stop at the destination. The distance is defined by the number of empty spaces traveled by the ball from the start position (excluded) to the destination (included). If the ball cannot stop at the destination, return -1.\n\nThe maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.\n\nExample 1\n\nInput 1: a maze represented by a 2D array\n\n0 0 1 0 0\n0 0 0 0 0\n0 0 0 1 0\n1 1 0 1 1\n0 0 0 0 0\n\nInput 2: start coordinate (rowStart, colStart) = (0, 4)\nInput 3: destination coordinate (rowDest, colDest) = (4, 4)\n\nOutput: 12\nExplanation: One shortest way is : left -> down -> left -> down -> right -> down -> right.\n             The total distance is 1 + 1 + 3 + 1 + 2 + 2 + 2 = 12.\n<img src=\"https://leetcode.com/static/images/problemset/maze_1_example_1.png\" width=\"500px\" />\n\nExample 2\n\nInput 1: a maze represented by a 2D array\n\n0 0 1 0 0\n0 0 0 0 0\n0 0 0 1 0\n1 1 0 1 1\n0 0 0 0 0\n\nInput 2: start coordinate (rowStart, colStart) = (0, 4)\nInput 3: destination coordinate (rowDest, colDest) = (3, 2)\n\nOutput: -1\nExplanation: There is no way for the ball to stop at the destination.\n<img src=\"https://leetcode.com/static/images/problemset/maze_1_example_2.png\" width=\"500px\" />\n\nNote:\nThere is only one ball and one destination in the maze.\nBoth the ball and the destination exist on an empty space, and they will not be at the same position initially.\nThe given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.\nThe maze contains at least 2 empty spaces, and both the width and height of the maze won't exceed 100.",
    "Difficulty" : "Medium",
    "Number" : "505",
    "Source" : "LeetCode",
    "Title" : "The Maze II"
  }, {
    "Description" : "Given scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: \"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\".\n\nExample 1:\nInput: [5, 4, 3, 2, 1]\nOutput: [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"]\nExplanation: The first three athletes got the top three highest scores, so they got \"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\". \nFor the left two athletes, you just need to output their relative ranks according to their scores.\nNote:\nN is a positive integer and won't exceed 10,000.\nAll the scores of athletes are guaranteed to be unique.",
    "Difficulty" : "Easy",
    "Number" : "506",
    "Source" : "LeetCode",
    "Title" : "Relative Ranks"
  }, {
    "Description" : "Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.\n\nExamples 1\nInput:\n\n  5\n /  \\\n2   -3\nreturn [2, -3, 4], since all the values happen only once, return all of them in any order.\nExamples 2\nInput:\n\n  5\n /  \\\n2   -5\nreturn [2], since 2 happens twice, however -5 only occur once.\nNote: You may assume the sum of values in any subtree is in the range of 32-bit signed integer.",
    "Difficulty" : "Medium",
    "Number" : "508",
    "Source" : "LeetCode",
    "Title" : "Most Frequent Subtree Sum"
  } ],
  "Linux" : [ {
    "expanded" : true,
    "files" : [ {
      "content" : "-t  # 指定排序时所用的栏位分隔字符\n-n  # 依照数值的大小排序\n-r  # 以相反的顺序来排序\n-f  # 排序时，将小写字母视为大写字母\n-d  # 排序时，处理英文字母、数字及空格字符外，忽略其他的字符\n-c  # 检查文件是否已经按照顺序排序\n-b  # 忽略每行前面开始处的空格字符\n-M  # 前面3个字母依照月份的缩写进行排序\n-k  # 指定域\n-m  # 将几个排序好的文件进行合并\n-T  # 指定临时文件目录,默认在/tmp\n+<起始栏位>-<结束栏位>   # 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。\n-o  # 将排序后的结果存入指定的文\n\nsort -n               # 按数字排序\nsort -nr              # 按数字倒叙\nsort -u               # 过滤重复行\nsort -m a.txt c.txt   # 将两个文件内容整合到一起\nsort -n -t' ' -k 2 -k 3 a.txt     # 第二域相同，将从第三域进行升降处理\nsort -n -t':' -k 3r a.txt         # 以:为分割域的第三域进行倒叙排列\nsort -k 1.3 a.txt                 # 从第三个字母起进行排序\nsort -t\" \" -k 2n -u  a.txt        # 以第二域进行排序，如果遇到重复的，就删除",
      "name" : "sort"
    }, {
      "content" : "# linux文件无创建时间\n# Access 使用时间\n# Modify 内容修改时间\n# Change 状态改变时间(权限、属主)\n# 时间默认以24小时为单位,当前时间到向前24小时为0天,向前48-72小时为2天\n# -and 且 匹配两个条件 参数可以确定时间范围 -mtime +2 -and -mtime -4\n# -or 或 匹配任意一个条件\n\nfind /etc -name \"*http*\"     # 按文件名查找\nfind . -type f               # 查找某一类型文件\nfind / -perm                 # 按照文件权限查找\nfind / -user                 # 按照文件属主查找\nfind / -group                # 按照文件所属的组来查找文件\nfind / -atime -n             # 文件使用时间在N天以内\nfind / -atime +n             # 文件使用时间在N天以前\nfind / -mtime +n             # 文件内容改变时间在N天以前\nfind / -ctime +n             # 文件状态改变时间在N天前\nfind / -mmin +30             # 按分钟查找内容改变\nfind / -size +1000000c -print                           # 查找文件长度大于1M字节的文件\nfind /etc -name \"*passwd*\" -exec grep \"xuesong\" {} \\;   # 按名字查找文件传递给-exec后命令\nfind . -name 't*' -exec basename {} \\;                  # 查找文件名,不取路径\nfind . -type f -name \"err*\" -exec  rename err ERR {} \\; # 批量改名(查找err 替换为 ERR {}文件\nfind 路径 -name *name1* -or -name *name2*               # 查找任意一个关键字",
      "name" : "find"
    }, {
      "content" : "tar zxvpf gz.tar.gz -C 放到指定目录 包中的目录       # 解包tar.gz 不指定目录则全解压\ntar zcvpf /$path/gz.tar.gz * # 打包gz 注意*最好用相对路径\ntar zcf /$path/gz.tar.gz *   # 打包正确不提示\ntar ztvpf gz.tar.gz          # 查看gz\ntar xvf 1.tar -C 目录         # 解包tar\ntar -cvf 1.tar *             # 打包tar\ntar tvf 1.tar                # 查看tar\ntar -rvf 1.tar 文件名         # 给tar追加文件\ntar --exclude=/home/dmtsai --exclude=*.tar -zcvf myfile.tar.gz /home/* /etc      # 打包/home, /etc ，但排除 /home/dmtsai\ntar -N \"2005/06/01\" -zcvf home.tar.gz /home      # 在 /home 当中，比 2005/06/01 新的文件才备份\ntar -zcvfh home.tar.gz /home                     # 打包目录中包括连接目录\ntar zcf - ./ | ssh root@IP \"tar zxf - -C /xxxx\"  # 一边压缩一边解压\nzgrep 字符 1.gz               # 查看压缩包中文件字符行\nbzip2  -dv 1.tar.bz2         # 解压bzip2\nbzip2 -v 1.tar               # bzip2压缩\nbzcat                        # 查看bzip2\ngzip A                       # 直接压缩文件 # 压缩后源文件消失\ngunzip A.gz                  # 直接解压文件 # 解压后源文件消失\ngzip -dv 1.tar.gz            # 解压gzip到tar\ngzip -v 1.tar                # 压缩tar到gz\nunzip zip.zip                # 解压zip\nzip zip.zip *                # 压缩zip\n# rar3.6下载:  http://www.rarsoft.com/rar/rarlinux-3.6.0.tar.gz\nrar a rar.rar *.jpg          # 压缩文件为rar包\nunrar x rar.rar              # 解压rar包\n7z a 7z.7z *                 # 7z压缩\n7z e 7z.7z                   # 7z解压",
      "name" : "tar"
    }, {
      "content" : "rpm -ivh lynx          # rpm安装\nrpm -e lynx            # 卸载包\nrpm -e lynx --nodeps   # 强制卸载\nrpm -qa                # 查看所有安装的rpm包\nrpm -qa | grep lynx    # 查找包是否安装\nrpm -ql                # 软件包路径\nrpm -Uvh               # 升级包\nrpm --test lynx        # 测试\nrpm -qc                # 软件包配置文档\nrpm --import  /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6     # 导入rpm的签名信息\nrpm --initdb           # 初始化rpm 数据库\nrpm --rebuilddb        # 重建rpm数据库  在rpm和yum无响应的情况使用 先 rm -f /var/lib/rpm/__db.00* 在重建",
      "name" : "rpm"
    }, {
      "content" : "yum list                 # 所有软件列表\nyum install 包名          # 安装包和依赖包\nyum -y update            # 升级所有包版本,依赖关系，系统版本内核都升级\nyum -y update 软件包名    # 升级指定的软件包\nyum -y upgrade           # 不改变软件设置更新软件，系统版本升级，内核不改变\nyum search mail          # yum搜索相关包\nyum grouplist            # 软件包组\nyum -y groupinstall \"Virtualization\"   # 安装软件包组\nrepoquery -ql gstreamer  # 不安装软件查看包含文件\nyum clean all            # 清除var下缓存\n\nyum使用epel源{\n\n    # 包下载地址: http://download.fedoraproject.org/pub/epel   # 选择版本5\\6\\7\n    rpm -Uvh  http://mirrors.hustunique.com/epel//6/x86_64/epel-release-6-8.noarch.rpm\n\n    # 自适配版本\n    yum install epel-release\n\n}\n\n自定义yum源{\n\n    find /etc/yum.repos.d -name \"*.repo\" -exec mv {} {}.bak \\;\n\n    vim /etc/yum.repos.d/yum.repo\n    [yum]\n    #http\n    baseurl=http://10.0.0.1/centos5.5\n    #挂载iso\n    #mount -o loop CentOS-5.8-x86_64-bin-DVD-1of2.iso /data/iso/\n    #本地\n    #baseurl=file:///data/iso/\n    enable=1\n\n    #导入key\n    rpm --import  /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5\n\n}",
      "name" : "yum"
    }, {
      "content" : "源码安装{\n    ./configure --help                   # 查看所有编译参数\n    ./configure  --prefix=/usr/local/    # 配置参数\n    make                                 # 编译\n    # make -j 8                          # 多线程编译,速度较快,但有些软件不支持\n    make install                         # 安装包\n    make clean                           # 清除编译结果\n}\n\nperl程序编译{\n    perl Makefile.PL\n    make\n    make test\n    make install\n}\n\npython程序编译{\n    python file.py\n\n    # 源码包编译安装\n    python setup.py build\n    python setup.py install\n}\n\n编译c程序{\n    gcc -g hello.c -o hello\n}",
      "name" : "compile"
    }, {
      "content" : "星期日[SUN] 星期一[MON] 星期二[TUE] 星期三[WED] 星期四[THU] 星期五[FRI] 星期六[SAT]\n一月[JAN] 二月[FEB] 三月[MAR] 四月[APR] 五月[MAY] 六月[JUN] 七月[JUL] 八月[AUG] 九月[SEP] 十月[OCT] 十一月[NOV] 十二月[DEC]\n\ndate -s 20091112                     # 设日期\ndate -s 18:30:50                     # 设时间\ndate -d \"7 days ago\" +%Y%m%d         # 7天前日期\ndate -d \"5 minute ago\" +%H:%M        # 5分钟前时间\ndate -d \"1 month ago\" +%Y%m%d        # 一个月前\ndate -d '1 days' +%Y-%m-%d           # 一天后\ndate -d '1 hours' +%H:%M:%S          # 一小时后\ndate +%Y-%m-%d -d '20110902'         # 日期格式转换\ndate +%Y-%m-%d_%X                    # 日期和时间\ndate +%N                             # 纳秒\ndate -d \"2012-08-13 14:00:23\" +%s    # 换算成秒计算(1970年至今的秒数)\ndate -d \"@1363867952\" +%Y-%m-%d-%T   # 将时间戳换算成日期\ndate -d \"1970-01-01 UTC 1363867952 seconds\" +%Y-%m-%d-%T  # 将时间戳换算成日期\ndate -d \"`awk -F. '{print $1}' /proc/uptime` second ago\" +\"%Y-%m-%d %H:%M:%S\"    # 格式化系统启动时间(多少秒前)",
      "name" : "date"
    }, {
      "content" : "ulimit -SHn 65535  # 临时设置文件描述符大小 进程最大打开文件柄数 还有socket最大连接数, 等同配置 nofile\nulimit -SHu 65535  # 临时设置用户最大进程数\nulimit -a          # 查看\n\n/etc/security/limits.conf\n\n# 文件描述符大小  open files\n# lsof |wc -l   查看当前文件句柄数使用数量\n* soft nofile 16384         # 设置太大，进程使用过多会把机器拖死\n* hard nofile 32768\n\n# 用户最大进程数  max user processes\n# echo $((`ps uxm |wc -l`-`ps ux |wc -l`))  查看当前用户占用的进程数 [包括线程]\nuser soft nproc 16384\nuser hard nproc 32768\n\n# 如果/etc/security/limits.d/有配置文件，将会覆盖/etc/security/limits.conf里的配置\n# 即/etc/security/limits.d/的配置文件里就不要有同样的参量设置\n/etc/security/limits.d/90-nproc.conf    # centos6.3的默认这个文件会覆盖 limits.conf\nuser soft nproc 16384\nuser hard nproc 32768\n\nsysctl -p    # 修改配置文件后让系统生效",
      "name" : "limits"
    }, {
      "content" : "内建三个表：nat mangle 和 filter\nfilter预设规则表，有INPUT、FORWARD 和 OUTPUT 三个规则链\nvi /etc/sysconfig/iptables    # 配置文件\nINPUT    # 进入\nFORWARD  # 转发\nOUTPUT   # 出去\nACCEPT   # 将封包放行\nREJECT   # 拦阻该封包\nDROP     # 丢弃封包不予处理\n-A       # 在所选择的链(INPUT等)末添加一条或更多规则\n-D       # 删除一条\n-E       # 修改\n-p       # tcp、udp、icmp    0相当于所有all    !取反\n-P       # 设置缺省策略(与所有链都不匹配强制使用此策略)\n-s       # IP/掩码    (IP/24)    主机名、网络名和清楚的IP地址 !取反\n-j       # 目标跳转，立即决定包的命运的专用内建目标\n-i       # 进入的（网络）接口 [名称] eth0\n-o       # 输出接口[名称]\n-m       # 模块\n--sport  # 源端口\n--dport  # 目标端口\n\niptables -F                        # 将防火墙中的规则条目清除掉  # 注意: iptables -P INPUT ACCEPT\niptables-restore < 规则文件        # 导入防火墙规则\n/etc/init.d/iptables save          # 保存防火墙设置\n/etc/init.d/iptables restart       # 重启防火墙服务\niptables -L -n                     # 查看规则\niptables -t nat -nL                # 查看转发\n\niptables实例{\n\n    iptables -L INPUT                   # 列出某规则链中的所有规则\n    iptables -X allowed                 # 删除某个规则链 ,不加规则链，清除所有非内建的\n    iptables -Z INPUT                   # 将封包计数器归零\n    iptables -N allowed                 # 定义新的规则链\n    iptables -P INPUT DROP              # 定义过滤政策\n    iptables -A INPUT -s 192.168.1.1    # 比对封包的来源IP   # ! 192.168.0.0/24  ! 反向对比\n    iptables -A INPUT -d 192.168.1.1    # 比对封包的目的地IP\n    iptables -A INPUT -i eth0           # 比对封包是从哪片网卡进入\n    iptables -A FORWARD -o eth0         # 比对封包要从哪片网卡送出 eth+表示所有的网卡\n    iptables -A INPUT -p tcp            # -p ! tcp 排除tcp以外的udp、icmp。-p all所有类型\n    iptables -D INPUT 8                 # 从某个规则链中删除一条规则\n    iptables -D INPUT --dport 80 -j DROP         # 从某个规则链中删除一条规则\n    iptables -R INPUT 8 -s 192.168.0.1 -j DROP   # 取代现行规则\n    iptables -I INPUT 8 --dport 80 -j ACCEPT     # 插入一条规则\n    iptables -A INPUT -i eth0 -j DROP            # 其它情况不允许\n    iptables -A INPUT -p tcp -s IP -j DROP       # 禁止指定IP访问\n    iptables -A INPUT -p tcp -s IP --dport port -j DROP               # 禁止指定IP访问端口\n    iptables -A INPUT -s IP -p tcp --dport port -j ACCEPT             # 允许在IP访问指定端口\n    iptables -A INPUT -p tcp --dport 22 -j DROP                       # 禁止使用某端口\n    iptables -A INPUT -i eth0 -p icmp -m icmp --icmp-type 8 -j DROP   # 禁止icmp端口\n    iptables -A INPUT -i eth0 -p icmp -j DROP                         # 禁止icmp端口\n    iptables -t filter -A INPUT -i eth0 -p tcp --syn -j DROP                  # 阻止所有没有经过你系统授权的TCP连接\n    iptables -A INPUT -f -m limit --limit 100/s --limit-burst 100 -j ACCEPT   # IP包流量限制\n    iptables -A INPUT -i eth0 -s 192.168.62.1/32 -p icmp -m icmp --icmp-type 8 -j ACCEPT  # 除192.168.62.1外，禁止其它人ping我的主机\n    iptables -A INPUT -p tcp -m tcp --dport 80 -m state --state NEW -m recent --update --seconds 5 --hitcount 20 --rttl --name WEB --rsource -j DROP  # 可防御cc攻击(未测试)\n\n}\n\niptables配置实例文件{\n\n    # Generated by iptables-save v1.2.11 on Fri Feb  9 12:10:37 2007\n    *filter\n    :INPUT ACCEPT [637:58967]\n    :FORWARD DROP [0:0]\n    :OUTPUT ACCEPT [5091:1301533]\n    # 允许的IP或IP段访问 建议多个\n    -A INPUT -s 127.0.0.1 -p tcp -j ACCEPT\n    -A INPUT -s 192.168.0.0/255.255.0.0 -p tcp -j ACCEPT\n    # 开放对外开放端口\n    -A INPUT -p tcp --dport 80 -j ACCEPT\n    # 指定某端口针对IP开放\n    -A INPUT -s 192.168.10.37 -p tcp --dport 22 -j ACCEPT\n    # 拒绝所有协议(INPUT允许)\n    -A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,PSH,URG RST -j DROP\n    # 允许已建立的或相关连的通行\n    -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n    # 拒绝ping\n    -A INPUT -p tcp -m tcp -j REJECT --reject-with icmp-port-unreachable\n    COMMIT\n    # Completed on Fri Feb  9 12:10:37 2007\n\n}\n\niptables配置实例{\n\n    # 允许某段IP访问任何端口\n    iptables -A INPUT -s 192.168.0.3/24 -p tcp -j ACCEPT\n    # 设定预设规则 (拒绝所有的数据包，再允许需要的,如只做WEB服务器.还是推荐三个链都是DROP)\n    iptables -P INPUT DROP\n    iptables -P FORWARD DROP\n    iptables -P OUTPUT ACCEPT\n    # 注意: 直接设置这三条会掉线\n    # 开启22端口\n    iptables -A INPUT -p tcp --dport 22 -j ACCEPT\n    # 如果OUTPUT 设置成DROP的，要写上下面一条\n    iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT\n    # 注:不写导致无法SSH.其他的端口一样,OUTPUT设置成DROP的话,也要添加一条链\n    # 如果开启了web服务器,OUTPUT设置成DROP的话,同样也要添加一条链\n    iptables -A OUTPUT -p tcp --sport 80 -j ACCEPT\n    # 做WEB服务器,开启80端口 ,其他同理\n    iptables -A INPUT -p tcp --dport 80 -j ACCEPT\n    # 做邮件服务器,开启25,110端口\n    iptables -A INPUT -p tcp --dport 110 -j ACCEPT\n    iptables -A INPUT -p tcp --dport 25 -j ACCEPT\n    # 允许icmp包通过,允许ping\n    iptables -A OUTPUT -p icmp -j ACCEPT (OUTPUT设置成DROP的话)\n    iptables -A INPUT -p icmp -j ACCEPT  (INPUT设置成DROP的话)\n    # 允许loopback!(不然会导致DNS无法正常关闭等问题)\n    IPTABLES -A INPUT -i lo -p all -j ACCEPT (如果是INPUT DROP)\n    IPTABLES -A OUTPUT -o lo -p all -j ACCEPT(如果是OUTPUT DROP)\n\n}\n\ncentos6的iptables基本配置{\n    *filter\n    :INPUT ACCEPT [0:0]\n    :FORWARD ACCEPT [0:0]\n    :OUTPUT ACCEPT [0:0]\n    -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n    -A INPUT -p icmp -j ACCEPT\n    -A INPUT -i lo -j ACCEPT\n    -A INPUT -s 222.186.135.61 -p tcp -j ACCEPT\n    -A INPUT -p tcp  --dport 80 -j ACCEPT\n    -A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT\n    -A INPUT -j REJECT --reject-with icmp-host-prohibited\n    -A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,PSH,URG RST -j DROP\n    -A FORWARD -j REJECT --reject-with icmp-host-prohibited\n    COMMIT\n}\n\n添加网段转发{\n\n    # 例如通过vpn上网\n    echo 1 > /proc/sys/net/ipv4/ip_forward       # 在内核里打开ip转发功能\n    iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j MASQUERADE  # 添加网段转发\n    iptables -t nat -A POSTROUTING -s 10.0.0.0/255.0.0.0 -o eth0 -j SNAT --to 192.168.10.158  # 原IP网段经过哪个网卡IP出去\n    iptables -t nat -nL                # 查看转发\n\n}\n\n端口映射{\n\n    # 内网通过有外网IP的机器映射端口\n    # 内网主机添加路由\n    route add -net 10.10.20.0 netmask 255.255.255.0 gw 10.10.20.111     # 内网需要添加默认网关，并且网关开启转发\n    # 网关主机\n    echo 1 > /proc/sys/net/ipv4/ip_forward       # 在内核里打开ip转发功能\n    iptables -t nat -A PREROUTING -d 外网IP  -p tcp --dport 9999 -j DNAT --to 10.10.20.55:22    # 进入\n    iptables -t nat -A POSTROUTING -s 10.10.20.0/24 -j SNAT --to 外网IP                         # 转发回去\n    iptables -t nat -nL                # 查看转发\n\n}\n",
      "name" : "iptables"
    }, {
      "content" : "rpm -ivh lynx          # rpm安装\nrpm -e lynx            # 卸载包\nrpm -e lynx --nodeps   # 强制卸载\nrpm -qa                # 查看所有安装的rpm包\nrpm -qa | grep lynx    # 查找包是否安装\nrpm -ql                # 软件包路径\nrpm -Uvh               # 升级包\nrpm --test lynx        # 测试\nrpm -qc                # 软件包配置文档\nrpm --import  /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6     # 导入rpm的签名信息\nrpm --initdb           # 初始化rpm 数据库\nrpm --rebuilddb        # 重建rpm数据库  在rpm和yum无响应的情况使用 先 rm -f /var/lib/rpm/__db.00* 在重建\n",
      "name" : "rpm"
    }, {
      "content" : "yum list                 # 所有软件列表\nyum install 包名          # 安装包和依赖包\nyum -y update            # 升级所有包版本,依赖关系，系统版本内核都升级\nyum -y update 软件包名    # 升级指定的软件包\nyum -y upgrade           # 不改变软件设置更新软件，系统版本升级，内核不改变\nyum search mail          # yum搜索相关包\nyum grouplist            # 软件包组\nyum -y groupinstall \"Virtualization\"   # 安装软件包组\nrepoquery -ql gstreamer  # 不安装软件查看包含文件\nyum clean all            # 清除var下缓存\n\nyum使用epel源{\n\n    # 包下载地址: http://download.fedoraproject.org/pub/epel   # 选择版本5\\6\\7\n    rpm -Uvh  http://mirrors.hustunique.com/epel//6/x86_64/epel-release-6-8.noarch.rpm\n\n    # 自适配版本\n    yum install epel-release\n\n}\n\n自定义yum源{\n\n    find /etc/yum.repos.d -name \"*.repo\" -exec mv {} {}.bak \\;\n\n    vim /etc/yum.repos.d/yum.repo\n    [yum]\n    #http\n    baseurl=http://10.0.0.1/centos5.5\n    #挂载iso\n    #mount -o loop CentOS-5.8-x86_64-bin-DVD-1of2.iso /data/iso/\n    #本地\n    #baseurl=file:///data/iso/\n    enable=1\n\n    #导入key\n    rpm --import  /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5\n\n}",
      "name" : "yum"
    }, {
      "content" : "<h4>Add a path for sudo:</h4>\nmodify the path of following code to your desired path, add to /etc/sudoers\n<code>\nDefaults secure_path+=/apollo/env/envImprovement/bin\n</code>",
      "name" : "sudo"
    } ],
    "name" : "Linux"
  }, {
    "expanded" : true,
    "files" : [ {
      "content" : "<code>\n# 编译安装git-1.8.4.4\n./configure --with-curl --with-expat\nmake\nmake install\n\ngit clone git@10.10.10.10:gittest.git  ./gittest/  # 克隆项目到指定目录\ngit status                                         # Show the working tree(工作树) status\ngit log -n 1 --stat                                # 查看最后一次日志文件\ngit branch -a                                      # 列出远程跟踪分支(remote-tracking branches)和本地分支\ngit checkout developing                            # 切换到developing分支\ngit checkout -b release                            # 切换分支没有从当前分支创建\ngit checkout -b release origin/master              # 从远程分支创建本地镜像分支\ngit push origin --delete release                   # 从远端删除分区，服务端有可能设置保护不允许删除\ngit push origin release                            # 把本地分支提交到远程\ngit pull                                           # 更新项目 需要cd到项目目录中\ngit fetch                                          # 抓取远端代码但不合并到当前\ngit reset --hard origin/master                     # 和远端同步分支\ngit add .                                          # 更新所有文件\ngit commit -m \"gittest up\"                         # 提交操作并添加备注\ngit push                                           # 正式提交到远程git服务器\ngit push [-u origin master]                        # 正式提交到远程git服务器(master分支)\ngit tag [-a] dev-v-0.11.54 [-m 'fix #67']          # 创建tag,名为dev-v-0.11.54,备注fix #67\ngit tag -l dev-v-0.11.54                           # 查看tag(dev-v-0.11.5)\ngit push origin --tags                             # 提交tag\ngit reset --hard                                   # 本地恢复整个项目\ngit rm -r -n --cached  ./img                       # -n执行命令时,不会删除任何文件,而是展示此命令要删除的文件列表预览\ngit rm -r --cached  ./img                          # 执行删除命令 需要commit和push让远程生效\ngit init --bare smc-content-check.git              # 初始化新git项目  需要手动创建此目录并给git用户权限 chown -R git:git smc-content-check.git\ngit config --global credential.helper store        # 记住密码\ngit config [--global] user.name \"your name\"        # 设置你的用户名, 希望在一个特定的项目中使用不同的用户或e-mail地址, 不要--global选项\ngit config [--global] user.email \"your email\"      # 设置你的e-mail地址, 每次Git提交都会使用该信息\ngit config [--global] user.name                    # 查看用户名\ngit config [--global] user.email                   # 查看用户e-mail\ngit config --global --edit                         # 编辑~/.gitconfig(User-specific)配置文件, 值优先级高于/etc/gitconfig(System-wide)\ngit config --edit                                  # 编辑.git/config(Repository specific)配置文件, 值优先级高于~/.gitconfig\ngit cherry-pick  &lt;commit id&gt;                       # 用于把另一个本地分支的commit修改应用到当前分支 需要push到远程\ngit log --pretty=format:'%h: %s' 9378b62..HEAD     # 查看指定范围更新操作 commit id\n\n从远端拉一份新的{\n    # You have not concluded your merge (MERGE_HEAD exists)  git拉取失败\n    git fetch --hard origin/master\n    git reset --hard origin/master\n}\n\n</code>",
      "name" : "Basics"
    }, {
      "content" : "1. rename a local branch:\n    if you are on the branch to be renamed:\n   <code>\ngit branch -m newname\n   </code>\n   if you are on a different branch:\n   <code>\ngit branch -m oldname newname\n   </code>\n\n2. delete the old name remote branch and push the new name local branch:\n   <code>\ngit push origin :oldname newname\n   </code>\n\n3. reset the upstream branch for the newname local branch:\n   <code>\ngit push origin -u newname\n   </code>",
      "name" : "rename a branch"
    } ],
    "name" : "Git"
  }, {
    "expanded" : true,
    "name" : "Ansible"
  }, {
    "expanded" : true,
    "name" : "Shell"
  }, {
    "expanded" : true,
    "files" : [ {
      "content" : "groupadd mysql\nuseradd mysql -g mysql -M -s /bin/false\ntar zxvf mysql-5.0.22.tar.gz\ncd mysql-5.0.22\n./configure  --prefix=/usr/local/mysql \\\n--with-client-ldflags=-all-static \\\n--with-mysqld-ldflags=-all-static \\\n--with-mysqld-user=mysql \\\n--with-extra-charsets=all \\\n--with-unix-socket-path=/var/tmp/mysql.sock\nmake  &&   make  install\n# 生成mysql用户数据库和表文件，在安装包中输入\nscripts/mysql_install_db  --user=mysql\nvi ~/.bashrc\nexport PATH=\"$PATH: /usr/local/mysql/bin\"\n# 配置文件,有large,medium,small三个，根据机器性能选择\ncp support-files/my-medium.cnf /etc/my.cnf\ncp support-files/mysql.server /etc/init.d/mysqld\nchmod 700 /etc/init.d/mysqld\ncd /usr/local\nchmod 750 mysql -R\nchgrp mysql mysql -R\nchown mysql mysql/var -R\ncp  /usr/local/mysql/libexec/mysqld mysqld.old\nln -s /usr/local/mysql/bin/mysql /sbin/mysql\nln -s /usr/local/mysql/bin/mysqladmin /sbin/mysqladmin\nln -s -f /usr/local/mysql/bin/mysqld_safe /etc/rc.d/rc3.d/S15mysql5\nln -s -f /usr/local/mysql/bin/mysqld_safe /etc/rc.d/rc0.d/K15mysql5\n",
      "name" : "Installation"
    }, {
      "content" : "./mysql/bin/mysqld_safe --user=mysql &   # 启动mysql服务\n./mysql/bin/mysqladmin -uroot -p -S ./mysql/data/mysql.sock shutdown    # 停止mysql服务\nmysqlcheck -uroot -p -S mysql.sock --optimize --databases account       # 检查、修复、优化MyISAM表\nmysqlbinlog slave-relay-bin.000001              # 查看二进制日志(报错加绝对路径)\nmysqladmin -h myhost -u root -p create dbname   # 创建数据库\n\nflush privileges;             # 刷新\nshow databases;               # 显示所有数据库\nuse dbname;                   # 打开数据库\nshow tables;                  # 显示选中数据库中所有的表\ndesc tables;                  # 查看表结构\ndrop database name;           # 删除数据库\ndrop table name;              # 删除表\ncreate database name;         # 创建数据库\nselect 列名称 from 表名称;      # 查询\nshow processlist;             # 查看mysql进程\nshow full processlist;        # 显示进程全的语句\nselect user();                # 查看所有用户\nshow slave status\\G;          # 查看主从状态\nshow variables;               # 查看所有参数变量\nshow status;                  # 运行状态\nshow table status             # 查看表的引擎状态\nshow grants for dbbackup@'localhost';           # 查看用户权限\ndrop table if exists user                       # 表存在就删除\ncreate table if not exists user                 # 表不存在就创建\nselect host,user,password from user;            # 查询用户权限 先use mysql\ncreate table ka(ka_id varchar(6),qianshu int);  # 创建表\nshow variables like 'character_set_%';          # 查看系统的字符集和排序方式的设定\nshow variables like '%timeout%';                # 查看超时(wait_timeout)\ndelete from user where user='';                 # 删除空用户\ndelete from user where user='sss' and host='localhost' ;    # 删除用户\ndrop user 'sss'@'localhost';                                # 使用此方法删除用户更为靠谱\nALTER TABLE mytable ENGINE = MyISAM ;                       # 改变现有的表使用的存储引擎\nSHOW TABLE STATUS from  库名  where Name='表名';              # 查询表引擎\nmysql -uroot -p -A -ss -h10.10.10.5 -e \"show databases;\"    # shell中获取数据不带表格 -ss参数\nCREATE TABLE innodb (id int, title char(20)) ENGINE = INNODB                     # 创建表指定存储引擎的类型(MyISAM或INNODB)\ngrant replication slave on *.* to '用户'@'%' identified by '密码';               # 创建主从复制用户\nALTER TABLE player ADD INDEX weekcredit_faction_index (weekcredit, faction);     # 添加索引\nalter table name add column accountid(列名)  int(11) NOT NULL(字段不为空);          # 插入字段\nupdate host set monitor_state='Y',hostname='xuesong' where ip='192.168.1.1';     # 更新数据\n\n自增表{\n\n    create table xuesong  (id INTEGER  PRIMARY KEY AUTO_INCREMENT, name CHAR(30) NOT NULL, age integer , sex CHAR(15) );  # 创建自增表\n    insert into xuesong(name,age,sex) values(%s,%s,%s)  # 自增插入数据\n\n}\n\n登录mysql的命令{\n\n    # 格式： mysql -h 主机地址 -u 用户名 -p 用户密码\n    mysql -h110.110.110.110 -P3306 -uroot -p\n    mysql -uroot -p -S /data1/mysql5/data/mysql.sock -A  --default-character-set=GBK\n\n}\n\nshell执行mysql命令{\n\n    mysql -u root -p'123' xuesong < file.sql   # 针对指定库执行sql文件中的语句,好处不需要转义特殊符号,一条语句可以换行.不指定库执行时语句中需要先use\n    mysql -u$username -p$passwd -h$dbhost -P$dbport -A -e \"\n    use $dbname;\n    delete from data where date=('$date1');\n    \"    # 执行多条mysql命令\n    mysql -uroot -p -S mysql.sock -e \"use db;alter table gift add column accountid  int(11) NOT NULL;flush privileges;\"    # 不登陆mysql插入字段\n\n}\n",
      "name" : "Operations"
    }, {
      "content" : "Backup database{\n\n    mysqldump -h host -u root -p --default-character-set=utf8 dbname >dbname_backup.sql               # 不包括库名，还原需先创建库，在use\n    mysqldump -h host -u root -p --database --default-character-set=utf8 dbname >dbname_backup.sql    # 包括库名，还原不需要创建库\n    /bin/mysqlhotcopy -u root -p    # mysqlhotcopy只能备份MyISAM引擎\n    mysqldump -u root -p -S mysql.sock --default-character-set=utf8 dbname table1 table2  > /data/db.sql    # 备份表\n    mysqldump -uroot -p123  -d database > database.sql    # 备份数据库结构\n\n    # 最小权限备份\n    grant select on db_name.* to dbbackup@\"localhost\" Identified by \"passwd\";\n    # --single-transaction  InnoDB有时间戳 只备份开始那一刻的数据,备份过程中的数据不会备份\n    mysqldump -hlocalhost -P 3306 -u dbbackup --single-transaction  -p\"passwd\" --database dbname >dbname.sql\n\n    # xtrabackup备份需单独安装软件 优点: 速度快,压力小,可直接恢复主从复制\n    innobackupex --user=root --password=\"\" --defaults-file=/data/mysql5/data/my_3306.cnf --socket=/data/mysql5/data/mysql.sock --slave-info --stream=tar --tmpdir=/data/dbbackup/temp /data/dbbackup/ 2>/data/dbbackup/dbbackup.log | gzip 1>/data/dbbackup/db50.tar.gz\n\n}\n\nRestore database {\n\n    mysql -h host -u root -p dbname < dbname_backup.sql\n    source 路径.sql   # 登陆mysql后还原sql文件\n\n}",
      "name" : "Backup and Restore"
    }, {
      "content" : "赋权限{\n\n    # 指定IP: $IP  本机: localhost   所有IP地址: %   # 通常指定多条\n    grant all on zabbix.* to user@\"$IP\";             # 对现有账号赋予权限\n    grant select on database.* to user@\"%\" Identified by \"passwd\";     # 赋予查询权限(没有用户，直接创建)\n    grant all privileges on database.* to user@\"$IP\" identified by 'passwd';         # 赋予指定IP指定用户所有权限(不允许对当前库给其他用户赋权限)\n    grant all privileges on database.* to user@\"localhost\" identified by 'passwd' with grant option;   # 赋予本机指定用户所有权限(允许对当前库给其他用户赋权限)\n    grant select, insert, update, delete on database.* to user@'ip'identified by \"passwd\";   # 开放管理操作指令\n    revoke all on *.* from user@localhost;     # 回收权限\n    GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER, EXECUTE, CREATE ROUTINE, ALTER ROUTINE ON `storemisc_dev`.* TO 'user'@'192.168.%'\n\n}\n\n更改密码{\n\n    update user set password=password('passwd') where user='root'\n    mysqladmin -u root password 'xuesong'\n\n}\n\nmysql忘记密码后重置{\n\n    cd /data/mysql5\n    /data/mysql5/bin/mysqld_safe --user=mysql --skip-grant-tables --skip-networking &\n    use mysql;\n    update user set password=password('123123') where user='root';\n\n}\n",
      "name" : "User Management"
    }, {
      "content" : "mysql主从复制失败恢复{\n\n    slave stop;\n    reset slave;\n    change master to master_host='10.10.10.110',master_port=3306,master_user='repl',master_password='repl',master_log_file='master-bin.000010',master_log_pos=107,master_connect_retry=60;\n    slave start;\n}\n\n检测mysql主从复制延迟{\n    1、在从库定时执行更新主库中的一个timeout数值\n    2、同时取出从库中的timeout值对比判断从库与主库的延迟\n}",
      "name" : "Master Slave Replication"
    }, {
      "content" : "select * from information_schema.processlist where command in ('Query') and time >5\\G      # 查询操作大于5S的进程\n\n开启慢查询日志{\n\n    # 配置文件 /etc/my.conf\n    [mysqld]\n    log-slow-queries=/var/lib/mysql/slowquery.log         # 指定日志文件存放位置，可以为空，系统会给一个缺省的文件host_name-slow.log\n    long_query_time=5                                     # 记录超过的时间，默认为10s\n    log-queries-not-using-indexes                         # log下来没有使用索引的query,可以根据情况决定是否开启  可不加\n    log-long-format                                       # 如果设置了，所有没有使用索引的查询也将被记录    可不加\n    # 直接修改生效\n    show variables like \"%slow%\";                         # 查看慢查询状态\n    set global slow_query_log='ON';                       # 开启慢查询日志 变量可能不同，看上句查询出来的变量\n\n}\n\nmysqldumpslow慢查询日志查看{\n\n    -s  # 是order的顺序，包括看了代码，主要有 c,t,l,r和ac,at,al,ar，分别是按照query次数，时间，lock的时间和返回的记录数来排序，前面加了a的时倒序\n    -t  # 是top n的意思，即为返回前面多少条的数据\n    -g  # 后边可以写一个正则匹配模式，大小写不敏感的\n\n    mysqldumpslow -s c -t 20 host-slow.log                # 访问次数最多的20个sql语句\n    mysqldumpslow -s r -t 20 host-slow.log                # 返回记录集最多的20个sql\n    mysqldumpslow -t 10 -s t -g \"left join\" host-slow.log # 按照时间返回前10条里面含有左连接的sql语句\n\n    show global status like '%slow%';                     # 查看现在这个session有多少个慢查询\n    show variables like '%slow%';                         # 查看慢查询日志是否开启，如果slow_query_log和log_slow_queries显示为on，说明服务器的慢查询日志已经开启\n    show variables like '%long%';                         # 查看超时阀值\n    desc select * from wei where text='xishizhaohua'\\G;   # 扫描整张表 tepe:ALL  没有使用索引 key:NULL\n    create index text_index on wei(text);                 # 创建索引\n\n}",
      "name" : "Slow Queries"
    } ],
    "name" : "MySQL"
  }, {
    "expanded" : true,
    "files" : [ {
      "content" : "# 不启动认证\n./mongod --port 27017 --fork --logpath=/opt/mongodb/mongodb.log --logappend --dbpath=/opt/mongodb/data/\n# 启动认证\n./mongod --port 27017 --fork --logpath=/opt/mongodb/mongodb.log --logappend --dbpath=/opt/mongodb/data/ --auth\n\n# 配置文件方式启动\ncat /opt/mongodb/mongodb.conf\n  port=27017                       # 端口号\n  fork=true                        # 以守护进程的方式运行，创建服务器进程\n  auth=true                        # 开启用户认证\n  logappend=true                   # 日志采用追加方式\n  logpath=/opt/mongodb/mongodb.log # 日志输出文件路径\n  dbpath=/opt/mongodb/data/        # 数据库路径\n  shardsvr=true                    # 设置是否分片\n  maxConns=600                     # 数据库的最大连接数\n./mongod -f /opt/mongodb/mongodb.conf\n\n# 其他参数\nbind_ip         # 绑定IP  使用mongo登录需要指定对应IP\njournal         # 开启日志功能,降低单机故障的恢复时间,取代dur参数\nsyncdelay       # 系统同步刷新磁盘的时间,默认60秒\ndirectoryperdb  # 每个db单独存放目录,建议设置.与mysql独立表空间类似\nrepairpath      # 执行repair时的临时目录.如果没开启journal,出现异常重启,必须执行repair操作\n# mongodb没有参数设置内存大小.使用os mmap机制缓存数据文件,在数据量不超过内存的情况下,效率非常高.数据量超过系统可用内存会影响写入性能",
      "name" : "Start"
    }, {
      "content" : "# Method 1:  log into mongodb\n./mongo\nuse admin\ndb.shutdownServer()\n\n# Method 2: kill\nkill -2 pid\nkill -15 pid",
      "name" : "Stop"
    }, {
      "content" : "./mongo                      # 先登录\nuse admin                    # 切换到admin库\ndb.addUser(\"root\",\"123456\")                     # 创建用户\ndb.addUser('zhansan','pass',true)               # 如果用户的readOnly为true那么这个用户只能读取数据，添加一个readOnly用户zhansan\n./mongo 127.0.0.1:27017/mydb -uroot -p123456    # 再次登录,只能针对用户所在库登录\n#虽然是超级管理员，但是admin不能直接登录其他数据库，否则报错\n#Fri Nov 22 15:03:21.886 Error: 18 { code: 18, ok: 0.0, errmsg: \"auth fails\" } at src/mongo/shell/db.js:228\nshow collections                                # 查看链接状态 再次登录使用如下命令,显示错误未经授权\ndb.system.users.find();                         # 查看创建用户信息\ndb.system.users.remove({user:\"zhansan\"})        # 删除用户\n\n#恢复密码只需要重启mongodb 不加--auth参数",
      "name" : "User Management"
    }, {
      "content" : "192.168.1.5:28017      # http登录后可查看状态\n./mongo                # 默认登录后打开 test 库\n./mongo 192.168.1.5:27017/databaseName      # 直接连接某个库 不存在则创建  启动认证需要指定对应库才可登录",
      "name" : "Login"
    }, {
      "content" : "#登录后执行命令查看状态\ndb.runCommand({\"serverStatus\":1})\n    globalLock         # 表示全局写入锁占用了服务器多少时间(微秒)\n    mem                # 包含服务器内存映射了多少数据,服务器进程的虚拟内存和常驻内存的占用情况(MB)\n    indexCounters      # 表示B树在磁盘检索(misses)和内存检索(hits)的次数.如果这两个比值开始上升,就要考虑添加内存了\n    backgroudFlushing  # 表示后台做了多少次fsync以及用了多少时间\n    opcounters         # 包含每种主要擦撞的次数\n    asserts            # 统计了断言的次数\n\n#状态信息从服务器启动开始计算,如果过大就会复位,发送复位，所有计数都会复位,asserts中的roolovers值增加\n\n#mongodb自带的命令\n./mongostat\n    insert     #每秒插入量\n    query      #每秒查询量\n    update     #每秒更新量\n    delete     #每秒删除量\n    locked     #锁定量\n    qr|qw      #客户端查询排队长度(读|写)\n    ar|aw      #活跃客户端量(读|写)\n    conn       #连接数\n    time       #当前时间",
      "name" : "Status"
    }, {
      "content" : "db.listCommands()     # 当前MongoDB支持的所有命令（同样可通过运行命令db.runCommand({\"listCommands\" : `1})来查询所有命令）\n\ndb.runCommand({\"buildInfo\" : 1})                # 返回MongoDB服务器的版本号和服务器OS的相关信息。\ndb.runCommand({\"collStats\" : 集合名})           # 返回该集合的统计信息，包括数据大小，已分配存储空间大小，索引的大小等。\ndb.runCommand({\"distinct\" : 集合名, \"key\" : 键, \"query\" : 查询文档})     # 返回特定文档所有符合查询文档指定条件的文档的指定键的所有不同的值。\ndb.runCommand({\"dropDatabase\" : 1})             # 清空当前数据库的信息，包括删除所有的集合和索引。\ndb.runCommand({\"isMaster\" : 1})                 # 检查本服务器是主服务器还是从服务器。\ndb.runCommand({\"ping\" : 1})                     # 检查服务器链接是否正常。即便服务器上锁，该命令也会立即返回。\ndb.runCommand({\"repaireDatabase\" : 1})          # 对当前数据库进行修复并压缩，如果数据库特别大，这个命令会非常耗时。\ndb.runCommand({\"serverStatus\" : 1})             # 查看这台服务器的管理统计信息。\n# 某些命令必须在admin数据库下运行，如下两个命令：\ndb.runCommand({\"renameCollection\" : 集合名, \"to\"：集合名})     # 对集合重命名，注意两个集合名都要是完整的集合命名空间，如foo.bar, 表示数据库foo下的集合bar。\ndb.runCommand({\"listDatabases\" : 1})                           # 列出服务器上所有的数据库",
      "name" : "Commands"
    }, {
      "content" : "db.currentOp()                  # 查看活动进程\ndb.$cmd.sys.inprog.findOne()    # 查看活动进程 与上面一样\n    opid   # 操作进程号\n    op     # 操作类型(查询\\更新)\n    ns     # 命名空间,指操作的是哪个对象\n    query  # 如果操作类型是查询,这里将显示具体的查询内容\n    lockType  # 锁的类型,指明是读锁还是写锁\n\ndb.killOp(opid值)                         # 结束进程\ndb.$cmd.sys.killop.findOne({op:opid值})   # 结束进程",
      "name" : "Process"
    }, {
      "content" : "./mongoexport -d test -c t1 -o t1.dat                 # 导出JSON格式\n    -c         # 指明导出集合\n    -d         # 使用库\n./mongoexport -d test -c t1 -csv -f num -o t1.dat     # 导出csv格式\n    -csv       # 指明导出csv格式\n    -f         # 指明需要导出那些例\n\ndb.t1.drop()                    # 登录后删除数据\n./mongoimport -d test -c t1 -file t1.dat                           # mongoimport还原JSON格式\n./mongoimport -d test -c t1 -type csv --headerline -file t1.dat    # mongoimport还原csv格式数据\n    --headerline                # 指明不导入第一行 因为第一行是列名\n\n./mongodump -d test -o /bak/mongodump                # mongodump数据备份\n./mongorestore -d test --drop /bak/mongodump/*       # mongorestore恢复\n    --drop      #恢复前先删除\ndb.t1.find()    #查看\n\n# mongodump 虽然能不停机备份,但市区了获取实时数据视图的能力,使用fsync命令能在运行时复制数据目录并且不会损坏数据\n# fsync会强制服务器将所有缓冲区的数据写入磁盘.配合lock还阻止对数据库的进一步写入,知道释放锁为止\n# 备份在从库上备份，不耽误读写还能保证实时快照备份\ndb.runCommand({\"fsync\":1,\"lock\":1})   # 执行强制更新与写入锁\ndb.$cmd.sys.unlock.findOne()          # 解锁\ndb.currentOp()                        # 查看解锁是否正常",
      "name" : "Backup and Restore"
    }, {
      "content" : "# 当停电或其他故障引起不正常关闭时,会造成部分数据损坏丢失\n./mongod --repair      # 修复操作:启动时候加上 --repair\n# 修复过程:将所有文档导出,然后马上导入,忽略无效文档.完成后重建索引。时间较长,会丢弃损坏文档\n# 修复数据还能起到压缩数据库的作用\ndb.repairDatabase()    # 运行中的mongodb可使用 repairDatabase 修复当前使用的数据库\n{\"repairDatabase\":1}   # 通过驱动程序",
      "name" : "Repair"
    } ],
    "name" : "MongoDB"
  }, {
    "expanded" : true,
    "name" : "Redis"
  }, {
    "expanded" : true,
    "name" : "Vim"
  }, {
    "expanded" : true,
    "name" : "ELK"
  }, {
    "expanded" : true,
    "files" : [ {
      "content" : "<code>\n#check tables\n.tables\n\n#set headers on\n.headers on\n\n#set columns mode\n.mode columns\n\n# check cars table schema\n.schema cars\n\n#exit\n.exit\n</code>",
      "name" : "basics"
    } ],
    "name" : "SQLite"
  } ],
  "Python" : [ {
    "expanded" : true,
    "files" : [ {
      "content" : "<code>\nyum install python-pip            # centos/RHEL/Amazon Linux install pip\nsudo apt-get install python-pip   # ubuntu install pip\npip official install (should be latest stable version)\n    wget https://raw.github.com/pypa/pip/master/contrib/get-pip.py\n    python get-pip.py\npip compiling installation\n    # https://pypi.python.org/pypi/setuptools\n    wget http://pypi.python.org/packages/source/s/setuptools/setuptools.tar.gz\n    tar zxvf setuptools.tar.gz\n    cd setuptools/\n    python setup.py build\n    python setup.py install\n    # https://pypi.python.org/pypi/ez_setup\n    tar zxvf ez_setup.tar.gz\n    cd ez_setup/\n    python setup.py build\n    python setup.py install\n    # https://pypi.python.org/pypi/pip\n    tar zxvf pip.tar.gz\n    cd pip/\n    python setup.py build\n    python setup.py install\nConfigure environment variables\n    vim /etc/profile\n    export PATH=/usr/local/python27/bin:$PATH\n    . /etc/profile\n\npip freeze                      # output current package list and versions\npip install Package             # install a package, e.g., pip install requests\npip install Package==1.2.1 # install a package of version 1.2.1\npip install Package &gt; 1.2 # install a package of version higher than 1.2\npip install -r requirements.txt  # requirements file is the output of pip freeze\npip show --files Package        # check what files are installed for a package\npip install --upgrade Package   # upgrade a package\npip install -U Package   # upgrade a package\npip uninstall Package           # uninstall a package\npip list                        # list pip installed package and version\npip list -o                    # list outdated packages\npip list --outdated      # list outdated packages\npip list --format columns    # list all packages with format(legacy(default), columns, freeze, json\npip install django==1.5         # install a certain version of package\n\n#If encountered following problem:\n#----------------------------------\n#OSError: [Errno 1] Operation not permitted: xxxxx\n#----------------------------------\n#use:\npip install package --user -U\n\n#update all packages:\npip freeze --local | grep -v '^\\-e' |cut -d= -f 1 | xargs pip install -U\n\n#only update outdated packages\npip list -o --format columns | awk 'NR &gt; 2{print $1}' | xargs pip install -U --user\n\n# If encountered following problem on OS X\n#---------------------------------\n# fatal error: 'ffi.h' file not found\n#----------------------------------\nbrew install pkg-config libffi\nsudo bash\nexport CFLAGS=-Qunused-arguments\nexport CPPFLAGS=-Qunused-arguments\nexport PKG_CONFIG_PATH=/usr/local/Cellar/libffi/3.0.13/lib/pkgconfig/\npip install bcrypt --user\n\n#then do  you installation again\n</code>\n\n",
      "name" : "pip"
    }, {
      "content" : "<code>\n# !/usr/bin/env python\n# -*- coding:utf-8 -*-\n   \nprint '----------------------方法1--------------------------'\n# 方法1, 实现__new__方法\n# 并在将一个类的实例绑定到类变量_instance上,\n# 如果cls._instance为None说明该类还没有实例化过,实例化该类并返回\n# 如果cls._instance不为None,直接返回cls._instance\n \nclass Singleton(object):\n    def __new__(cls, *args, **kw):\n        if not hasattr(cls, '_instance'):\n            new = super(Singleton, cls)\n            cls._instance = new.__new__(cls, *args, **kw)\n        return cls._instance\n \nclass MyClass(Singleton):\n    a = 1\n \none = MyClass()\ntwo = MyClass()\n \ntwo.a = 3\nprint one.a         # 3\n \n# one和two完全相同,可以用id(), ==, is检测\nprint id(one)       # 140382102515600\nprint id(two)       # 140382102515600\nprint one == two    # True\nprint one is two    # True\n \n \nprint '----------------------方法2--------------------------'\n# 方法2,共享属性;所谓单例就是所有引用(实例、对象)拥有相同的状态(属性)和行为(方法)\n# 同一个类的所有实例天然拥有相同的行为(方法),\n# 只需要保证同一个类的所有实例具有相同的状态(属性)即可\n# 所有实例共享属性的最简单最直接的方法就是__dict__属性指向(引用)同一个字典(dict)\n# 可参看:http://code.activestate.com/recipes/66531/\nclass Singleton2(object):\n    _state = {}\n    def __new__(cls, *args, **kw):\n        ob = super(Singleton2, cls).__new__(cls, *args, **kw)\n        ob.__dict__ = cls._state\n        return ob\n \nclass MyClass2(Singleton2):\n    a = 1\n \none = MyClass2()\ntwo = MyClass2()\n \n# one和two是两个不同的对象,id, ==, is对比结果可看出\ntwo.a = 3\nprint one.a         # 3\n \nprint id(one)       # 140630201217168\nprint id(two)       # 140630201217232\nprint one == two    # False\nprint one is two    # False\n \n# 但是one和two具有相同的（同一个__dict__属性）,见:\nprint id(one.__dict__)      # 140630201186296\nprint id(two.__dict__)      # 140630201186296\n \n \nprint '----------------------方法3--------------------------'\n# 方法3:本质上是方法1的升级（或者说高级）版\n# 使用__metaclass__（元类）的高级python用法\nclass Singleton3(type):\n    def __init__(cls, name, bases, dict):\n        super(Singleton3, cls).__init__(name, bases, dict)\n        cls._instance = None\n         \n    def __call__(cls, *args, **kw):\n        if cls._instance is None:\n            cls._instance = super(Singleton3, cls).__call__(*args, **kw)\n        return cls._instance\n \nclass MyClass3(object):\n    __metaclass__ = Singleton3\n \none = MyClass3()\ntwo = MyClass3()\n \ntwo.a = 3\nprint one.a         # 3\n \nprint id(one)       # 140630201217424\nprint id(two)       # 140630201217424\nprint one == two    # True\nprint one is two    # True\n \n \nprint '----------------------方法4--------------------------'\n# 方法4:也是方法1的升级（高级）版本,\n# 使用装饰器(decorator),\n# 这是一种更pythonic,更elegant的方法,\n# 单例类本身根本不知道自己是单例的,因为他本身(自己的代码)并不是单例的\ndef singleton(cls, *args, **kw):\n    instances = {}\n    def _singleton():\n        if cls not in instances:\n            instances[cls] = cls(*args, **kw)\n        return instances[cls]\n    return _singleton\n \n@singleton\nclass MyClass4(object):\n    a = 1\n    def __init__(self, x=0):\n        self.x = x\n \none = MyClass4()\ntwo = MyClass4()\n \ntwo.a = 3\nprint one.a         # 3\n \nprint id(one)       # 140630201217168\nprint id(two)       # 140630201217168\nprint one == two    # True\nprint one is two    # True\n \none.x = 1\nprint one.x         # 1\nprint two.x         # 1\n</code>",
      "name" : "singleton implementations"
    } ],
    "name" : "Python Basics"
  }, {
    "expanded" : true,
    "name" : "Networking"
  }, {
    "expanded" : true,
    "name" : "Database"
  }, {
    "expanded" : true,
    "files" : [ {
      "content" : "Installation and basic usage\n<code>\neasy_install pymongo      # 安装(python2.7+)\nimport pymongo\nconnection=pymongo.Connection('localhost',27017)   # 创建连接\ndb = connection.test_database                      # 切换数据库\ncollection = db.test_collection                    # 获取collection\n# db和collection都是延时创建的，在添加Document时才真正创建\n</code>\n<hr>\n文档添加, _id自动创建\n<code>\n    import datetime\n    post = {\"author\": \"Mike\",\n        \"text\": \"My first blog post!\",\n        \"tags\": [\"mongodb\", \"python\", \"pymongo\"],\n        \"date\": datetime.datetime.utcnow()}\n    posts = db.posts\n    posts.insert(post)\n    ObjectId('...')\n</code>\n<hr>\n批量插入\n<code>\n    new_posts = [{\"author\": \"Mike\",\n        \"text\": \"Another post!\",\n        \"tags\": [\"bulk\", \"insert\"],\n        \"date\": datetime.datetime(2009, 11, 12, 11, 14)},\n        {\"author\": \"Eliot\",\n        \"title\": \"MongoDB is fun\",\n        \"text\": \"and pretty easy too!\",\n        \"date\": datetime.datetime(2009, 11, 10, 10, 45)}]\n    posts.insert(new_posts)\n    [ObjectId('...'), ObjectId('...')]\n</code>\n获取所有collection\n<code>\n    db.collection_names()    # 相当于SQL的show tables\n</code>\n获取单个文档\n<code>\n    posts.find_one()\n</code>\n查询多个文档\n<code>\n    for post in posts.find():\n        print post\n</code>\n加条件的查询\n<code>\n    posts.find_one({\"author\": \"Mike\"})\n</code>\n高级查询\n<code>\n    posts.find({\"date\": {\"$lt\": \"d\"}}).sort(\"author\")\n</code>\n统计数量\n<code>\n    posts.count()\n</code>\n加索引\n<code>\n    from pymongo import ASCENDING, DESCENDING\n    posts.create_index([(\"date\", DESCENDING), (\"author\", ASCENDING)])\n</code>\n查看查询语句的性能\n<code>\n    posts.find({\"date\": {\"$lt\": \"d\"}}).sort(\"author\").explain()[\"cursor\"]\n    posts.find({\"date\": {\"$lt\": \"d\"}}).sort(\"author\").explain()[\"nscanned\"]\n</code>\n",
      "name" : "MongoDB"
    }, {
      "content" : "https://pypi.python.org/pypi/redis                  # redis的python官网\npip install redis  OR easy_install redis            # 安装\nhttp://redis.readthedocs.org/en/latest/index.html   # redis命令详解\nhttp://redis.readthedocs.org/en/2.4/index.html\n\n<code>\nimport redis\nrds = redis.Redis(host=host, port=port, password=passwd, socket_timeout=10,db=0)\nrds.info()                           # redis信息\nrds.set(key, value)                  # 将值value关联到key\nrds.get(key)                         # 取key值\nrds.del(key1,key2)                   # 删除key\nrds.rename(key,new_key2)             # 将key改名 存在覆盖\nrds.seten(key,value)                 # 将值value关联到key,如果key存在不做任何动作\nrds.setex(key, value, 10800)         # 将值value关联到key,并设置key的过期时间\nrds.mset()                           # 同时设置一个或多个key-value对  如果key存在则覆盖\nrds.msetnx()                         # 同时设置一个或多个key-value对  如果有key存在则失败\nrds.mget(key1, key2, key3)           # 取多个key值   不存在返回nil\nrds.expire(key seconds)              # 设置key的过期时间\nrds.persist(key)                     # 移除key的过期时间\nrds.ttl(key)                         # 查看超时时间 -1为不过期\nrds.sadd(key,value1)                 # 将value1加入集合中  集合不重复\nrds.smembers(key)                    # 返回key中所有成员\nrds.scard(key)                       # 集合中元素的数量\nrds.srandmember(key)                 # 对集合随机返回一个元素 而不对集合改动  当key不存在或key是空集时，返回nil\nrds.sinter(key1,key2)                # 两个集合的交集\nrds.sdiff(key1,key2)                 # 两个集合的差集\nrds.sismember(key,value)             # 判断value元素是否是集合key的成员 1存在 0不存在\nrds.lpush(key,value1)                # 将value1加入列表中  从左到右\nrds.lpop(key,value1)                 # 移除并返回列表key的头元素\nrds.llen(key)                        # 返回列表长度\nrds.sort(key)                        # 对列表、集合、有序集合排序[大列表排序非常影响性能，甚至把redis拖死]\nrds.append(key,value)                # 字符串拼接为新的value\nrds.ltrim(key, 0, -10)               # 保留指定区间内的元素，不在都被删除 0第一个 -1最后一个\nrds.incr(key , amount=1)             # 计数加1 默认1或请先设置key的数值\nrds.decr(key)                        # 计数减1 请先设置key的数值\nrds.save()                           # 保存数据\n</code>",
      "name" : "Redis"
    } ],
    "name" : "NoSQL"
  }, {
    "expanded" : true,
    "name" : "Crawlers"
  }, {
    "expanded" : true,
    "name" : "Concurrency"
  }, {
    "expanded" : true,
    "name" : "Django"
  }, {
    "expanded" : true,
    "name" : "Flask"
  } ],
  "Ruby" : [ {
    "expanded" : true,
    "files" : [ {
      "content" : "Problem: to using rbenv to install ruby, for example version 2.4.0\n<code>\n$rbenv install 2.4.0\n$rbenv rehash\n$rbenv --global 2.4.0\n</code>\nan often encountered problem is that rbenv --global does not work.\nSolution:\nAppend following code to your .bashrc or .bash_profile:\n<code>\nexport PATH=\"$HOME/.rbenv/bin:$PATH\"\neval \"$(rbenv init -)\"\n</code>",
      "name" : "rbenv --global does not work"
    }, {
      "content" : "1. Format number:\n<code>\n//Number.toFixed(x)\nvar profits=2489.8237\nprofits.toFixed(3) //returns 2489.824 (round up)\nprofits.toFixed(2) //returns 2489.82\nprofits.toFixed(7) //returns 2489.8237000 (padding)\n\n//Number.toPrecision()\nvar anumber=123.45\nanumber.toPrecision(6) //returns 123.450 (padding)\nanumber.toPrecision(4) //returns 123.5 (round up)\nanumber.toPrecision(2) //returns 1.2e+2 (you figure it out!)\n</code>\n\n2. Parse string into number:\n<code>\nparseInt(num); // default way (no radix)\nparseInt(num, 10); // parseInt with radix (decimal)\nparseFloat(num) // floating point\nNumber(num); // Number constructor\n~~num //bitwise not\nnum / 1 // diving by one\nnum * 1 // multiplying by one\nnum - 0 // minus 0\n+num // unary operator \"+\"\n</code>",
      "name" : "number"
    }, {
      "content" : "<code>\nprocess.stdin.resume();\nprocess.stdin.setEncoding('ascii');\n\nvar input_stdin = \"\";\nvar input_stdin_array = \"\";\nvar input_currentline = 0;\n\nprocess.stdin.on('data', function (data) {\n    input_stdin += data;\n});\n\nprocess.stdin.on('end', function () {\n    input_stdin_array = input_stdin.split(\"\\n\");\n    main();    \n});\n\n// Reads complete line from STDIN\nfunction readLine() {\n    return input_stdin_array[input_currentline++];\n}\n</code>",
      "name" : "input/output"
    }, {
      "content" : "1. indentation with 2 spaces for each nested level is encouraged but not required.\n2. comments:\n  <i class='fa fa-arrow-circle-right'></i> single line comment: #\n<code>\n#this line is commented\n</code>\n  <i class='fa fa-arrow-circle-right'></i> multiple line comment: =begin && =end\n<code>\n=begin\nthis line is commented\nthis line too\n=end\n</code>\n  \n3. everything is evaluated\n4. puts vs print vs p:\n  <i class='fa fa-arrow-circle-right'></i> puts: print in a line with line break\n  <i class='fa fa-arrow-circle-right'></i> print: print without line break\n  <i class='fa fa-arrow-circle-right'></i> p: print the internal presentation of an object\n\n5. if, else, elsif, unless\n<code>\nx = 6\nunless x == 5\n    puts \"x is not 5\"\nend\n\n# =&gt; x is not 5\n</code>\n\n6. false and nil are false, everything else are true, including 0, '', [], {}\n\n7. triple equal ===:\n<code>\n# 1. regular expression test\nif /sera/ === \"coursera\"\n  puts \"triple equal\"\nend\n# =&gt; triple equal\n\n# 2. type test\nif Integer === 66\n  puts \"66 is Integer\"\nend\n# =&gt;  66 is Integer\n</code>",
      "name" : "ruby basics"
    }, {
      "content" : "<code>\na_multiple_line_string = %Q{ it's a hot day outside\n grab your umbrellas }\n\na_multiple_line_string.lines do |line|\n  line.sub! 'hot', 'rainy'\n  puts \"#{line.strip}\"\nend\n</code>",
      "name" : "string"
    }, {
      "content" : "1. construct an array:\n<code>\narr1 = [2,3,5,8]\narr2 = %w{ hello world ruby }\n</code>\n\n2. retrieve array elements:\n<code>\narray_words = %w{ what a great day today }\n\nputs array_words[3]\n#=&gt; \"great\"\n\nputs array_words[-4]\n#=&gt; \"a\"\n\nputs array_words[1, 2] # take 2 element start from index 1\n#=&gt; a great\n\nputs array_words[2..4] #take elements from index 2 to index 4 both inclusive\n#=&gt;  great day today\n</code>\n\n3. join an array with delimiter\n<code>\narray_words = %w{ what a great day today }\narray_words.join(\"~\")\n#=&gt; \"what~a~great~day~today\"\n</code>\n\n4. modify array\n<code>\n#append: &lt;&lt; or push\narr = [5, 8]\narr.push 10\narr &lt;&lt; 15\np arr\n# =&gt; [5, 8, 10, 15]\n\n#remove: pop or shift\narr.pop\np arr\n# =&gt; [5, 8, 10]\narr.shift\np arr\n# =&gt; [8, 10]\n</code>\n\n5. useful methods:\n.sort\n.sort!\n.sample\n.reverse\n.reverse!\n\n.each\n.select\n.reject\n.map\n<code>\na = [1,3,5,8,10]\na.each { |num| print num } # =&gt; 135810\n\nnew_arr = a.select { |num| num &gt; 4 }\np new_arr # =&gt; [5,8,10]\n\nnew_arr = a.select {|num| num &lt; 10 } .reject { |num| num.even? }\np new_arr # =&gt;[1,3,5]\n\nnew_arr = a.map { |x| x * 3 }\np new_arr # =&gt; [3,9,15,24,30]\n</code>",
      "name" : "array"
    }, {
      "content" : "<code>\nsome_range = 1..3\nputs some_range.max # =&gt; 3\nputs some_range.include? 2 # =&gt; true\n\nputs (1...10) === 5.3 # =&gt; true\nputs ('a'...'r') === \"r\" # false (end-exclusive)\n\np ('a'..'z').to_a.sample(2) # =&gt; [\"m\", \"w\"]\n\nage = 25\ncase age\n  when 10...20 then puts \"teenager\"\n  when 60..99 then puts \"retired\"\nend\n</code>",
      "name" : "range"
    }, {
      "content" : "1. basic usage\n<code>\neditor_props = { \"font\" =&gt; \"arial\", \"size\" =&gt; 12, \"color\" =&gt; \"green\" }\nputs editor_props.length\nputs editor_props[\"font\"]\n\neditor_props[\"background\"] = \"black\"\n\neditor_props.each_pair do |key, value|\n  puts \"Key: #{key}, Value: #{value}\"\nend\n\n\nputs editor_props[\"width\"] # =&gt; nil\n</code>\n\n2. create a hash with default value\n<code>\nword_frequency = Hash.new(0)\n\nsentence = \"hello world world\"\nsentence.split.each do |word|\n  word_frequency[word.downcase] += 1\nend\n\np word_frequency # =&gt; { \"hello\" =&gt; 1, \"world\" =&gt; 2 }\n</code>\n\n3. \n<code>\nfamily = { oldest: \"Jim\", older: \"Joe\", younger: \"Jack\" }\nfamily[:youngest] = \"Jerry\"\n\np family\n# =&gt; {:oldest=&gt;\"Jim\", :older=&gt;\"Joe\", :younger=&gt;\"Jack\", :youngest=&gt;\"Jerry\"}\n\ndef adjust_colors (props = {foreground: \"red\", background: \"white\"})\n  puts \"Foreground: #{props[:foreground}\" if props[:foreground]\n  puts \"Background: ${props[:background]}\" if props[:background]\nend\n\nadjust_colors\n# =&gt;\n# =&gt;\n\nadjust_colors ({ :foreground =&gt; \"green\"})\nadjust_colors background: \"yellow\"\nadjust_colors :background =&gt; \"magenta\"\n\n</code>",
      "name" : "hash"
    }, {
      "content" : "<code>\n# With trailing parens\nx = [1, 2, 3].join(\n  '-'\n)\n\n# With leading dot\nx = [1, 2, 3]\n  .join '-'\n\n# With trailing `=`\nx =\n  [1, 2, 3].join '-'\n\n# I'm not a big fan of the following options but its\n# absolutely OK if you are, choose what you find\n# works best for your situation.\n\n# With trailing dot\nx = [1, 2, 3].\n  join '-'\n\n# With slash\nx = [1, 2, 3].join \\\n  '-'\n\n# With leading `=`, requires slash\nx \\\n  = [1, 2, 3].join '-'\n\n# With leading parens, requires slash\nx = [1, 2, 3].join \\\n  ('-')\n</code>",
      "name" : "How to break long lines up"
    }, {
      "content" : "Blocks are just code that are passed into methods\n<code>\n# explicit \ndef two_times (&a_block)\n  return 'No block' if a_block.nil?\n  a_block.call\n  a_block.call\nend\n\nputs two_times  # =&gt; 'No block'\ntwo_times { print 'hello' }  # =&gt; 'hello hello'\n\n==============================================\n# implicit\ndef two_times\n  return 'No block' unless block_given?\n  yield\n  yield\nend\n\nputs two_times  # =&gt; 'No block'\ntwo_times { print 'hello' }  # =&gt; 'hello hello'\n</code>",
      "name" : "block"
    }, {
      "content" : "Reading files\n<code>\nif File.exist? 'test.txt'\n  File.foreach('test.txt') do |line|\n    puts line # =&gt; The first line of file\n    p line # =&gt; \"The first line of file\\n\"\n    p line.chomp # =&gt; \"The first line of file\"\n    p line.split # =&gt; [\"The\", \"first\",  \"line\",  \"of\",  \"file\"]\n  end\nend\n</code>\n\nWriting files\n<code>\nFile.open(\"test.txt\", \"w\") do |file|\n  file.puts \"line one\"\n  file.puts \"line two\"\nend\n</code>\n\nenvironment variables\n<code>\nputs ENV[\"PATH\"]\n</code>",
      "name" : "files"
    }, {
      "content" : "<code>\nclass Kid\n  attr_accessor :age, :name\nend\n\nclass Class\n  include Enumerable\n\n  attr_accessor :number, :kid\n  \n  def add_kids(*kids)\n    @kids += kids\n  end\n\n  def each\n    @kids.each { |kid| yield kid }\n  end\nend\n</code>\n\n<code>\nclass1 = Class.new\nclass1.add_kids(Kid.new(xxxxx), Kid.new(xxxxx))\n\n# select and reject are from Enumerable module\nspecial_kid = class1.select { |kid| (10..15) == kid.age }\n                    .reject { |kid| kid.name === \"Jack\" }\n</code>",
      "name" : "module"
    } ],
    "name" : "Ruby"
  }, {
    "expanded" : true,
    "files" : [ {
      "content" : "1.check if ActiveRecord result is empty:\n<i class='fa fa-arrow-circle-right'></i> <kbd>empty?</kbd> and <kbd>blank?</kbd> return true if a relation returns no records.\n<i class='fa fa-arrow-circle-right'></i> <kbd>any?</kbd> and <kbd>exists?</kbd> return true if a relation returns one or more records.\n\n2. check the number of records:\n<i class='fa fa-arrow-circle-right'></i> if you already loaded all entries, i.e., <kbd>User.all</kbd>, then you should use <kbd>length</kbd> to avoid another db query.\n<i class='fa fa-arrow-circle-right'></i> if you do not have anything loaded yet, use <kbd>count</kbd> to make a count query on your db.\n<i class='fa fa-arrow-circle-right'></i> Use <kbd>size</kbd> which will adapt to the situations mentioned above.\n\n3. Prerequisites:\n<i class='fa fa-arrow-circle-right'></i> ActiveRecord has to know how to find your database (when Rails is loaded, this info is read from <b>config/database.yml</b>\n<i class='fa fa-arrow-circle-right'></i> (Convention) There is a table with a plural name that corresponds to ActiveRecord::Base subclass with a singular name\n<i class='fa fa-arrow-circle-right'></i> (Convention) Expects the table to have a primary key named <I>id</I>\n\n4. plural form definitions stored at <b>config/initializaer/inflections.rb</b>, i.e., person->people, example file:\n<code>\n# Add new inflection rules using the following format. Inflections are locale specific, \n# and you may define rules for as many different locales as you wish. All of these\n# examples are active by default:\n# ActiveSupport::Inflector.inflections(:en) do |inflect|\n#   inflect.plural /^(ox)$/I, '\\len'\n#   inflect.singular /^(ox(en)/I, '\\1'\n#   inflect.irregular 'person', 'people'\n#   inflect.uncountable %w( fish sheep )\n# end\n\n# These inflection rules are supported but not enabled by default:\n# ActiveSupport::Inflector.inflections(:en) do |inflect|\n#   inflect.acronym 'RESTful'\n# end\n</code>\n\n5. Do not have to kill rails console after a new migration - just call <b>reload!</b>\n\n6. Frequently used methods:\n<code>\nPerson.column_names\n</code>",
      "name" : "ActiveRecord"
    }, {
      "content" : "1. sandbox\n<code>\n# whatever you do will be get rolled back when you exit console\nrails console --sandbox\n</code>\n\n2. last statement\n<code>\n# will execute last expression\n&gt; Employee.first\n&gt; _ \n# as function call\n&gt; _.name.upcase\n&gt; _.as_json\n&gt; _.to_xml\n&gt; _.to_yaml\n</code>\n\n3. reload\n<code>\n# reload your systems without restart console when you changed your project\n&gt; reload!\n</code>\n\n4. store activerecord relation to a variable\n<code>\n# when you store activerecord to a variable, whatever change you do will not show up in the variable because the variable is a stored state of activerecord\n&gt; e = Employee.all\n&gt; e.first.destroy\n&gt; e.first # will show the one destroyed because it's stored in variable e\n&gt; Employee.all.first # actually destroyed if you check \n</code>",
      "name" : "Rails console techniques"
    }, {
      "content" : "Byebug is a nice gem for debugging Ruby 2.\n\nThe most common problem to happen using this gem is the error: ‘Sorry, you can’t use byebug without Readline‘ , lucky for those running Mac OS, this issue can be simply solved by using this command on terminal:\n\n<code>\nln -s /usr/local/opt/readline/lib/libreadline.dylib /usr/local/opt/readline/lib/libreadline.6.dylib\n</code>",
      "name" : "How to solve: Sorry, you can’t use byebug without Readline (Mac OS)"
    }, {
      "content" : "1. migrations are classes that extend ActiveRecord::Migration\n2. file name needs to start with a timestamp(year/month/date/hour/minute/second) and be followed by some name, which becomes the name of the class\n3. the timestamp defines the sequence of how the migrations are applied and acts as a database version of sorts or snapshot in time\n4. example\n<code>\n# filename: 20170507135462_create_cars.rb\nclass CreateCars &lt; ActiveRecord::Migration\n  def change\n    create_table :cars do |t|\n      t.string :make\n      t.string :color\n      t.integer :year\n      t.timestamps null: false\n    end\nend\n</code>\n5. methods:\n<code>\nclass CreateCars &lt; ActiveRecord::Migration\n  def up\n    # code to create table to do changes\n  end\n\n  def change\n    # code to create or do changes, but when do you do db:migrate or db:migrate:rollback, rails will guess what to do, so you don't need up and down methods\n  end\n\n  def down\n    # code to drop table, undo changes\n  end\n</code>\n\n6. data types\n<table class=\"table table-striped table-hover\">\n  <tr>\n    <th>Migration type</th>\n    <th>sqlite3</th>\n    <th>Oracle</th>\n    <th>Postgres</th> \n    <th>Mysql</th>  \n  </tr>\n  <tr>\n    <td>:binary</td>\n    <td>blob</td>\n    <td>blob</td>\n    <td>bytea</td> \n    <td>Mysql</td>  \n  </tr>\n  <tr>\n    <td>:boolean</td>\n    <td>tinyint(1)</td>\n    <td>number(1)</td>\n    <td>boolean</td> \n    <td>Mysql</td>  \n  </tr>\n  <tr>\n    <td>:date</td>\n    <td>date</td>\n    <td>date</td>\n    <td>date</td> \n    <td>Mysql</td>  \n  </tr>\n  <tr>\n    <td>:datetime</td>\n    <td>datetime</td>\n    <td>date</td>\n    <td>timestamp</td> \n    <td>Mysql</td>  \n  </tr>\n  <tr>\n    <td>:decimal</td>\n    <td>decimal</td>\n    <td>decimal</td>\n    <td>decimal</td> \n    <td>Mysql</td>  \n  </tr>\n  <tr>\n    <td>:float</td>\n    <td>float</td>\n    <td>number</td>\n    <td>float</td> \n    <td>Mysql</td>  \n  </tr>  \n<tr>\n    <td>:integer</td>\n    <td>Integer</td>\n    <td>number(38)</td>\n    <td>integer</td> \n    <td>Mysql</td>  \n  </tr>\n  <tr>\n    <td>:string</td>\n    <td>varchar(255)</td>\n    <td>varchar2(255)</td>\n    <td>character varying</td> \n    <td>Mysql</td>  \n  </tr>\n  <tr>\n    <td>:text</td>\n    <td>text</td>\n    <td>clob</td>\n    <td>text</td> \n    <td>Mysql</td>  \n  </tr>\n  <tr>\n    <td>:time</td>\n    <td>datetime</td>\n    <td>date</td>\n    <td>time</td>\n    <td>Mysql</td>  \n  </tr>\n</table>\n\n7. extra column options:\n -> besides specifying logical types, you can specify up to three more options(when the underlying DB supports it)\n -> null: true or false (when false, a  <I>not null</I> constraint is added\n -> limit: size (set a limit on the size of the field)\n -> default: value (default value for the column, only calculated once!)\n -> precision: value (how many total number of digits stored)\n -> scale: value ( where to put the decimal point)\n\n8. table name will always be plural, <b>id</b> column is automatically created to be used as primary key, <b>timestamps</b> methods creates <I>created_at </I>and <I>updated_at </I>columns\n\n9. Adding/Removing columns\n<code>\nclass AddPriceToCars &lt; ActivateRecord::Migration\n  def change\n    add_column :cars, :price, :decimal, precision: 10, scale: 2\n    remove_column :cars, :year\n    rename_column :cars, :old_column_name, :new_column_name\n  end\nend\n</code>",
      "name" : "Migrations"
    }, {
      "content" : "1. Three ways to create a record in the database\n  <i class='fa fa-arrow-circle-right'></i> Use an empty constructor and (ghost) attributes to set the values and then call <kbd>save</kbd>\n  <code>\n  p = Person.new\n  p.name = 'Jack'\n  p.save\n  </code>\n  <i class='fa fa-arrow-circle-right'></i> Pass a hash of attributes into the constructor and then call <kbd>save</kbd>\n  <code>\n  p = Person.new(name: 'Jack')\n  p.save\n  </code>\n  <i class='fa fa-arrow-circle-right'></I>Use <kbd>create</kbd> method with a hash to create an object and save it to the database in one step\n  <code>\n  p = Person.create(name: 'Jack')\n  </code>\n\n2. Retrieve/Read method:\n<I class='fa fa-arrow-circle-right'></I> <b>.find(id)</b> or <b>.find(id1, id2)</b>, will throw 'RecordNotFound' exception when not found.\n<I class='fa fa-arrow-circle-right'></I> <b>.first, .last, .take, all</b>, return the results you expect or <b>nil</b> if nothing is found.\n<I class='fa fa-arrow-circle-right'></I> <b>.order(:column)</b> or <b>.order(column: :desc)</b>\n<I class='fa fa-arrow-circle-right'></I> <b>.pluck</b> allow to narrow down which fields are coming back, need to call at the end.\n  <code>\n  Person.pluck(:first_name)\n  </code>\n<I class='fa fa-arrow-circle-right'></I> <b>.where(hash)</b> , returns ActiveRecord::Relation\n  <code> \n  Person.where(last_name: 'Jack').first\n  Person.where(last_name: 'Jack').pluck(:first_name)\n  </code>\n<I class='fa fa-arrow-circle-right'></I> <b>.find_by(conditions_hash)</b>, same as <b>.where</b>, but returns a single result or nil if a record with the specified conditions is not found\n<I class='fa fa-arrow-circle-right'></I> <b>.find_by!(conditions_hash)</b>, same as <b>.find_by</b>, but throws an exception if cannot find the result\n<I class='fa fa-arrow-circle-right'></I> <b>.limit(n)</b>\n<I class='fa fa-arrow-circle-right'></I> <b>.offset(n)</b>\n\n3. Update: Two ways to update a record in the database:\n <I class='fa fa-arrow-circle-right'></I> Retrieve a record, modify the values and then call save\n <I class='fa fa-arrow-circle-right'></I> Retrieve a record and then call update method passing in a hash of attributes with new values\n  <code>\n   # modify and save\n   jane = Person.find_by first_name: 'Jane'\n   jane.last_name = 'Smith'\n   jane.save\n  \n   # update\n   Person.find_by(last_name: 'Smith').update(last_name: 'Dawson')\n  </code>\n\n4. Delete\n<I class='fa fa-arrow-circle-right'></I> <b>destroy(id)</b> or some_instance.destroy\n<I class='fa fa-arrow-circle-right'></I> <b>delete(id)</b>\n<I class='fa fa-arrow-circle-right'></I> <b>delete_all</b>, will delete all data if you do not specify condition\n\n <code>\n # destroy\n jane = Person.find_by first_name: 'Jane'\n jane.destroy\n \n # delete\n joe = Person.find_by first_name: 'Joe'\n Person.delete(joe.id)\n </code>",
      "name" : "ActiveRecord CRUD"
    }, {
      "content" : "file at db/seeds.db\n<code>\nPerson.destroy_all\n\nPerson.create! [\n { first_name: 'Ross', last_name: 'Geller', age: 30 },\n { first_name: 'Monica', last_name: 'Geller', age: 30 },\n { first_name: 'Rachel', last_name: 'Green', age: 31 },\n { first_name: 'Joey', last_name: 'Tribiani', age: 30 }\n]\n</code>\n\nrun\n<code>\nrake db:seed\n</code>",
      "name" : "seeds database"
    }, {
      "content" : "1. Two alternatives to directly specifying SQL literals:\n <i class='fa fa-arrow-circle-right'></i> Array Conditions Syntax\n  <code>\nPerson.where(\"age BETWEEN ? AND ?\", 28, 35).to_a\n  </code>\n <i class='fa fa-arrow-circle-right'></i> Hash Conditions Syntax\n  <code>\nPerson.where(\"age BETWEEN :min_age AND :max_age\", min_age: 28, max_age: 32).to_a\nPerons.where(\"first_name LIKE :pattern or last_name LIKE :pattern\", pattern: '%Ja%').to_a\n  </code>",
      "name" : "Advance Query"
    }, {
      "content" : "1. one-to-one: \nexample:  person and personal_info\n\n--------------------------------------------\ngenerate command\n<code>\nrails g model personal_info height:float weight: float person: references\n</code>\n--------------------------------------------\nmigration file\n<code>\nclass CreatePersionInfos &lt; ActiveRecord::Migration\n  def change\n    create_table :personal_infos do |t|\n      t.float :height\n      t.float :weight\n      t.references :person, index: true, foreign_key: true\n      t.timestamps null: false\n    end\n  end\nend\n</code>\n------------------------------------------------\nmodels generated:\n<code>\n# person model\nclass Person &lt; ActiveRecord::Base\n  has_one :personal_info\nend\n\n# personal_info model\nclass PersonalInfo &lt; ActiveRecord::Base\n  belongs_to :person\nend\n</code>\n-------------------------------------------------\nbuild or create \n<code>\nbill = Person.find_by last_name: 'Gates'\nbill.build_personal_info height: 5.7, weight: 145.0 # will not save to database right away\nbill.create_personal_info height: 5.7, weight: 145.0 # will save to database immediately\n</code>\n\n2. one-to-many\n<code>\n# person model\nclass Person &lt; ActiveRecord::Base\n  has_one :personal_info, dependent: :destroy\n  has_many :jobs\n  # alternative: has_many :my_jobs, class_name: \"Job\"\nend\n\n# personal_info model\nclass Job &lt; ActiveRecord::Base\n  belongs_to :person\nend\n</code>\n\n3. many-to-many\nhabtm (has_and_belongs_to_many)\nneed to create an extra (a.k.a. join) table (without a model, i.e. just a migration)\nconvention: plural model names separated by an underscore in alphabetical order\n\ncontains 2 models and 3 migrations\nthe join table only exists in database but not ruby code\n\n<code>\nrails g migration create_hobbies_people person:references hobby:references\n</code>\nthe migration generated as:\n<code>\nclass CreateHobbiesPeople &lt; ActiveRecord::Migration\n  def change\n    create_table :hobbies_people, id: false do |t|\n       t.references :person, index: true, foreign_key: true\n       t.references :hobby, index: true, foreign_key: true\n    end\n  end\nend\n</code>\nmodels:\n<code>\nclass Person &lt; ActiveRecord::Base\n  has_and_belongs_to_many :hobbies\nend\n\nclass Hobbies &lt; ActiveRecord::Base\n  has_and_belongs_to_many :people\nend\n</code>\n\n4. has_many, has_one and belongs_to support <b>:dependent</b> option\n:delete - remove associated objects\n:destroy - same as :delete, but remove by calling .destroy on the object\n:nullify - set the foreign key to NULL\n<code>\n# person model\nclass Person &lt; ActiveRecord::Base\n  has_one :personal_info, dependent: :destroy\n  has_many :jobs, dependent: :delete\n  has_one :spouse, dependent: :nullify\n  # alternative: has_many :my_jobs, class_name: \"Job\"\nend\n</code>\n\n5. grand children relation\n<code>\nclass Person &lt; ActiveRecord::Base\n  has_many :jobs\n  has_many :salaries, through: :jobs, source: :salary_range\nend\n\nclass Job &lt; ActiveRecord::Base\n  belongs_to :person\n  has_one :salary_range\nend\n\nclass SalaryRange &lt; ActiveRecord::Base\n  belongs_to :job\nend\n</code>",
      "name" : "Relations"
    }, {
      "content" : "Scopes always return ActiveRecord::Relation\nCan make your ActiveRecord queries very expressive\n\nDefinition:\n<code>\nclass Person &lt; ActiveRecord::Base\n  has_many :jobs\n  has_many :approx_salaries, through: :jobs, source: :salary_range\n\n  def max_salary\n      approx_salaries.maximum(:max_salary)\n  end\n  \n  # define default scope\n  default_scope { order :name }\n\n  # define named scopes\n  scope :order_by_age, -&gt; { order age: :desc }\n  scope :starts_with, -&gt; (start_str) { where(\"first_name LIKE ?\", \"#{start_str}%\") }\nend\n</code>\n\nUsage:\n<code>\n# default scope\nPerson.pluck :age\n\n# unscope\nPerson.unscoped.pluck :name\n\n#named scopes\nPerson.order_by_age.pluck :age\nPerson.order_by_age.starts_with('Jo').pluck :age, :first_name\nPerson.order_by_age.limit(2).starts_with(\"Jo\").pluck :age, :first_name\n \n</code>",
      "name" : "Active Record Scope"
    }, {
      "content" : "1. built-in validations:\n<I class=\"fa fa-arrow-circle-right\"></I> :presence\n<I class=\"fa fa-arrow-circle-right\"></I> :uniqueness\n<I class=\"fa fa-arrow-circle-right\"></I> :numerically\n<I class=\"fa fa-arrow-circle-right\"></I> :length\n<I class=\"fa fa-arrow-circle-right\"></I> :format\n<I class=\"fa fa-arrow-circle-right\"></I> :inclusion\n<I class=\"fa fa-arrow-circle-right\"></I> :exclusion\n\n<code>\nclass Job &lt; ActiveRecord::Base\n  belongs_to :person\n  has_one :salary_range\n\n  validates :title, :company, presence: true, uniqueness: true\nend\n</code>\n\n2. custom validations\nkey word is <b>validate</b>, not <b>validates</b>\n<code>\nclass SalaryRange &lt;ActiveRecord::Base\n  belongs_to :job\n  validate :min_is_less_than_max\n  \n  def min_is_less_than_max\n    if min_salary &gt; max_salary\n      errors.add(:min_salary, \"can not be greater than max salary!\")\n    end\n  end\nend\n</code>\n\n3. errors\n<code>\njob = Job.new\njob.save\njob.errors\n=&gt; #&lt;ActiveModel::Errors:0x007fe0b0b03590 @base=#&lt;Job id:nil, title: nil, company: nil, position_id: nil, person_id: nil, created_at: nil, updated_at: nil&gt; @messages={:title=&gt;[\"can not be blank\"], :company=&gt;[\"can not be blank\"]}&gt;\njob.errors.full_messages\n=&gt; [\"Title can not be blank\", \"Company can not be blank\"]\n</code>",
      "name" : "validations"
    }, {
      "content" : "Named routes from \"Resources :Blogs\"\n<table class=\"table table-striped table-hover\">\n  <tr>\n    <th>HTTP Method</th>\n    <th>Named Routes</th>\n    <th>Parameters</th>\n    <th>Controller</th> \n    <th>Purpose</th>  \n  </tr>\n  <tr>\n    <td>GET</td>\n    <td>blogs_path</td>\n    <td></td>\n    <td>index</td> \n    <td>list all</td>  \n  </tr>\n  <tr>\n    <td>GET</td>\n    <td>blog_path</td>\n    <td>:id</td>\n    <td>show</td> \n    <td>show one</td>  \n  </tr>\n  <tr>\n    <td>GET</td>\n    <td>new_blog_path</td>\n    <td></td>\n    <td>new</td> \n    <td>provide form to input new blog</td>  \n  </tr>\n  <tr>\n    <td>POST</td>\n    <td>blogs_path</td>\n    <td>Record Hash</td>\n    <td>create</td> \n    <td>create new record in DB</td>  \n  </tr>\n  <tr>\n    <td>GET</td>\n    <td>edit_blog_path</td>\n    <td>:id</td>\n    <td>edit</td> \n    <td>provide form to edit blog</td>  \n  </tr>\n  <tr>\n    <td>PUT/PATCH</td>\n    <td>blog_path</td>\n    <td>:id, Record Hash</td>\n    <td>update</td> \n    <td>update record in the DB</td>  \n  </tr>  \n<tr>\n    <td>DELETE</td>\n    <td>blog_path</td>\n    <td>:id</td>\n    <td>destroy</td> \n    <td>remove record</td>  \n  </tr>\n</table>\n",
      "name" : "ActionPack"
    } ],
    "name" : "Rails"
  }, {
    "expanded" : true,
    "files" : [ {
      "content" : "1. installation\n<code>\ngem install rspec\n</code>\n\n2. initialization\n<code>\nrspec --init\n-------------------------------\ncreate .rspec\ncreate spec/spec_helper.rb\n</code>\n\n3. \n<code>\nrspec --format documentation \nor\nrspec -f d\n</code>\n\n4. describe()\n5. before() and after()\n6. setup() and teardown()\n7. it()",
      "name" : "basics"
    }, {
      "content" : "1. be_true / be_false\n2. be_<predicate>, i.e., be_nil, because every object has .nil? method\n3. ",
      "name" : "Rspec matchers"
    } ],
    "name" : "Rspec"
  } ]
}
